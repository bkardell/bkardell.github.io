<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bkardell.com/</id>
    <title>bkardell.com rss feed</title>
    <updated>2024-05-09T13:32:32.709Z</updated>
    <generator>awesome mix</generator>
    <author>
        <name>Brian Kardell</name>
        <email>bkardell@gmail.com</email>
        <uri>https://bkardell.com</uri>
    </author>
    <link rel="alternate" href="http://bkardell.com/"/>
    <link rel="self" href="https://bkardell.com/blog/feed.atom"/>
    <subtitle>Just the bkardell.com rss feed</subtitle>
    <logo>http://bkardell.com/profile.jpg</logo>
    <rights>All rights reserved 2018, Brian Kardell</rights>
    <entry>
        <title type="html"><![CDATA[Brian Specific Failures]]></title>
        <id>https://bkardell.com/blog/BSF.html</id>
        <link href="https://bkardell.com/blog/BSF.html">
        </link>
        <updated>2024-05-09T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[Through my work in Interop, I've been I've been learning stuff about WPT.  Part of this has been driven by a desire to really understand the graph on the main page about browser specific failures (like: which tests?). You might think this is stuff I'd already know, but I didn't.  So, I thought I'd share some of the things I learned along the way, just incase you didn't know either.]]></summary>
        <content type="html"><![CDATA[
    <h1 class="contextual-heading" style="font-size: 2rem;">Brian Specific Failures</h1>
    
    <p class="segue">Through my work in Interop, I've been I've been learning stuff about WPT.  Part of this has been driven by a desire to really understand the graph on the main page about browser specific failures (like: which tests?). You might think this is stuff I'd already know, but I didn't.  So, I thought I'd share some of the things I learned along the way, just incase you didn't know either.</p>

	<p>Did you know that <a href="https://github.com/web-platform-tests/wpt.fyi/blob/main/api/query/README.md">wpt.fyi has lots of ways to query it</a>? It does!</p>

	<p>You can, for example, type <code>nameOfBrowser: fail</code> (or <code>nameOfBrowser: pass</code>) into the search box - and you can even string together several of them to ask interesting questions!</p>
  
    <section class="sectioning">
    	<h2 class="contextual-heading" style="font-size: 2.5rem;">What tests <em>fail in every browser</em>?</h2>

    	<p>It seemed like an interesting question:  Are there tests that fail in <em>every single browser?</em></p>  		
 
    	<p>A query for that might look like: <code>chrome:fail firefox:fail edge:fail safari:fail</code> (using the browsers that are part of Interop, for example).  And, as of this writing, it tells me...</p>  
	    <blockquote> 
	        <p><a href="https://wpt.fyi/results/?label=master&amp;label=experimental&amp;aligned&amp;q=chrome%3Afail%20firefox%3Afail%20edge%3Afail%20safari%3Afail%20">There are 2,724 tests (15,718 subtests) which fail in <em>every single browser</em></a>!</p>
	    </blockquote>

    	<p>Wow.  I didn't expect there to be zero, but that feels like kind of a lot of tests to fail in every browser, doesn't it? How can that even happen? To be totally honest, I don't know! </p>

    	<section class="sectioning">
    		<h3 class="contextual-heading" style="font-size: 3rem;">A chicken and egg problem?</h3>

    		<p>The purpose of WPT is to test conformance to a standard, but this is... tricky.  Tests can be used to discuss specs as they are being written - or highlight things that are yet to be implemented, and WPT doesn't have the same kind of guardrails as specs. Things can get committed there that aren't "real" or yet agreed upon. Frequently the first implementers and experimenters write tests. And, it's not uncommon that then things change - or sometimes the specs just never go anywhere. Maybe those tests sit in a limbo "hoping" to advance?</p>

    		<p><a href="https://web-platform-tests.org/writing-tests/file-names.html">WPT asks</a> that files of early things like this be placed in a <code>/tentative</code> directory or have a <code>.tentative</code> in the names of early things like that which don't have agreement.</p>

    		<p>Luckily thanks to the query API we can see which of the tests above fall into that category by adding <code>is:tentative</code> to our query: <code>chrome:fail firefox:fail edge:fail safari:fail is:tentative</code>). We can see that indeed </p>

    <blockquote>
        <p><a href="https://wpt.fyi/results/?label=master&amp;label=experimental&amp;aligned&amp;q=chrome%3Afail%20firefox%3Afail%20edge%3Afail%20safari%3Afail%20is%3Atentative">348 of the tests (1,911 subtests) that fail in every single browser are marked as tentative</a>. </p>
    </blockquote>
    <p>The query language supports negating parameters with an exclamation, so we can adjust the query (<code>chrome:fail firefox:fail edge:fail safari:fail <em>!is:tentative</em></code>) and see...</p>
    <blockquote>
        <p><a href="https://wpt.fyi/results/?label=master&amp;label=experimental&amp;aligned&amp;q=chrome%3Afail%20firefox%3Afail%20edge%3Afail%20safari%3Afail%20%21is%3Atentative">2,372 tests (13,797 subtests) of the tests that fail in every single browser are not marked as tentative</a>. </p>
    </blockquote>

    <p>So, I guess <code>.tentative</code> doesn't explain most of it (or maybe some of those just didn't follow that guidance). What does? I don't know!</p>

    <p>Poking around, I see there's even 1 ACID test that literally everyone fails. Maybe that's just a bad test at this point? Maybe all of the tests that match this query need reviewed? I don't know!</p>
	</section>

    <p class="note">
        You can also query simply <code>all(status:fail)</code> which will show pretty much the same thing for whatever browsers you happen to be showing.  I like the explicit version for introducing this though as it's very clear from the query itself which "all" I'm referring to about.
    </p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: 2.5rem;">Are there any tests that <em>only pass in one browser?</em></h2>

		<p>I also wondered: Hmm... If there are tests that <em>fail in exactly one browser</em>, and we've just shown there's a bunch that <em>pass in none</em>, how many are there that <em>pass in <em>exactly</em> one</em>? That's pretty interesting to look at too:</p>
	    <ul>
	        <li>5,037 tests (36,446 subtests) which <a href="https://wpt.fyi/results/?label=master&amp;label=experimental&amp;aligned&amp;q=chrome%3Apass%20safari%3Afail%20firefox%3Afail">pass in Chrome, but not in WebKit or Firefox</a>, </li> 
	        <li>1,769 tests (14,273 subtests) which <a href="https://wpt.fyi/results/?label=master&amp;label=experimental&amp;aligned&amp;q=chrome%3Afail%20safari%3Afail%20firefox%3Apass">pass only in Firefox</a> </li>
	        <li>545 tests (3,389 subtests) which pass only in Safari(<a href="https://wpt.fyi/results/?label=master&amp;label=experimental&amp;aligned&amp;q=chrome%3Afail%20safari%3Apass%20firefox%3Afail">https://wpt.fyi/results/?label=master&amp;label=experimental&amp;aligned&amp;q=chrome%3Afail%20safari%3Apass%20firefox%3Afail</a>)</li>
	    </ul>
	    <section class="sectioning">
	    	<h3 class="contextual-heading" style="font-size: 3rem;">Engines and Browsers: Tricky</h3> 
    		
    		<p><em>Often</em> when we're showing results we're using the 3 flagship browsers as a proxy for engine capabilies. We do that a lot - like in the Browsers Specific Failures (BSF) graph at the top of wpt.fyi - but... It's an imperfect proxy.</p>

    		<p>For example, there are also <a href="https://wpt.fyi/results/?label=experimental&amp;label=master&amp;aligned&amp;q=chrome%3Apass%20firefox%3Apass%20edge%3Afail%20safari%3Apass%20">tests that only fail in Edge</a>. As of this writing 1,456 tests (1,727 subtests) of them. </p>

    		<p>Or, there's also <a href="https://wpt.fyi/results/?label=master&amp;label=experimental&amp;product=chrome&amp;product=edge&amp;product=firefox&amp;product=safari&amp;product=webkitgtk&amp;aligned&amp;q=chrome%3Apass%20firefox%3Apass%20edge%3Apass%20safari%3Apass%20gtk%3Afail">tests that fail uniquely in WebKit GTK</a> - 1,459 tests (1,740 subtests) of those.</p>

    		<p>Here's where there's a bit of a catch-22 though.  BSF is really useful for the browser teams, so links like the above are actually very handy if you're on the Edge or GTK teams.  But we can't add those to the BSF chart because it kind of really changes the meaning of the whole thing.  What that kind of wants to be is "Engine Specific Failures", but that's not actually directly measurable.</p>
    	</section>
    </section>
    <section class="sectioning">
    	<h2 class="contextual-heading" style="font-size: 2.5rem;">Brian Specific Failures...</h2>
    	
    	<p>Below is an interesting table which links to query results that show actual tests that report as failing in only one of the three flagship browsers.</p>
    <table>
        <thead>
            <tr>
                <th align="left">Browser</th>
                <th align="left">Non-tentative Subtests which uniquely fail among these browsers</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td align="left">Chrome</td>
                <td align="left"><a href="https://wpt.fyi/results/?label=master&amp;label=experimental&amp;product=chrome&amp;product=firefox&amp;product=safari&amp;aligned&amp;q=chrome%3Afail%20firefox%3Apass%20safari%3Apass">1,345 tests (12,091 subtests)</a></td>
            </tr>
            <tr>
                <td align="left">Firefox</td>
                <td align="left"><a href="https://wpt.fyi/results/?label=master&amp;label=experimental&amp;product=chrome&amp;product=firefox&amp;product=safari&amp;aligned&amp;q=chrome%3Apass%20firefox%3Afail%20safari%3Apass%20%21is%3Atentative">2,290 tests (16,791 subtests)</a></td>
            </tr>
            <tr>
                <td align="left">Safari</td>
                <td align="left"><a href="https://wpt.fyi/results/?label=master&amp;label=experimental&amp;product=chrome&amp;product=firefox&amp;product=safari&amp;aligned&amp;q=chrome%3Apass%20firefox%3Apass%20safari%3Afail">4,263 tests (14,867 subtests)</a></td>
            </tr>
        </tbody>
    </table>

    <p>If that sounds like the data for the Browser Specific Failures (BSF) graph on the front page of wpt.fyi, yes.  And no.  I call this the "Brian Specific Failures" (BSF) table.</p>

    <figure class="captioned-image">
    	<img src="/media/2024/isthisthedata.jpg">
    </figure>

    <p>I think that this is about as close as we're probably going to get in the short term to a linkable set of tests that fail, if you'd like to explore them.  The BSF graph is also, I believe, more disciminating than just "pass" and "fail" that we're showing here.  Like, what do you do if a test times out? Are there intermediate or currently unknown statuses?</p>

    <p>It was also kind of interesting, for me at least, while looking at the data, to realize just how different the situation looks depending on whether you are looking at tests, or subtests. Firefox fails the most subtests, but Safari fails the most tests.  BSF "scores" subtests as decimal values of a whole test.</p>

    <p>It's pretty complicated to pull any of this off actually. Things go wrong with tests and runs, and so on. I also realized that all of these scores are inherently a little imperfect.</p>

	<p>For example, if you at the top of the page, it says (as I am writing this) there are 55,176 tests (1,866,346 subtests)</p>

    <figure class="captioned-image">
    	<img src="/media/2024/wpt-1.png" alt="&quot;Showing 55176 tests (1866346 subtests)&quot;">
    </figure>
    
    <p>But if you look to the bottom of the screen, the table has a summary with the passing/total subtests for each browser. As I am writing this it says: </p>
    
    <figure class="captioned-image"><img src="/media/2024/wpt-2.png" alt="chrome: 1836812 / 1890027, edge: 1834777 / 1887771, firefox: 1786949 / 1868316, safari: 1787112 / 1879926">
    </figure>

    <p>You might note that <em>none of those lists the same number of subtests</em>!</p>

	</section>

	<p>Anyway, it was an interesting rabbit hole to dive into!  I have further thoughts on the WPT.fyi dashboard page which I'll share in another post, but I'd love to hear of any interesting queries that you come up with or questions you have. I probably don't know the answers, but I'll try to help find them!</p>

]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Known Knowns]]></title>
        <id>https://bkardell.com/blog/known-knowns.html</id>
        <link href="https://bkardell.com/blog/known-knowns.html">
        </link>
        <updated>2024-05-04T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[Fun with the DOM, the parser, illogical trees and "unknowns"...]]></summary>
        <content type="html"><![CDATA[
    <h1 class="contextual-heading" style="font-size: 2rem;">Known Knowns</h1>
    <p class="segue">Fun with the DOM, the parser, illogical trees and "unknowns"...</p>
    <script src="../prism.js"></script>
    <link rel="stylesheet" href="../prism.css">
    
    
    <p>HTML has this very tricky parser that does 'corrections' and things on the fly. So if you create a page like:</p>
    <pre><code class="language-html">&lt;table&gt;
   Hello
   &lt;td&gt;
      Look below...
   &lt;/td&gt;
&lt;/table&gt;
</code></pre>
    <p>And load it in your browser, what you'll actually get parsed as a tree will be </p>
    <ul class="domTree">
        <li class="t1"><code class="language-html">HTML</code>
            <ul>
                <li class="t1"><code class="language-html">HEAD</code></li>
                <li class="t1"><code class="language-html">BODY</code>
                    <ul>
                        <li class="t3"><code class="language-html">#text</code>: <span>
                                Hello
                            </span></li>
                        <li class="t1"><code class="language-html">TABLE</code>
                            <ul>
                                <li class="t1"><code class="language-html">TBODY</code>
                                    <ul>
                                        <li class="t1"><code class="language-html">TR</code>
                                            <ul>
                                                <li class="t1"><code class="language-html">TD</code>
                                                    <ul>
                                                        <li class="t3"><code class="language-html">#text</code>: <span>
                                                                Look below...
                                                            </span></li>
                                                    </ul>
                                                </li>
                                                <li class="t3"><code class="language-html">#text</code>: <span>
                                                    </span></li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
    <p>Things can literally be moved around, implied elements added and so on. </p>
    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: 2.5rem;">Illogical trees</h2>
        <p>But it's not impossible to create trees that are impossible to create with the parser itself, if you do it dynamically. With the DOM API, you can create whatever wild constructs you want: Paragraphs inside of paragraphs? Sure, why not.</p>
        <p>Or, <a href="https://software.hixie.ch/utilities/js/live-dom-viewer/?%3C!DOCTYPE%20html%3E%0A%3Ctable%20id%3D%22one%22%3E%3C%2Ftable%3E%0A%0A%3Cscript%3E%0A%20%20%20one.appendChild(%0A%20%20%20%20%20document.createTextNode(%22test%22)%0A%20%20%20)%0A%3C%2Fscript%3E">text that is a direct child of a table</a>. Note this still renders the text in every browser engine.</p>
        <p>You can even add children to 'void' elements that way too. Here's an interesting one: <a href="https://software.hixie.ch/utilities/js/live-dom-viewer/?%3C!DOCTYPE%20html%3E%0A%3Chr%20id%3D%22one%22%3E%0A%0A%3Cscript%3E%0A%20%20%20one.appendChild(%0A%20%20%20%20%20document.createTextNode(%22test%22)%0A%20%20%20)%0A%3C%2Fscript%3E">An <code>&lt;hr&gt;</code> with a text node child</a>. Again, It renders the text in every browser engine (the color varies).</p>
        <p>You can also put unknown elements into your markup and the text content is shown... By default, it is basically a <code>&lt;span&gt;</code>.</p>
        <p>In <em>most cases</em>, HTML wants to show something... or at least leave CSS in control. For example, you can dynamically add children to a <code>&lt;script&gt;</code>. While that won't be shown by default, it's simply because the UA style sheet has script set to <code>display: none;</code>. If we change that, <a href="https://software.hixie.ch/utilities/js/live-dom-viewer/?%3C!DOCTYPE%20html%3E%0A%3Cstyle%3E%0A%20%20%20script%20%7B%20display%3A%20block%3B%20%7D%0A%3C%2Fstyle%3E%0A%3Cbody%3E%0A%20%20%3Cdiv%20id%3Dtwo%20style%3D%22background%3A%20pink%22%3EInteresting!%3C%2Fdiv%3E%0A%3Cscript%20id%3D%22one%22%3E%0A%20%20%20one.appendChild(two)%0A%3C%2Fscript%3E">we can totally see it</a>.</p>
        <p>But this isn't universal: In some cases there are other renderers that are in control - mainly when it comes to form controls. But also, for example, if you switch the <code>&lt;hr&gt;</code> in the example above to a <code>&lt;br&gt;</code> it won't render the text. It doesn't generate a box that you can do anything with with CSS as far as I can tell, except make it <code>display: none</code> (useful if they’re in <code>white-space: pre</code> blocks to keep them from forcing open extra lines).
    </p></section>
    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: 2.5rem;">SVG</h2>
        <p>The HTML parser has fix ups for embedding SVG too, there are kind of integration points. But, in SVG you can have an unknown element too... For example:</p>
        <pre><code class="language-html">&lt;svg&gt;
    &lt;unknown&gt;Test&lt;unknown&gt;
    &lt;rect width="150" height="150" x="10" y="10" style="fill:blue;stroke:pink;stroke-width:5;opacity:0.5" /&gt;
&lt;/svg&gt;
</code></pre>
        <p>The unknown element won't render the text, nor additional SVG children inside it. For example:</p>
        <pre><code class="language-html">&lt;svg id=one width="300" height="170"&gt;
  &lt;unknown&gt;&lt;ellipse cx="120" cy="80" rx="100" ry="50" style="fill:yellow;stroke:green;stroke-width:3" /&gt;&lt;/unknown&gt;
&nbsp; &lt;rect width="150" height="150" x="10" y="10" style="fill:blue;stroke:pink;stroke-width:5;opacity:0.5" /&gt;
&lt;/svg&gt;
</code></pre>
    </section>
    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: 2.5rem;">MathML</h2>
        <p>As you might expect, there are parser integrations for MathML too, and you can have an unknown elements in MathML too. In MathML, all elements (including unknown ones) generate a "math content box", but only <em>token</em> elements (like <code>&lt;mi&gt;</code>, <code>&lt;mo&gt;</code>, <code>&lt;mn&gt;</code>) render text. For example, the <code>&lt;math&gt;</code> element itself - if you try to put text in it, the text won't render, but it will still generate a box and other content.</p>
        <pre><code class="language-html">&lt;math&gt;
   Not a token. Doesn't render.
   &lt;mi&gt;X&lt;/mi&gt;
&lt;/math&gt;
</code></pre>
        <p>MathML has other elements too like <code>&lt;mrow&gt;</code> and <code>&lt;mspace&gt;</code> and <code>&lt;mphantom&gt;</code> which are just containers. Same story there, if you try to put text in them, the text won't render... </p>
        <pre><code class="language-html">&lt;math&gt;
   &lt;mrow&gt;Not a token. Doesn't render.&lt;/mrow&gt;
   &lt;mi&gt;X&lt;/mi&gt;
&lt;/math&gt;
</code></pre>
        <p><em>But</em> if you put the text inside a token element (like <code>&lt;mi&gt;</code>) inside that same <code>&lt;mrow&gt;</code>, then the text will render..</p>
        <pre><code class="language-html">&lt;math&gt;
   &lt;mrow&gt;&lt;mi&gt;ok&lt;/mi&gt;&lt;/mrow&gt;
   &lt;mi&gt;X&lt;/mi&gt;
&lt;/math&gt;
</code></pre>
        <p>In MathML, unknown elements are basically treated just like <code>&lt;mrow&gt;</code>. In the above examples, you could replace <code>&lt;mrow&gt;</code> with <code>&lt;unknown&gt;</code> and it'd be the same.</p>
    </section>
    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: 2.5rem;">Unknown Unknowns</h2>
        <p>Ok, here's something you don't think about every day: Given this markup:</p>
        <pre><code class="language-html">&lt;unknown id=one&gt;One&lt;/unknown&gt;
&lt;math&gt;
  &lt;unknown id=two&gt;Two&lt;/unknown&gt;
&lt;/math&gt;
&lt;svg&gt;
  &lt;unknown id=three&gt;Three&lt;/unknown&gt;
&lt;/svg&gt;
</code></pre>
        <p><code>One</code>, <code>Two</code> and <code>Three</code> are <strong><em>three different kinds of unknowns</em></strong>!</p>
        <pre><code class="language-javascript">console.log(one.namespaceURI, one.constructor.name)
// logs 'http://www.w3.org/1999/xhtml HTMLUnknownElement'

console.log(two.namespaceURI, two.constructor.name)
// logs 'http://www.w3.org/1998/Math/MathML MathMLElement'

console.log(three.namespaceURI, three.constructor.name)
// logs 'http://www.w3.org/2000/svg SVGElement`
</code></pre>
        <p>In CSS, these can also (theoretically) be styled via namespaces. The following will only style the first of those:</p>
        <pre><code class="language-css">@namespace html url(http://www.w3.org/1999/xhtml);
html|unknown { color: blue; }
</code></pre>
    </section>
    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: 2.5rem;">Under-defined Unknowns</h2>
        <p>Remember how in the beginning we created nonsensical constructs dynamically? Well, we can do that here too. We can move an unknown <code>MathMLElement</code> right into HTML, or an unknown <code>HTMLElement</code> right into MathML, and so on - and it's not currently well-defined, universal, or consistent what actually happens here.</p>
        <p><a href="https://codepen.io/briankardell/pen/ExJzOXK">Here's an interesting example</a> moves an unknown <code>MathMLElement</code> and a <code>SVGElement</code> into HTML, and an <code>HTMLElement</code> into MathML and so on</p>
        <p class="codepen" data-height="300" data-default-tab="html,result" data-slug-hash="ExJzOXK" data-user="briankardell" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
            <span>See the Pen <a href="https://codepen.io/briankardell/pen/ExJzOXK">
                    Untitled</a> by вкαя∂εℓℓ (<a href="https://codepen.io/briankardell">@briankardell</a>)
                on <a href="https://codepen.io">CodePen</a>.</span>
        </p>
        <script async="" src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
        <p> Here's how that renders in the various today:</p>
        <figure>
            <img src="https://notes.igalia.com/uploads/331613fd-0d93-4126-a746-646b3aa114f9.png">
            <figcaption>Left to right: Chrome, Firefox, Safari all render differently</figcaption>
        </figure>
        <p>So, I guess we should probably fix that. I'll have to start creating some issues and tentative tests (feel free to beat me to it 😉)</p>
    </section>
    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: 2.5rem;">Semi-related Rabbit Holes</h2>
        <p>Not specifically these issues, but related namespace stuff has caused a lot of problems that we're remedying as shown by a recent flurry of activity started by my colleague Luke Warlow to fix MathML-Core support in various libraries/frameworks:</p>
        <ul>
            <li><a href="https://github.com/sveltejs/svelte/pull/11387">Svelte 5</a></li>
            <li><a href="https://github.com/preactjs/preact/pull/4364">Preact</a> </li>
            <li><a href="https://github.com/angular/angular/issues/55608">Angular</a></li>
            <li><a href="https://github.com/lit/lit/pull/4637">Lit</a></li>
        </ul>
        <p>Who's next? :)</p>
    </section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mirror Effects]]></title>
        <id>https://bkardell.com/blog/mirror-effects.html</id>
        <link href="https://bkardell.com/blog/mirror-effects.html">
        </link>
        <updated>2024-04-22T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[Today I had this thought about "AI" that felt more like a short blog post than a social media thread, so I thought I'd share it.]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: 2rem;">Mirror Effects</h1>
	<p class="segue">Today I had this thought about "AI" that felt more like a short blog post than a social media thread, so I thought I'd share it.</p>

	<p>I love learning and thinking about weird indirect connections like how thing X made things Y and Z suddenly possible, and given some time these had secondary or tertiary impacts that were really unexpected.</p>

	<p>There are so many possible examples:  We didn't really expect the web and social media to give rise to the Arab Spring.  Nor to such disinformation.  Nor the 2016 American election (or several others similarly around the world).  Maybe Carrier didn't expect that the invention of air conditioning would help reshape the American political map, <a href="https://www.pbs.org/newshour/show/did-air-conditioning-play-a-role-in-reagans-election-searching-for-ripple-effects-of-history-making-tech">but it did</a>.</p>

	<p>One of the things that came to my mind today  was a thing I read about mirrors.  Ian Mortimer explains how improvements to and the spread of mirrors radically changed lots of things. Here's a quote from the piece:

	</p><blockquote>
	The very act of a person seeing himself in a mirror or being represented in a portrait as the center of attention encouraged him to think of himself in a different way. He began to see himself as unique. Previously the parameters of individual identity had been limited to an individual’s interaction with the people around him and the religious insights he had over the course of his life. Thus individuality as we understand it today did not exist;  people only understood their identity in relation to groups—their household, their manor, their town or parish—and in relation to God... 
	<cite><a href="https://www.laphamsquarterly.org/roundtable/mirror-effect">The Mirror Effect</a></cite>
	</blockquote>

	<p>It's pretty interesting to look back and observe all of the changes that this began to stir - from the way people literally lived (more privacy), to changes in the types of writing and art, and how we thought about fitting in to the larger world (and thus the societies we built).</p>

	<p>So, today I had this random thought that I wonder what sorts of effects like these will come from all of the "AI" focus. That is, not the common/direct sorts of things we're talking about but the ones that maybe have very little to do with any actual technology even.  Which things will some future us look back on in 20 or 100 years and say "huh, interesting".</p>

	<p>In particular, the thing that brought this to mind is that I am suddenly seeing lots of more people suddenly having conversations like "What is consciousness though, really?" and "What is intelligence, really?". I don't mean from technologists, I just mean it seems to be causing lots more people to suddenly think about that kind of thing.</p>

	<p>So it made me think: I wonder if we will see increased signups for philosophy courses? Or,  sales of more books along these lines?  Could that ultimately lead to another, similar sort of changing in how we collectively see ourselves?  I wonder what effects this has in the long term on literature, film, or even science and government.</p>

	<p>This isn't a "take" - it's not trying to be optimistic or pessimistic.  It's more of a "huh... I hadn't thought much about that before, but it's kind of interesting to think about."  Don't you think?  Outside of the normal sorts of things we're obviously thinking about - what are some you could imagine?</p>

	<p>As a kind of final interesting note: Stephen Johnson is a great storyteller, and his work is full of connections like these.  If you want to read more, <a href="https://en.wikipedia.org/wiki/Steven_Johnson_(author)#Books">check out his books</a>.  Part of the reason that I mention him is that interestingly, it seems that he <a href="https://stevenberlinjohnson.com/writing-at-the-speed-of-thought-21dfb7f689e4">has recently gone to work with Google on a LM project about writing himself</a>. I bet he's got some notes and ideas on this already too.</p> 

]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Blessing of the Strings]]></title>
        <id>https://bkardell.com/blog/blessing-strings.html</id>
        <link href="https://bkardell.com/blog/blessing-strings.html">
        </link>
        <updated>2024-04-03T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[Trusted Types have been a proposal by Google for quite some time at this point, but it's currently getting a lot of attention and work in all browsers (Igalia is working on implementations in WebKit and Gecko, sponsored by Salesforce and Google, respectively). I've been looking at it a lot and thought it's probably something worth writing about.]]></summary>
        <content type="html"><![CDATA[
    <h1 class="contextual-heading" style="font-size: 2rem;">The Blessing of the Strings</h1>
    <p class="segue">Trusted Types have been a proposal by Google for quite some time at this point, but it's currently getting a lot of attention and work in all browsers (Igalia is working on implementations in WebKit and Gecko, sponsored by Salesforce and Google, respectively). I've been looking at it a lot and thought it's probably something worth writing about.</p>
    <script src="../prism.js"></script>
    <link rel="stylesheet" href="../prism.css">
    
    <p>The Trusted Types proposal is about preventing Cross-site scripting (XSS), and rides atop Content Security Policy (CSP) and allows website maintainers to say "require trusted-types". Once required, lots of the Web Platform's dangerous API surfaces ("sinks") which currently require a string will now require... well, a <em>different</em> type.</p>
    <p><code>myElement.innerHTML</code> (and a whole lot of other APIs) for example, would now require a <code>TrustedHTML</code> object instead of just a string.</p>
    <p>You can think of <code>TrustedHTML</code> as an interface indicating that a string has been somehow specially "blessed" as safe... Sanitized.</p>
    <figure class="captioned-image">
    	<img src="/media/2024/holy.gif" style="width:100%;max-width:800px;" alt="the Holy Hand grenade scene from Monty Python's Holy Grail">
    	<figcaption>And Saint Attila raised the string up on high, saying, 'O Lord, bless this thy string, that with it we may trust that it is free of XSS...' <a href="https://www.youtube.com/watch?v=xOrgLj9lOwk">[ref]</a>.</figcaption>
    </figure>
    <section class="sectioning">
        <h2 class="contextual-heading" id="blessing-strings" style="font-size: 2.5rem;">Granting Blessings</h2>
        <p>The interesting thing about this is how one goes about blessing strings, and how this changes the dynamics of development and safety to protect from XSS.</p>
        <p>To start with, there is a new global <code>trustedTypes</code> object (available in both window and workers) with a method called <code>.createPolicy</code> which can be used to create "policies" for blessing various kinds of input (<code>createHTML</code>, <code>createScript</code>, and <code>createScriptURL</code>). Trusted Types comes with the concept of a <em>default</em> policy, and the ability for you to register a specially named "default"...</p>
        <pre><code class="language-javascript">//returns a policy, but you 
// don't really need to do anything 
// with the default one
trustedTypes.createPolicy(
    "default", 
    {
      createHTML: s =&gt; { 
          return DOMPurify.sanitize(s) 
      } 
    }
);</code></pre>
        <p>And now, the practical upshot is that <em>all attempts to set HTML will be sanitized</em>... So if there's some code that tries to do:</p>
        <pre><code class="language-javascript">// if str contains
// `&amp;lt;img src="no" onerror="&lt;em&gt;dangerous code&lt;/em&gt;" &amp;gt;`;
target.innerHTML =  str;</code></pre>
        <p>Then the <code>onerror</code> attribute will be <em>automatically</em> stripped (sanitized) before <code>.innerHTML</code> gets it.</p>
        
        <p><strong><em>Hey that's pretty cool!</em></strong></p>

        <figure class="captioned-image">
    		<img src="/media/2024/monty.gif" style="width:100%;max-width:400px;" alt="one of the scenes where the castle guard is mocking arthur and his men">
    		<figcaption>It's almost like you just put defenses around all that stuff and can just peer over the wall at would be attackers and make faces at them....</figcaption>
    	</figure>

        <p>But wait... can't someone come along then and just create a more lenient policy called default?</p>
        
        <p>No! That will throw an exception!</p>

        <p>Also, you don't <em>have</em> to create a default. If you don't, and someone tries to use one of those methods to assign a string, it will throw.</p>

        <p>The only thing this enforcement cares about is that it is one of these "blessed" types. Website administrators can also provide (in the header) the name of 1 or more policies which should be created. </p>

        <p>Any attempts to define a policy not in that list will throw (it's a bit more complicated than that, see <a href="#name-your-policy">Name your Policy</a> below). Let's imagine that in the header we specified that a policy named "sanitize" is allowed to be created. </p>
        <p>Maybe you can see some of why that starts to get really interesting. In order to use any of those APIs (at all), you'd need access to a policy in order to bless the string. But because the policy which can do that blessing is a handle, it's up to you what code you give it to... </p>
        <pre><code class="language-javascript">{
  const sanitizerPolicy = 
      trustedTypes.createPolicy(
        "sanitize",
        {
          createHTML: s =&gt; { 
            return DOMPurify.sanitize(s) 
        } 
  );


    // give someOtherModule access to a sanitization policy
    someOtherModule.init(sanitizerPolicy)

    // yetAnotherModule can't even sanitize, any use of those
    // APIs will throw
    yetAnotherModule.foo()
}

// Anything out here also doesn't have 
// access to a sanitization policy
</code></pre>
        <p>What's interesting about this is that the thing doing the trusting on the client, is actually <em>on</em> the client as well - but the pattern ensures that this becomes a considerably more finite problem. It is much easier to audit whether the "trust" is warranted. That is, we can look at the above to see that there is only one policy and it only supports creating HTML. We can see that the trust there is placed in DOMPurify, and even that amount of trust is only provided to select modules.</p>
        <p>Finally, most importantly: It is a pattern that is machine enforceable. Anything that tries to use any of those APIs without a blessed string (a Trusted Type) will fail... Unless you ask it not to.</p>
    </section>
    <section class="sectioning">
        <h2 class="contextual-heading" id="dont-throw-just-help" style="font-size: 2.5rem;">Don't Throw, Just Help?</h2>
        <p>Shutting down all of those APIs after the fact is hard because all of those dangerous APIs are also really useful and therefore widely used. As I said earlier, auditing to find and understand all uses of them all is pretty difficult. Chances are pretty good that there might just be a lot more unsafe stuff floating around in your site than you expected.</p>
        <p>Instead of <code>Content-Security-Policy</code> CSP headers, you can send <code>Content-Security-Policy-Report-Only</code> and include a directive that includes <code>report-to /csp-violation-report-endpoint/</code> where <code>/csp-violation-report-endpoint/</code> is an endpoint path (on the same origin). If set, whenever violations occur, browsers should send a request to <a href="https://w3c.github.io/webappsec-csp/#report-violation">report a violation</a> to that endpoint (JSON formatted with lots of data). </p>
        <p>The general idea is that it is then pretty easy to turn this on and monitor your site to discover where you might have some problems, and begin to work through them. This should be especially good for your QA environment. Just keep in mind that the report doesn't actually prevent the potentially bad things from happening, it just lets you know they exist.</p>
    </section>
    <section class="sectioning">
        <h2 class="contextual-heading" id="shouldnt-there-just-be-a-standard-santizer-too" style="font-size: 2.5rem;">Shouldn't there just <em>be</em> a standard santizer too?</h2>
        <p><a href="https://github.com/WICG/sanitizer-api">Yes!! That is also a thing that is being worked on</a>.</p>
    </section>
    <section class="sectioning">
        <h2 class="contextual-heading" id="name-your-policy" style="font-size: 2.5rem;">Name Your Policy</h2>
        <p>I'm not going to lie, I found CSP/headers to be both a little confusing to read and to figure out their relationships. You might see a header set up to report only....</p>
        <p><code>Content-Security-Policy-Report-Only: report-uri /csp-violation-report-endpoint; default-src 'self'; require-trusted-types-for 'script'; trusted-types one two;</code></p>
        <p>Believe it or not that's a fairly simple one. Basically though, you split it up on semi-colons and each of those is a directive. The directive has a name like "report-uri" followed by whitespace and then a list of values (potentially containing only 1) which are whitespace separated. There are also keyword values which are quoted.</p>
        <p>So, the last two parts of this are about Trusted Types. The first, <code>require-trusted-types-for</code> is about what gets some kind of enforcement and really the only thing you can put there currently is the keyword <code>'script'</code>. The second, <code>trusted-types</code> is about what policies can be created.</p>
        <p>Note that I said "some kind of enforcement" because the above is "report only" which means those things will report, but not actually throw, while if we just change the name of the header from <code>Content-Security-Policy-Report-Only</code> to <code>Content-Security-Policy</code> lots of things might start throwing - which didn't greatly help my exploration. So, here's a little table that might help..</p>
        <table>
            <thead>
                <tr>
                    <th>If the directives are...</th>
                    <th>then...</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><em>(missing)</em></td>
                    <td>You can create whatever policies you want (except duplicates), but they aren't enforced in any way.</td>
                </tr>
                <tr>
                    <td><code>require-trusted-types-for 'script';</code></td>
                    <td>You can create whatever policies you want (except duplicates), and they are enforced. All attempts to assign strings to those sinks will throw. This means if you create a policy named default, it will 'bless' strings through that automatically, but it also means anyone can create any policy to 'bless' strings too.</td>
                </tr>
                <tr>
                    <td><code>trusted-types</code></td>
                    <td>You cannot create any policies whatsoever. Attempts to will throw.</td>
                </tr>
                <tr>
                    <td><code>trusted-types 'none'</code></td>
                    <td>Same as with no value.</td>
                </tr>
                <tr>
                    <td><code>trusted-types a b</code></td>
                    <td>You can call <code>createPolicy</code> with names 'a' and 'b' exactly once. Attempts to call with other names (including 'default'), or repeatedly will throw.</td>
                </tr>
                <tr>
                    <td><code>trusted-types default</code></td>
                    <td>You can call <code>createPolicy</code> with names 'default' exactly once. Attempts to call with other names, or repeatedly will throw.</td>
                </tr>
                <tr>
                    <td><code>require-trusted-types-for 'script'; trusted-types a</code></td>
                    <td>You can call <code>createPolicy</code> with names 'a' exactly once. Attempts to call with other names (including default), or repeatedly will throw. All attempts to assign strings to those sinks will throw unless they are 'blessed' from a function in a policy named 'a'</td>
                </tr>
            </tbody>
        </table>
    </section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[How We Fund the Web Ecosystem]]></title>
        <id>https://bkardell.com/blog/HowWeFund.html</id>
        <link href="https://bkardell.com/blog/HowWeFund.html">
        </link>
        <updated>2024-03-13T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[On Tuesday (March 12th, 2024), Robin Berjon and Eric Meyer and I organized, led and scribed a session during W3C breakouts day about how we fund the web ecosystem…]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: 2rem;">How We Fund the Web Ecosystem</h1>
	<p class="segue">On Tuesday (March 12th, 2024), Robin Berjon and Eric Meyer and I organized, led and scribed a session during W3C breakouts day about how we fund the web ecosystem…</p>


	<p>Every year the W3C has a week long giant set of in-person meetings called TPAC. A nice feature of those meetings has always been “Breakouts Day” which is a day where people can propose sessions about pretty much anything and we try to organize a schedule around the ones that seem interesting to enough people.</p>

	<p>This year, the W3C decided to try a second Breakouts Day that is not at the same time as TPAC, and was purely online.</p>

	<p>Over the last several years, I’ve written several pieces about different aspects of the health of the web ecosystem and led a podcast series with quite a few episodes about that.  In those pieces I’ve argued that while the web ecosystem has become the infrastructure for nearly everything, our models for funding and prioritization of the last 20 years have proven not only inadequate, and problematic, but ultimately fragile and cannot last.  The only questions, I’ve argued, are how soon and what happens next. Are we ready for it? (hint: no).</p>


	<p>So, I talked to a few people and we proposed this as a topic. It was well attended. We began with a short presentation (we made a very detailed outline together, but credit goes to Robin for the <a href="https://bkardell.com/media/2024/How_We_Fund_The_Web.pdf" rel="noopener">great slides</a>).</p>

	<p>We organized the presentation into sort of 2 parts. First I presented explaining the problems and why we believe this requires our attention and action.  First we have to admit that we have a problem, right?  And that this is a problem that <em>we</em> should be concerned with… If not us, who?  If not now, when?</p>

	<p>Then I outlined that there are many possible solutions and elements of solutions that we can discuss (or try), but all of them share some common elements:</p>

	<ol>
		<li>We need a way to take in common money, and a way to actually encourage money into the pot.</li>
		<li>We need a way to <em>efficiently</em> and <em>fairly</em> prioritize the money in the pot toward actual work.</li>
	</ol>

	<p>I highlighted that there are existing things we can already try (and are trying), and that we should really start trying more.</p>

	<p>After this, Robin presented a bigger possible vision we tried to lay out with lots of still fuzzy areas and questions - but effectively: We create an institution which is (through one of a few possibilities) able to compel participation into a system which enforces more sustainable (and fairer) characteristics which guarantee support for the infrastructure of the web.</p>

	<p>You can get a very good idea of what was actually presented from the <a href="https://github.com/w3c/breakouts-day-2024/issues/20#issuecomment-1992539848" rel="noopener">detailed outline</a> that we shared too.</p>

	<p>But all of this was only the initial short presentation which I think was only maybe 5-10 minutes.  The rest was the point of the breakout: Actual discussion.</p>

	<p>I think it was <em>very</em> positive actually.  The main thing that impressed me is that there was seemingly no push back or questioning at at all in the premise.  We agree with the fundamentals - that as I explained in <a href="https://bkardell.com/blog/Webrise.html" rel="noopener">Webrise</a>, it’s fragile from this perspective, and we need to care about it.</p>

	<p>Rick Beyers (from Google, but not speaking for Google) mentioned what they observed in Chromium contributions and that they also had concerns about diversity, both in terms of contributions to a single engine, and multiple engines.  He also mentioned that Chromium was spinning up a new collective idea (not yet announced).</p>

	<p>Just this morning, we helped launch the <a href="https://servo.org/blog/2024/03/12/sponsoring-servo/" rel="noopener">Servo collective</a>.  The timing is purely coincidental.  I’d also note that in part of my presentation I mentioned exploring ways that governments can incentivize and forgot to mention that there have been interesting developments in some open source funding happening this way recently, and to note that the White House recently made a statement that <a href="https://www.whitehouse.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/" rel="noopener">Future Software Should Be Memory Safe</a>.  If anyone has a good ‘in’ at the White House please make the case that if you want to know a good place to invest to be sure a lot of future stuff is memory safe, it’s probably browsers - and especially the one written in Rust :). The collective would be happy to accept the White House’s check.</p>

	<p>There were also some interesting questions about whether Web Monetization could be related to this, or is just a wholly separate problem, about how the advertising model is exceptionally progressive, and where other investment comes from currently.</p>
	<p>Happily <a href="https://www.w3.org/2024/03/12-ecosystem-funding-minutes.html" rel="noopener">minutes are available</a> if you’re interested - and we’ll be trying to organize some immediate discussions on where we go from here through <a href="https://github.com/darobin/wise/" rel="noopener">this repo</a> which also has <a href="https://darobin.github.io/wise/" rel="noopener">a rough outline of how one solution might work</a>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Darkening]]></title>
        <id>https://bkardell.com/blog/darkening.html</id>
        <link href="https://bkardell.com/blog/darkening.html">
        </link>
        <updated>2024-03-11T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[Some additions to my half-light library for styling Shadow DOM.]]></summary>
        <content type="html"><![CDATA[ 
	<h1 class="contextual-heading" style="font-size: 2rem;">The Darkening</h1>
	<p class="segue">Some additions to my half-light library for styling Shadow DOM.</p> 

	<p>In case you haven't followed, a number of my recent posts have been thinking about how Shadow DOM falls short, and how we can can use the tools we have today to explore potential solutions and improvements.  This has led to good feedback and quick iteration on a tiny library called <a href="https://github.com/bkardell/half-light">half-light</a>.</p>

	<p>This library lets page authors selectively "push" styles down into shadow roots as adopted <code>@layer</code>s. It plugs into CSS's media queries, and allows selectivity on both ends: Which styles and which specific shadow roots.  I'm not going to recap the whole concept and interface here because it would just be regurgitating the stuff that's already in the link above.  What I want to write about is the latest set of improvements to half-light.</p>
 
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: 2.5rem;">no-light</h2>
		<p>An important point "feature" of half-light is that it doesn't require web components to be built in a special way in order to achieve this.  Alternative/Previous ideas required elements to subclass a special element, for example, to say "Yes, I am styleable from above".  However, I don't believe that that seems practical for reasons I explained in <a href="https://bkardell.com/blog/LovelyTrees.html">Lovely Trees</a>.  Effectively, it is very difficult to grow iterations on that approach naturally, and there are already so many wonderful components out there which a number of people say "I wish I could use, but alas I cannot provide some basic styling".  This library just lets them do exactly that: Provide styling from the outside (with some caveats below), to see what it's like to actually live with that possibility.  Do they love it?  Ultimately regret it?</p>

		<p>I don't believe that this is some kind of breach of contract to allow that kind of styling from the outside in open shadow roots. The simple fact that the library has to do hardly anything shows just how easy it is, technically, for any page author to do it already today.  No "new powers" have been added.</p>

		<p>It's harder to make this case with closed shadow roots.  While it is entirely possible for page authors to take control of closed shadow roots too, they have to achieve this by changing their nature and, effectively saying "sorry, no your closed shadow roots will be open roots in my page".  However much I am not a fan of the closed roots, I do think that someone who made their root closed gave a pretty strong opinion that you're not supposed to touch the inside, even if you think you want to.</p>

		<p>What I hadn't considered is that open roots could exist inside of closed roots, and with my pattern you could still have styled them the same way. That felt wrong, so I fixed that by making the whole subtree "darkened". That is, half-light can't get any light past it.</p>

		<p>I also made a check for an attribute (or property) <em>called</em> <code>darkened</code> which can achieve this for a light DOM as well.  You set it on the shadow host.  Thus, if you write <code>myElement.darkened = true</code> or <code>&lt;my-element darkened&gt;</code> it will prevent half-light from applying to the whole subtree.  That trick can be used by both custom elements and page authors directly if they find it helpful. Similarly, it's benign otherwise, so component authors can start adding it if they want to and whether page authors happen to be using half-light or not doesn't matter.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: 2.5rem;">Optimizations</h2>

		<p>The very first edition of half-light was a little greedy as to processing and probably was doing a little too much work.  I didn't hear anyone say that they actually experienced a problem, but it was clearly not as efficient as it could be, so, I improved that generally.</p>

		<p>But I also built half-light to be a little resilient to where in the head it was loaded, and to conveniently to work with dev tools.  That means you can go ahead and live-change the CSS its aware of that and will propagate changes down into your components.  This is achieved via a MutationObserver.</p>

		<p>Now, in practice I don't think this is likely to be much of a problem in most cases. Once the document has settled down enough to start rendering, I'm not sure how heavy head mutations are these days - but it seems pretty reasonable to be able to say "you don't have to keep observing", so I added that ability too.  If you include the 
		<code>disable-live-half-light</code> attribute on the script tag that you use to include half-light, it will stop monitoring.</p>

		<p>There's a practical upshot to that as well: This means it can also disengage some book keeping which technically leaks memory (this won't practically cause you issues on your blog or something, it's really mainly if you are doing a lot of dynamic stuff in a long-lived application).</p>

	</section>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: 2.5rem;">Feedback and evolution</h2>
		<p>What I've appreciated most about this effort is the feedback and iteration.  It's kind of amazing to look over such a brief period of time all of the evolution and improvements toward solving a problem.  I hope that more and more people find it valuable to explore and let us know how it goes.  Real world experimentation and feedback is so valuable toward ultimately developing a standard solution.  Thanks to everyone who has reached out, filed issues, written a blog post, or discussed it on a podcast.</p>

		<p>If you haven't already, please leave an emoji or a comment on this <a href="https://github.com/bkardell/half-light/issues/1">github issue</a> to help me collect sentiment toward a solution like this in a central place.</p>
	</section>

]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[StyleSheet Parfait]]></title>
        <id>https://bkardell.com/blog/parfait.html</id>
        <link href="https://bkardell.com/blog/parfait.html">
        </link>
        <updated>2024-02-12T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[In this post I'll talk about some interesting things (some people might pronounce this 'footguns') around adoptedStyleSheets, conversations and thoughts around open styling problems and @layer.]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: 2rem;">StyleSheet Parfait</h1>
	<p class="segue">In this post I'll talk about some interesting things (some people might pronounce this 'footguns') around adoptedStyleSheets, conversations and thoughts around open styling problems and @layer.</p>

	<script src="../prism.js"></script>
	<link rel="stylesheet" href="../prism.css">

	<p>If you're not familiar with adopted stylesheets, they're a way that your shadow roots can <em>share</em> literal styesheet instances by reference.  That's a cool idea, right?  If you have 10 <code>fancy-input</code>s on the same page, it makes no sense for <em>each</em> of them to have their own copy of the whole stylesheet.</p>

	<p>It's fairly early days for this still (in standards and support terms, at least) and we'll put improvements on top of this, but for now it is a pretty basic JavaScript API: Every shadow root now has an <code>.adoptedStyleSheets</code> property, which is an array.  You can push stylesheets onto it or just assign an array of stylesheets.  Currently those stylesheets have to be instances  created via the recently introduced constructor <code>new CSSStyleSheet()</code>.</p>

	<p>Cool.</p>

	<p><a href="https://github.com/sorvell">Steve Orvell</a> opened an issue suggesting that I make <a href="https://github.com/bkardell/half-light">half-light</a> use adopted stylesheets.  Sure, why not.  In practice what this really saves is mainly the parse time, since browsers are pretty good at optimizing this otherwise, but that's still important and, in fact, it made the code more concise as well.</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: 2.5rem;">Whoopsie</h2>
		<p>However, there is an important bit about adopted stylesheets that I forgot about when I implemented this initially (which is strange because I am on the record discussing it in CSSWG): adopted stylesheets are treated as if they come <em>after</em> any stylesheets in the (shadow) root.</p>

		<p>Previously, half-light (and earlier experiments) took great care to put stylesheets from the outer page <em>before</em> any that the component itself. That seems right to me, and what the adopted stylesheets were doing now with adopted stylesheets seemed wrong...</p>
	</section>


	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: 2.5rem;">Enter: Layers</h2>
		<p>A solution to this newly created problem that's fairly easy is to wrap the rules that are adopted with <code>@layer</code>.  Then, if your component has a style element, the rules in there will, by default, win.  And that's true even if the rules that the page author pushed in had higher specificity!  That's a pretty nice improvement. If some code helps you understand, here's a pen that illustrates it all:</p>

		<p class="codepen" data-height="300" data-default-tab="html,result" data-slug-hash="ExMdWdq" data-user="briankardell" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
		  <span>See the Pen <a href="https://codepen.io/briankardell/pen/ExMdWdq">
		  adoptedstylesheets and layers</a> by вкαя∂εℓℓ (<a href="https://codepen.io/briankardell">@briankardell</a>)
		  on <a href="https://codepen.io">CodePen</a>.</span>
		</p>
		<script async="" src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: 2.5rem;">Layers... Like an ogre.</h2>
		<a href="https://www.igalia.com/chats/a-lighter-shade-of-dom">Eric and I recently did a podcast on the Open Styleable shadow roots topic with Mia</a>.  Some of the thoughts she shared, and later conversations that followed with <a href="https://westbrookjohnson.com/">Westbrook</a> and <a href="https://nolanlawson.com/">Nolan</a>,  convinced me to try to explore how we could use layers in half-light.<p></p>

		<p>It had me thinking that the way that adopted stylesheets and layers both work seems to allow that we could develop some kind of 'shadow styling protocol' here.  Maybe the simplest way to do this is to just give the layer a well-known name: I called it <code>--crossroot</code></p>

		<p>Now, when a page author uses half-light to set a style like:</p> 

		<pre><code class="language-css">@media --crossroot { 
  h1 { ... }
}</code></pre>

		<p>This is adopted into shadow roots as:</p>

		<pre><code class="language-css">@layer --crossroot { 
  h1 { ... }
}</code></pre>

		<p>That is a lower layer than anything in the default layer of a component's shadow root (both stylesheets or adopted stylesheets).</p>

		<p>The maybe interesting part this adds is that it means  that the component itself can consciously manage it's layers if it chooses to do so!  For example..</p>

		<pre><code class="language-javascript">this.shadowRoot.innerHTML = `
  &lt;style&gt;
    @layer base, --crossroot, main;
    ... 
    /* add rules to those layers  */
    ... 
  &lt;/style&gt;
  ${some_html}
`</code></pre>

		<p>If that sounds a little confusing, it's really not too bad - what it means is that, going from least to most specific, rules would evaluate roughly like:</p>

		<ol>
			<li>User Agent styles.</li>
			<li>Page authored rules that inherit into the Shadow DOM.</li>
			<li>@layers (including <code>--crossroot</code> half-light provides) in the shadow</li>
			<li>Rules in style elements in the shadow that aren't in a layer.</li>
		</ol> 

	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: 2.5rem;">Combining ideas...</h2>
		<p>There was also some unrelated feedback from Nolan that this approach was a non-starter for some use cases - like pushing Bootstrap down to all of the shadow roots.  The previous shadow-boxing library would have supported that better. Luckily, though we've built this on Media Queries, so CSS has that pretty well figured out - all we have to do is add support to half-light to make Media Queries work in link and style tags (in the head) as well.  Easy enough, and I agree that's a good improvement.  So, now you can also write markup like this:</p>

		<pre><code class="language-html">&lt;link rel="stylesheet" href="../prism.css" media="screen, --crossroot"&gt;&lt;/link&gt;

&lt;!-- or to target shadows of specific elements, add a selector... --&gt;
&lt;link rel="stylesheet" href="../prism.css" media="screen, (--crossroot x-foo)"&gt;&lt;/link&gt;</code></pre>
	</section>


	<p>So... That's it, this is all in half-light now... And guess what? <em>It's still only 95 lines of code</em>.  Thanks for all the feedback so far!  So, wdyt?
		Don't forget to leave me an indication of how you're feeling about it with an emoji (and/or comment) on the <a href="https://github.com/bkardell/half-light/issues/1">Emoji sentiment or short comment issue</a>.</p>
	
	<p class="thanksTo">Very special thanks to everyone who has commented and shared thoughts constructively along the way, even when they might not agree.  If you actually voted in the emoji sentiment poll: ❤. Thanks especially to <a href="https://www.miriamsuzanne.com/">Mia</a> who has been great to discuss/review and improve ideas with.</p>

]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[half-light]]></title>
        <id>https://bkardell.com/blog/half-light.html</id>
        <link href="https://bkardell.com/blog/half-light.html">
        </link>
        <updated>2024-01-25T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[Evolving ideas on "open stylable" issues, a new proposal.]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: 2rem;">half-light</h1>
	<p class="segue">Evolving ideas on "open stylable" issues, a new proposal.</p>

	<script src="../prism.js"></script>
	<link rel="stylesheet" href="../prism.css">

	<p>Recently I wrote a piece called <a href="https://bkardell.com/blog/LovelyTrees.html">Lovely Trees</a> in which I described how the Shadow DOM puts a lot of people off because the use case it's designed around thus far aren't the one most authors feel like they have. That's a real shame because there is a lot of usefulness there that is just lost.  People seem to want something just a little <em>less</em> shadowy.</p>

	<p>However, there are <em>several</em> slightly different visions for what it is we want, and how to achieve it.  Each offers significantly different details and implications.</p>

	<p>In that piece I also noted that we can make any of these possible through script in order to explore the space, gain practical experience with and iterate on until we at least have a pretty good idea what will work really well.</p>

	<p>To this end I offered a library that I called "shadow-boxing" with several possible "modes" authors could explore.</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: 2.5rem;">"Feels like the wrong place"</h2>
		<p>Many people seemed to think this would be way better expressed in CSS itself somehow, rather than metadata in your HTML.</p>

		<p>There is a long history here. Originally there were combinators for crossing the shadow boundary, but these were problematic and removed.</p>

		<p>However, the fact that this kept coming up in different ways made me continue to discuss and bounce possible ideas around.  I made a few rough takes, shared them with some people, and thanks to <a href="https://www.miriamsuzanne.com/">Mia</a> and <a href="https://daverupert.com/">Dave Rupert</a> for some good comments and discussion, today I'm adding a separate library which I think will make people much happier.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: 2.5rem;">Take 2: <code>half-light.js</code></h2>
		<p><code><a href="https://github.com/bkardell/half-light">half-light.js</a></code> is a very tiny (~100 LoC) library that lets you express styles for shadow doms in your page <em>in your CSS</em> (it should be CSS inline or linked in the head). You can specify whether those rules apply to both your page and shadow roots, or just shadow roots, or just certain shadow roots, etc. Let's have a look.. All of these make use of CSS <code>@media</code> rules containing a custom <code>--crossroot</code> which can be functional. The easiest way to understand it is with code, let's have a look...</p>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: 3rem;">Rules for shadows, not the page...</h3>
			<p>This applies to <code>&lt;h1&gt;</code>'s in <em>all shadow roots</em>, but not in the light DOM of the page itself.</p>
			
			<pre><code class="language-css">@media --crossroot { 
  h1 { ... }
}</code></pre>

			<p>Authors can also provide a selector filter to specify which elements should have their shadow roots affected.  This can be, for example, a tag list. In the example below, it will style the <code>&lt;h2&gt;</code>'s in the shadows of <code>&lt;x-foo&gt;</code> or <code>&lt;x-bar&gt;</code> elements, and not to those in the light DOM of your page itself...</p>
			<pre><code class="language-css">@media --crossroot(x-foo, x-bar) { 
  h2 { ... }
}</code></pre>

		<p>Most selectors should work there, so you could also <em>exclude</em> if you prefer. The example below will style the <code>&lt;h3&gt;</code>'s in the shadows of all elements <em>except</em> those of <code>&lt;x-bat&gt;</code> elements ...</p>

		<pre><code class="language-css">@media --crossroot(:not(x-bat)) {
  h3 { ... } 
}</code></pre>
		</section>
		
		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: 3rem;">Rules for shadows, <em>and</em> the page...</h3>

			<p>It's really just a trick of <code>@media</code> that we're tapping into: Begin any of the examples above with <code>screen,</code> and put the whole <code>--crossroot</code> in parenthesis. The example below styles all the <code>&lt;h1&gt;</code>'s in both your light DOM and all shadows...

		</p><pre><code class="language-css">@media screen, (--crossroot) { 
  h1 { ... }
}</code></pre>
		
			<p>Or, to use the exclusion route from above, but to apply to all <code>&lt;h3&gt;</code>'s in the page, or of shadows of all elements <em>except</em> those of <code>&lt;x-bat&gt;</code> elements ...</p>

		<pre><code class="language-css">@media screen, (--crossroot(:not(x-bat))) {
  h3 { ... } 
}</code></pre>

		</section>

		<p>Play with it... There's a pen below. Once you've got an impression, give me your impression, even with a simple <a href="https://github.com/bkardell/half-light/issues/1">Emoji sentiment or short comment here</a>.</p>

		<p class="codepen" data-height="300" data-default-tab="html,result" data-slug-hash="LYazzmL" data-user="briankardell" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/briankardell/pen/LYazzmL">
  halflight</a> by вкαя∂εℓℓ (<a href="https://codepen.io/briankardell">@briankardell</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async="" src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>

	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: 2.5rem;">Is this a proposal?</h2>
		<p>No, not yet, it's just a library that should allow us to experiment with something "close enough" to what "features" a real proposal might need to support, and very vaguely what it might look like.</p>

		<p>A real proposal, if it came from this, would certainly not use this syntax, which is simply trying to strike a balance between being totally valid and easy to process, and "close enough" for us to get an idea if it's got the right moving parts.</p>
	</section>
	


]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[What's Good?]]></title>
        <id>https://bkardell.com/blog/WhatsGood.html</id>
        <link href="https://bkardell.com/blog/WhatsGood.html">
        </link>
        <updated>2024-01-03T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[I think this is a question worth asking, let me explain why…]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: 2rem;">What's Good?</h1>
	<p class="segue">I think this is a question worth asking, let me explain why…</p>

	<p>A few times a year, every developer advocate will ask developers about what developing features they're interested in or what pain points they experience most. That is a good thing. We should keep doing that.</p>
  
  	<p>While we don't often present it in this light, one thing this does is inform prioritization. The simple truth is that resources are way too finite, so we have to look for good signals about what should be prioritized.</p>
  
  	<p>I think it's similarly important to have feedback on the other end too: What's your satisfaction like on the web features you've gotten in the last few years? Can you name any that you use all the time? Can you name some that you over-estimated your need for? Something that you thought you needed/wanted but then ultimately didn't end up using so much? Something that you had high hopes for, but failed you?</p>
  
  	<p>But why ask that?</p>
  	
  	<p>Well, it seems quite probable that there are things we can learn from that.</p>
  
  	<p>Maybe we can look at where we should have listened more, or pushed more. Maybe we can learn things about the processes that successful things took that unsuccessful things didn't (did they go through WICG? Were there polyfills? Origin trials? Did they stay in experimental builds behind a flag for a long time? Were they done at roughly the same time in all browsers?). Can we compare the amount of resources and time required between them? Maybe those things could also inform prioritization somehow?</p>

	<p>Normally, around this time, I'd have wrapped up working on the latest Web Almanac and there would be lots of data flying at me which scratches a little bit of the kind of itch I've got - but this year we didn't do one, so I find myself wondering: How are people getting along with all of those things we've been delivering since 2019 or so?</p>

  	<p>So, let me know!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lovely Trees]]></title>
        <id>https://bkardell.com/blog/LovelyTrees.html</id>
        <link href="https://bkardell.com/blog/LovelyTrees.html">
        </link>
        <updated>2023-12-26T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[You've read lots of Web Components posts lately, I think this one is a little different.]]></summary>
        <content type="html"><![CDATA[ 
	<h1 class="contextual-heading" style="font-size: 2rem;">Lovely Trees</h1>
	<p class="segue">You've read lots of Web Components posts lately, I think this one is a little different.</p> 
	<script src="../prism.js"></script>
	<link rel="stylesheet" href="../prism.css">
	
   <p>
		I'm <em>thrilled</em> that so many people are suddenly learning about, and falling in love with Custom Elements separately from Shadow DOM. It is, in my mind, best to learn about Custom Elements first anyways. And, if your goals are to use it in some simple, static sites, or blogs - then, well, that might be all you need.  It's just a better version of what we used to do with jQuery, really.  
	</p>  

	<p>But…</p>

	<p>Here is where I want to say something about Shadow DOM, and I expect it will go something like this:</p>


	<figure class="captioned-image optional">
		<video src="/media/PB_Fire_Swamp.mp4" controls="" style="max-width: 600px; width: 100%; display: block; margin: 2rem auto 3rem;"></video>
		<figcaption>It's not so bad.</figcaption>
	</figure>

	<p>
		But, stick with me.  It won't be that bad, I promise.
	</p>

	<p>
		The simple light DOM way is, yes, good.  But it creates a poor illusion if the component manipulates the DOM.  That illusion is easy shattered as neither component authors, nor page authors can reason well about the tree in potentially important ways, because it is a transform of the page author's tree to some tree of the component author's making, with no designed coordination. And then, <em>everything</em> starts breaking down quickly, not just CSS. Script too, uses selectors and tree relationships.  Where there is any kind of real complexity: It's cases like that that Shadow DOM <em>should</em> serve us very well for. 
	</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: 2.5rem;">But it falls short</h2>
		<p>
			Despite this, it seems that for plenty of people who have tried, Shadow DOM is falling short.  All of the posts I'm reading show that people are so put off by the current state that they'd flipped the bit until now on Custom Elements too.  When one steps back and looks at all of the calls (from people who have been trying to use Shadow DOM for a while) for a few variations of "open style-able roots", or "slots in the light DOM", or "ability to use IDREFs across shadow roots" - or even the fact that we're bringing back scoped styles: It really starts to seem like maybe we've missed (or at least not recognized or prioritized)  multiple important use cases along the way.
		</p>
		
		<p>
			I think this is because we've focused mainly on giving developers a capability to build and share something that is pretty similar to native widgets - and that's not what most people think they need.  Indeed, I think we've failed to wrestle with differences that seem sharp. 
		</p>

		<p>
			For example: Browsers are <em>extremely</em> careful to not expose their "Shadow DOM" internals because the consequences of doing so could be dire. If they didn't, then when browsers try to push an update that makes some otherwise innocuous, even welcome change, everything goes wrong. Users suddenly experience problems in tons of apps.  Maybe they suddenly can't activate a control.  Perhaps that prevents them from getting the information they need for their bank, or their insurance.  It can be a very big deal.  People start filing bugs on those websites and writing hate filled blog posts.  Devs from those websites do the same in kind.  And so on.  No one wins.</p>

		<p>
			However, code libraries (of custom elements or anything else) are different. It's sites themselves, not the browser or the library, that are in charge of deploying upgrades to libraries, which involves testing and avoids the worst surprises. Neither the site author, nor the library author, it seems, generally requires the kind of extreme upgrade guarantees that current Shadow DOM is built to grant.  Largely, it seems they would provide other trade-offs instead.
		</p>

		<p>
			The design of Shadow DOM also hasn't focused enough on collaboration.  I believe (as I have since the beginning) that <em>most</em> uses of Shadow DOM are about some kind of collaboration -- more about preventing <a href="https://bkardell.com/blog/FriendlyFire.html">friendly fire</a>.  But what we've created is perhaps more like a programming language with only <code>private</code> — no <code>protected</code> or "friendly" concepts.
		</p>

		<p>
			If you think that all of this sounds kind of damning of standards, it's more complicated than it seems.  There are no cow paths to pave here.  But, what if there were? Because, at this point, it sure seems like there could be.
		</p>

		<p><em>I'm not saying I'd like to build a summer home there, but the Shadow Trees are actually quite lovely</em>.</p>
	</section>

	

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: 2.5rem;">Treading Some Cow Paths</h2>
		<p>
			<em>Lots</em> of coordination is totally possible, it simply requires jumping through hoops and isn't standard.  The community can, probably should, spend some time proving out and living with a few different ideas.  That would make standardizing one of them much easier (standards are at their best, in my take, when they are mostly <a href="https://bkardell.com/blog/Dropping-The-F-Bomb-On-Standards.html">writing down the slang that developed and was tested naturally, in the wild</a>). Better still it taps into the creative power of the commons to get us <em>functional</em> solutions now, rather than making us wait forever for solutions that might not arrive for years - or even ever! This sort of approach is how we got things like <code>.querySelector()</code> <code>.matches()</code> and <code>.closest()</code>.
		</p>

		<p>
			Today, if you create a Shadow DOM, style rules inside don't leak out to the rest of the page, and don't "leak in" from the page.  There are a lot of people who dislike that second part.  Tricky thing is, they don't all seem to dislike it the same way, or want the same kind of solution(s).  What we need here, I think, is practical experience and, luckily, we have the raw materials to try solutions to some of this in the wild ourselves and see what pains it soothes (and probably, also realize some that it causes). 
		</p>

		<p>
			For example, here are few major potential philosophies: 
		</p> 
		<dl>
			<dt>Let components decide</dt> 
			<dd>Authors extend a new base class which then automatically pulls down a copy of some, or all of the styles provided by the page.</dd>

			<dt>Let page authors decide</dt> 
			<dd>Lets the page say "these are the base, simple styles for all components" regardless of what they extend. I think this is kind of key because one of the really nice things about custom elements is that many of us might like to share and find and mix and match, which is pretty hard to do while also basing a solution on extending a particular base class.</dd>
		</dl>


		<p>But which one is "right"? All of them feel more natural for some use cases/scenarios. All of them are probably just terrible for others. Maybe there are more variants! Maybe what we need is a "pick one, that's how your page will work" idea.  Or, maybe we need all of them to work!  I think we can only learn through use and experimentation, so...</p>

		<p><a href="https://github.com/bkardell/shadow-boxing/">Here's a tiny library to let you try each those things</a>!</p>

		<p><a href="https://shadow-boxing.glitch.me/">And a little glitch you can poke around, inspect, remix, play with, and tweak</a>.</p>

		<p>Go on... Pick one. Try it. Remix the glitch, make a pen, try it on your site. Love it or hate it.  Let it inspire better ideas.  But, most importantly - share your thoughts - regardless! Did it do good things for you? Was it tricky? I want to know!</p>

	</section>
		


]]></content>
    </entry>
</feed>