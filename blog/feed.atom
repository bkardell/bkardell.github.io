<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bkardell.com/</id>
    <title>bkardell.com rss feed</title>
    <updated>2021-09-24T21:00:55.274Z</updated>
    <generator>awesome mix</generator>
    <author>
        <name>Brian Kardell</name>
        <email>bkardell@gmail.com</email>
        <uri>https://bkardell.com</uri>
    </author>
    <link rel="alternate" href="http://bkardell.com/"/>
    <link rel="self" href="https://bkardell.com/blog/feed.atom"/>
    <subtitle>Just the bkardell.com rss feed</subtitle>
    <logo>http://bkardell.com/profile.jpg</logo>
    <rights>All rights reserved 2018, Brian Kardell</rights>
    <entry>
        <title type="html"><![CDATA[Experimenting with :has()]]></title>
        <id>https://bkardell.com/blog/ExperimentingWithHas.html</id>
        <link href="https://bkardell.com/blog/ExperimentingWithHas.html">
        </link>
        <updated>2021-08-20T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[Back in May, I wrote Can I :has()?. In that piece, I discussed the :has() pseudo-class and the practical reasons it's been hard to advance. Today I'll give you some updates on advancing :has() efforts in Chromium, and how you can play with it today.]]></summary>
        <content type="html"><![CDATA[
    <h1 class="contextual-heading" style="font-size: NaNrem;">Experimenting with <code>:has()</code></h1>

  <p class="segue">Back in May, I wrote <a href="https://bkardell.com/blog/canihas.html">Can I :has()?</a>. In that piece, I discussed the <code>:has()</code> pseudo-class and the practical reasons it's been hard to advance. Today I'll give you some updates on advancing <code>:has()</code> efforts in Chromium, and how you can play with it <em>today</em>.</p>

  <p>In my previous piece I explained that <a href="https://twitter.com/igalia">Igalia</a> had been working to help move these discussions along by doing the research that has been difficult for vendors to prioritize (funded by eyeo) and that we believe that we'd gotten somewhere: We'd done lot of research, developed a prototype in a custom build of chromium and had provided what we believed were good proofs for discussion.   The day that I wrote that last piece, we were filing an intent to prototype in chromium.</p>

  <p>Today, I'd like to give some updates on those efforts...</p>

  <section class="sectioning">
    <h2 class="contextual-heading" style="font-size: NaNrem;">Where things stand in Chromium, as of yesterday</h2>
    <p>As you may, or may not know, the process for shipping new features in Chromium is pretty involved and careful.  There are several 'intent' steps, many, reviews along the way, many channels (canary, dev, beta, stable). Atop this are also things which launch with command line flags, runtime feature flags, origin trials (experimentally on for some sites opted in), reverse origin trials (some sites opted out) and field trials/finch flags (rollout to some % of users on or off by default).</p>

    <p>Effectively, things get more serious and certain, and as that happens we want to expand the reach of these things by making it easier for more developers to experiment with it.</p>

    <section class="sectioning">
      <h3 class="contextual-heading" style="font-size: NaNrem;">Previously...</h3>
    <p>For a while now our up-streaming efforts have allowed you to pass command line flags to enable some support in early channels. Either</p>

    <pre><code class="langauge-javascript">--enable-blink-features=CSSPseudoHasInSnapshotProfile
--enable-blink-features=CSSPseudoHas</code></pre>

  <p>The former adds support for the use of the <code>:has()</code> pseudo class in the JavaScript selector APIs ('the snapshot/static profile'), and the latter enables support in CSS stylesheets too.</p>

  <p>These ways still work, but it's obviously a lot more friction than most developers will take the time to learn, figure out, and try.  Most of us don't launch from a command line.</p>

  <section class="sectioning">
    <h4 class="contextual-heading" style="font-size: NaNrem;">New Advancements!</h4>

    <p>As things have gotten more stable and serious, we're moving along and making some thing easier...</p>

    <p>As of the dev channel release 94.0.4606.12 (yesterday), enabling support <em>in the JavaScript selector APIs</em> is now as simple as <a href="https://techviral.net/enable-experimental-web-platform-features-in-chrome/">enabling the experimental web platform features runtime flag</a>. Chances are, a number of readers already have this flag flipped, so low friction indeed!</p>

    <p>Support in the JavaScript APIs has always involved far fewer unknowns and challenges, but what's held us from adding support there first has always been a desire to prevent splitting and a lack of ability to answer questions about whether the main, live CSS profile could be supported, what limits it would need and so on.  We feel like we have a much better grip on many of these questions now and so things are moving along a bit.</p>

    <p>We hope that this encourages more people to try it out and provide feedback, open bugs, or just add encouragement. Let us know if you do!</p>
  </section>
  </section>
  <section class="sectioning">
    <h3 class="contextual-heading" style="font-size: NaNrem;">Much more at Ad Blocker Dev Summit 2021</h3>
    <p>I'm also happy to note that I'll be speaking, along with my colleague Byungwoo Lee and eyeo's <a href="https://twitter.com/shwetank">@shwetank</a> and <a href="https://twitter.com/WebReflection">@WebReflection</a> at <a href="https://adblockerdevsummit.com/">Ad Blocker Dev Summit 2021</a> on October 21. Looking forward to being able to provide a lot more information there on the history, technical challenges, process, use cases and impacts!  Hope to see you there!</p>
    </section>
</section>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tabs in HTML?]]></title>
        <id>https://bkardell.com/blog/SpicySections.html</id>
        <link href="https://bkardell.com/blog/SpicySections.html">
        </link>
        <updated>2021-07-04T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[Please help us evaluate an idea!]]></summary>
        <content type="html"><![CDATA[
  <h1 class="contextual-heading" style="font-size: NaNrem;">Tabs in HTML?</h1>
 
<p class="segue">Please help us evaluate an idea!</p>

<p>I've fallen a bit behind on my podcast consumption (thanks to being very busy), but I was recently catching up during a drive in the car and was pleased to hear Dave Rupert and Chris Coyier having some good discussion on the Shop Talk Show episode 466 (time jumped to the start) <a href="https://shoptalkshow.com/466/#t=04:12">about some work we've been doing and that we're looking for more opinions/thoughts on</a>. Dave did a bang-up job explaining I think, but just trying to imagine it all might be a little difficult, so I wanted to share something a little more concrete, provide some context around it, and to re-iterate that "we'd like (need) your help in evaluating this idea ".</p>

<section class="sectioning">
<h2 class="contextual-heading" style="font-size: NaNrem;">Show me something...</h2>

<p>Imagine that you could have something that worked .... kind of like this (insert giant hand wavey motions):  You write some good old HTML that looks just like HTML you  write today, but are able to express that want you to <em>sometimes</em> treat it with different interaction affordances - just like the way scroll panes work on the Web today...</p>

<div class="captioned-image">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/1x_SDV4PDQU" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
   <p>A running demo showing sections that gain tabset or collapse affordances as the screen resizes.</p>
</div>

<p>You should be able to load the demo in this video yourself in any browser...</p>

<a href="https://codepen.io/bkardell/pen/VwpJGGL?editors=1100" style="border: 1px solid blue;
    display: block;
    margin: 1rem 20%;
    background: papayawhip;
    padding: 0.5rem; 
    text-align: center;
    border-radius: 0.5rem;">Show me the demo</a>

<p>If you view the source of that page, you'll see there is just a single element that we have cleverly named <code>&lt;spicy-sections&gt;</code>.</p>

<p>Please check it out: It's <a href="https://github.com/tabvengers/spicy-sections">very easy to try</a>. Note that the actual syntax or way to express the association with interactive afforances is entirely up in the air. This custom element <em>isn't</em> a proposal itself. There are many efforts happening in parallel discussing precisely how this should (and shouldn't or can and can't) work, but the custom element should help you explore the ideas.</p>

<p>Play with it. Build something useful.  Ask questions, show us your uses, <a href="https://github.com/tabvengers/spicy-sections/issues">give us feedback about what you like or don't</a>. This will help us shape good and successful approaches and inform actual proposals. Question #1 is on the crux of the idea itself.</p>

<p>If the answer to "how do I get a native tabset in the browser?"" involved using 0...1 'new' elements (perhaps one to identify content which could fit these models) and some CSS (or CSS-like) means of expressing 'when'" - would you call that a win? Do you get it? Do you love it? Do you hate it? What are your questions?</p>

<section class="sectioning">
<h3 class="contextual-heading" style="font-size: NaNrem;">A little background</h3>

<p>There are lots of efforts around adding new elements to HTML - many of which are being coordiated through an effort in WICG called "Open UI". This effort involves browser implementers, developers, UI Toolkit makers, etc, and I think that's great. I <em>really</em> want the web to have a better set of tools for making basic UI and I hope that Open UI can show us a better way forward than we've done in the past.</p>

<p>To me, this means involving more people. It means meeting developers closer to where they are and giving them something useful to evaluate, to tighten the feedback loop and make sure we're able to course correct.  But it also means that we should be producing things out in the open along the way that allow anyone to see how we even got to here.  Proposals shouldn't lack a back-story or explantion, or seem like they appeared out of nowhere.  There shouln''t be any things "you just have to trust us on".</p>

<p>So, that's what we're trying to do: A group of us have been looking at 'tabs' - and there is a reason we're asking.  Chances are, I think, this won't  match your first ideas about how the browser would get native support for tabs.  It didn't match my own, in fact.  I've built and used a lot of tabs over the last 20+ years, and never thought of it this way either.  So, I wanted to add some context and explanation for the curious...</p>
</section>
</section>

<section class="sectioning">
<h2 class="contextual-heading" style="font-size: NaNrem;">Step 1: Define Tabs?</h2>

<p>I realize this sounds almost silly.  In fact, when I asked the question "can we define 'tabs'" a friend replied to me...

</p><blockquote>You know what tabs are, Brian".  </blockquote>

<p>I mean... You use them every day, on every OS. Everybody <em>knows</em> they exist in every toolbox. All that's left is to "just pave the cowpaths!" But when you get right down to it, it's a lot more complicated than that.</p>

<p>Different "tabset" implementations have different features and different limits.  All of them have changed and evolved over time.  Today, most UI toolboxes have <em>multiple</em> APIs for creating things that users would just call "tabs" - and there are reasons for that.  Sometimes these APIs are even the basis of things a user might <em>not</em> call tabs!  In many cases, the APIs themselves <em>aren't called "tabs" (or anything close to that)</em>.  So, if we want to discuss these things (any components, really), we need to begin with a survey and lay down some clear definitions and goals.  We laid this all out in <a href="https://open-ui.org/components/tabs.research.parts">this research identifying the parts and features</a> in the landscape.</p>

<section class="sectioning">
  <h3 class="contextual-heading" style="font-size: NaNrem;">An interesting distinction</h3>
  <p>One thing which falls out this is an intesting distinction of 2 broad "kinds of tabset-like controls":</p>
  <ul>
    <li>One kind is actually a <em>window manager</em>. The tabs at the top of the browser you're looking at right now are windows that happen to be arranged visually as groups that look like tabs.</li>
    <li>Another kind manages exclusive display and focus management patterns of what are, effectively, sections within the same document that happen to look like tabs.</li>
  </ul>
  <p>As end-users we probably don't think about this much, but it is a pretty important distinction actually and there are differences we understand commonly.  In fact, so many expectations about both the shape of the UI and user interactions flow from this. Text searching happens in a window, not across windows, for example.  Windows can be "dragged out" and displayed as, well, windows. The keyboard interactions and accessibility roles of windows are expected to be... windows. And so on.</p>

  <p>For our purposes, we have chosen to focus primarily on the ltter kind which are prevalent in UI kits for the Web.</p>
</section>

</section>

<section class="sectioning">
<h2 class="contextual-heading" style="font-size: NaNrem;">Markup and APIs</h2>

<p>Again, it <em>feels</em> like it shouldn't be difficult to pave these paths into markup.  However, even in systems <em>without</em> markup, the shape of APIs varies pretty considerably.  Translating this to markup adds a new set of challenges.  There isn't a clear/self evident mapping to DOM/markup at all - and whatever decisions we make somehow dictate something about how APIs should work on the web.</p>

<p>To illustrate this, we have also collected <a href="https://open-ui.org/components/tabs.research.markup">a bunch of research showing all sorts of variants over the years</a> and various dissected pros and cons of each.</p>

<section class="sectioning">
  <h3 class="contextual-heading" style="font-size: NaNrem;">Some things we thought were important...</h3>

<p>We thought it is worth thinking about progressive enhancement.  Support for new features generally rolls out unevenly (we only got the last support for summary/details about a year ago, for example).  This means that for potentially a long time, some browsers may not have support for native tabs.</p>

<p>But that's only part of the story: When you consider "other browsers" - things like embedded devices which update more slowly still, or search engines or reader modes... What happens to content?</p>

<p>Further, we'd would like to test out any theory with a custom element (as above), and the script can fail to download.  In fact, these things seem to dovetail nicely. We'd like the content to be "good" even if script for some reason doesn't execute in that case.</p>

<p>This fed into roads we didn't go down..</p>

<section class="sectioning">
  <h4 class="contextual-heading" style="font-size: NaNrem;">Attributes?</h4>
  <p>One popular approach involves putting the tab's "label" as an attribute.  That has a lot of really nice qualities, but it falls down on a number of other points.  Without support (including all of those cases above), users would be left with information loss and a wall of run-on and unlabelled content.  This also has pretty extreme limitations on what can be put <em>into</em> a tab label. No additional elements means no ruby text, for example,  or interesting icon treatments or stylistic markup or structured text of any kind.  So, we suggest that attributes for labels are not our first choice.</p>
</section>

<section class="sectioning">
  <h4 class="contextual-heading" style="font-size: NaNrem;">TOC Style?</h4>
  <p>Another very popular set of solutions involves "table of contents (TOC) style" markup. These draw a parallel which equates tab labels to items in a table of contents.  In fact, over the years this sort of pattern has been popular with progressive enhancement enthusiasts because you can use a list of links. The markup itself even "looks like tabs" already. It's probably surprising then that this isn't our first choice - why?</p>

  <p>
  The short answer is that there are some fundamental flaws in this analogy which have impacts.  Tables of contents are an enhancement of headings, not a replacement for them.  That is, they are generally built based on headings that label content and simply repeated/reflected earlier.  Without these already in place, the un-enhanced content is just a wall of unbroken text without labels. It's almost exactly the same issue as attribute style.  While it's possible to repeat the headings too, why repeat yourself? If you have the heading, you can build the TOC, but not vice-versa.</p>

  <p>Similarly, the argument that "the markup looks like tabs already" is less than perfect.  As our research shows, tabset labels can exist along any axis, or even around the circumference of a circle.  If you look at it just slightly differently, they can perhaps even be interleaved in the content ('responsive tabs' do this, and at one point ARIA's "single select accordions" were also tabs).</p>

  <p>So, we suggest TOC-style isn't our first choice either.</p>
</section>

<section class="sectioning">
  <h4 class="contextual-heading" style="font-size: NaNrem;">A tabset element?</h4>
  <p>All of this helps shine light on some interesting questions and led to my post <a href="https://bkardell.com/blog/DesignAffordanceControls.html">Design Afforance Controls</a> which talks about why the way we approach this matters. It holds up flaws in the inherent control-specific-ness of <code>&lt;summary&gt;</code> and <code>&lt;details&gt;</code> and contrasts this with the fact that we don't have a <code>&lt;scrollpane&gt;</code> element - but rather employ those affordances when they make sense.</p>

  <p>If a thing's fundamental, primary "nature" is just "good sections", don't we often want to change our minds on presentation based on things like media or design? It's worth considering.</p>

  <p>So, it's not that we <em>shouldn't</em> have an element specifically for tabs as much as "isn't this maybe more useful"?
</p></section>

</section>


<section class="sectioning">
<h3 class="contextual-heading" style="font-size: NaNrem;">What do you think?</h3>

<p>Please let us know what you think about the ideas here!  If you could provide "just good content" and have pretty much full stylistic control, and use CSS to express what kind of "showey/hidey" control it should be/when... How would you feel about that? Do you "get it"?  Do you "buy the arguments"? Or are we just barking up the wrong tree?  Your feedback will help inform how we discuss or advocate for things next in OpenUI to move things forward.</p>
</section>

  <p class="thanksTo">Mentions do not imply endorsements, but many thanks to folks who  proofread this post, met along the way, helped research, had discussions, and did work.  Very special thanks especially @jon_neal @TerribleMia and @davatron5000 for many thoughtful discussions.</p>

</section>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stranger Than Fractions]]></title>
        <id>https://bkardell.com/blog/StrangerThanFractions.html</id>
        <link href="https://bkardell.com/blog/StrangerThanFractions.html">
        </link>
        <updated>2021-05-27T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[There's a new Math Working Group in the W3C (and I'm co-chairing).  In this post, I'll share some information on that, why I really hope your organizations will join, as well as some personal reflections.]]></summary>
        <content type="html"><![CDATA[
<h1 class="contextual-heading" style="font-size: NaNrem;">Stranger Than Fractions</h1>
<p class="segue"><em>There's a new Math Working Group in the W3C (and I'm co-chairing).  In this post, I'll share some information on that, why I really hope your organizations will join, as well as some personal reflections.</em></p>

<p>Life is weird.  If I could travel back in time and explain my life to a younger me, I couldn't even count of the number of things that younger me would have just absolutely scoffed at in disbelief.  Here's another one to add to the list: I'm co-chairing a new W3C Working Group focused on Math on the Web.</p>

<p>I'm not going to  offer all of the reasons this would be surprising to a younger me, but suffice to say it's a pretty long list.  Even a me of only 2-3 years ago would probably be pretty incredulous.  See, I'd never really given math on the web much thought until then.  The thing that really brought it to my attention was that a company I knew to be full of some pretty smart people (Igalia, where I now work) were suddenly talking about how to add MathML to Chromium, and why this is a thing we should do.  It came up before the W3C Technical Architecture Group and was getting some larger discussion around the interwebs.  Particularly, there were connections to Extensible Web Manifesto. I felt kind of compelled to really think about it and write something thoughtful about it myself. So in January 2019 (I didn't work for Igalia then) I wrote <a href="https://bkardell.com/blog/Math.html">Harold Crick and the Web Platform</a>.    </p>

<p>Based on this and some other observations that I was having about what an important role I thought Igalia could play in so many fundamentally important issues, I applied there (here).  Since then I've tried to help "right the ship" and get math onto the web and on a stable footing that is integrated with the platform. I participated in the CG where we worked out <a href="https://mathml-refresh.github.io/mathml-core/">MathML-Core</a>, attempting to do just that. I helped write some tests, open (and resolve!) issues in a number of standards about how we integrate, draft a bit of spec, open implementation bugs (and ship changes in all browsers!), explain why this work is important from a significant number of angles (not the least of which is that it is societally important) in blog posts and talks (I won't link them all because there's already a lot of links here), prioritize work, draft an <a href="https://github.com/mathml-refresh/mathml-core/blob/master/docs/explainer.md">expainer</a>, work through <a href="https://github.com/w3ctag/design-reviews/issues/438">a TAG review</a>, draft the <a href="https://www.w3.org/Math/Documents/Charter2021.html">new Working Group Charter</a> and gain support for it (I'm very pleased to say that every browser vendor supported its creation - and Chrome was even first one, if anyone has doubts).</p>

<p>A few weeks after the charter was approved, I was asked to sign on as a co-chair to lead the MathML-Core portion (the bit that goes in browsers). Last week I was officially added and "approved by the director" as co-chair.</p>

<p>Now for... you know... lots more important work as we try reach a really great state of affairs.  </p>

<p>We'll only really hope to do that though with help and good, diverse (from many angles) participation in the Working Group.  If you're a W3C member,  consider getting involved yourself.  If not, still please comment on issues and review things. Importantly: Put aside any math phobias, doubts or pre-conceived notions.  Even if your present-self is a little (or even a lot) incredulous at the idea that you can really help.  Believe me, I get it.  But that's wrong.  Help and participation from people with backgrounds across the platform aren't only very welcome, they're necessary:  There's a lot to do to ensure that the platform is sensible and consistent as possible.  Many discliplines need to coordinate to make sure that things stay on track, make sense and that important aspects don't get left behind.  </p>

<p>We'll be starting up the MathML-Core meetings soon (end of June or early July, tdb sooon) and focus on actually moving some of this through the standards process and beginning to work together to answer remaining questions and make sure we're driving toward really good interoperable, well integrated math on the Web.  </p>

<p>We can do this.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Can I :has()]]></title>
        <id>https://bkardell.com/blog/canihas.html</id>
        <link href="https://bkardell.com/blog/canihas.html">
        </link>
        <updated>2021-05-13T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[As you might know, my company (Igalia) works on all of the web engines and we contribute a lot.  I'm very proud of all of the things we're able to do to improve both the features of the web platform, and the overall health of this commons.  I'm especially pleased when this lets us tackle historically hard problems.  A very incomplete list of things with some historical challenges that we've helped move in important ways the past few years would include: CSS Grid, MathML, JavaScript Class features, hardware accelerated SVGs and Container Queries.  Today I'll be telling you about another one we're working on.]]></summary>
        <content type="html"><![CDATA[
  <h1 class="contextual-heading" style="font-size: NaNrem;">Can I <code>:has()</code></h1>
  <script src="../prism.js"></script>
    <link rel="stylesheet" href="../prism.css">
<p class="segue">As you might know, my company (Igalia) works on all of the web engines and we contribute a lot.  I'm very proud of all of the things we're able to do to improve both the features of the web platform, and the overall health of this commons.  I'm especially pleased when this lets us tackle historically hard problems.  A very incomplete list of things with some historical challenges that we've helped move in important ways the past few years would include: CSS Grid, MathML, JavaScript Class features, hardware accelerated SVGs and Container Queries.  Today I'll be telling you about another one we're working on.</p> 

<p>Today we're filing an intent to prototype, tackling yet another historically hard problem for the web: The <code>:has()</code> selector.  In this post, I'd like to <em>explain what this intent means</em>, as well as why it matters, where it comes from and why I am very excited about it.</p>

<section class="sectioning">
  <h2 class="contextual-heading" style="font-size: NaNrem;"><code>:has()</code> for the unfamilliar</h2>

<p>When you write a CSS rule, the <em>last</em>  (right-most) bit of the selector is the thing that you're styling. We call that the "subject" of the rule.  Most people writing CSS have, at some point, found themselves wanting to style something <em>based on what is inside it</em>.  You might have heard people talk about wanting "a parent selector" or an "ancestor combinator". <code>:has()</code> is that - basically.</p>

<pre><code class="language-css">/* style an .x that contains a .y descendant - not the .y */ 
.x:has(.y) { ... }
</code></pre>
</section>

<section class="sectioning">
<h2 class="contextual-heading" style="font-size: NaNrem;">The long history of postponed <code>:has</code></h2>

<p>The basic reasons to desire such powers are pretty obvious. Powerful selection ability greatly enables a real separation of concerns.  This fact wasn't lost on anyone.  XPath allowed it, and CSS specifications since the late 1990's have tried.  </p>

<p>In fact, a lot of people learned about <code>:has()</code> first through jQuery.  That's because when John Resig wrote it he wanted it to support all of the ""new CSS 3 selectors" - and <code>:has()</code> was one of them. It was in the spec, so <a href="https://api.jquery.com/has-selector/">jQuery supported the :has()</a> selector pseudo.  The trouble, of course, is that no one actually knows what will gain implementations and reach recommendations at the start of the process - and <code>:has()</code> didn't, and was postponed again to Selectors Level 4. The first draft of Selectors Level 4 was <a href="https://www.w3.org/TR/2011/WD-selectors4-20110929/">published in 2011</a>. It is highly starred, was <a href="https://web.archive.org/web/20171204194327/https://wpdev.uservoice.com/forums/257854-microsoft-edge-developer/suggestions/8977591--has">among the top requested features in Microsoft's old User Voice system</a>, and every year remains among the top 2-3 most requested features. Every so often someone (frequently me) brings it up again in the CSS Working Group.</p>
</section>

<section class="sectioning">
  <h2 class="contextual-heading" style="font-size: NaNrem;">Why the hold up?</h2>

<p>Primarily, even without <code>:has()</code> it's pretty hard to live up to performance guarantees of CSS, where everything continue to evaluate and render "live" at 60fps.  If you think, mathematically, about just how much work is conceptually involved in applying hundreds or thousands of rules as the DOM changes (including as it is parsing), it's quite a feat as is.</p>

<p>Engines have figured out how to optimize this based on clever patterns and observations that avoid the work that is conceptually necessary - and a lot of that is sort of based on these subject invariants that <code>has()</code> would appear to throw to the wind.</p>

<p>At the same time, there are plenty of aspects of this problem that are considerably easier than others.  CSS engines for print, for example support <code>:has()</code> because they don't need to run at 60fps.  DOM APIs like <code>querySelector()</code> / <code>querySelectorAll()</code> / <code>matches()</code> also check at a very specific point in time in a completely different manner - it's very doable there, as jQuery showed.  </p>

<p>There are limits that we could potentially place on this selector that might help a little.  Or, there are things like <code>:focus-within</code> or <code>:empty</code> which seem similar, but internally, are very specifically easier - but very incomplete.</p>

<p>And so, for the last decade this comes up once or twice a year as we try to find some way forward. In the end, we ultimately sort of go around in circles: It's impossible to make decisions and progress while everything is in limbo.  We don't really know what the options are, and its hard for anyone to take up trying to imagine a way forward.  As we've seen with some other things, like Container Queries, this is also somewhat of a vicious cycle:  The more it comes up, and the more it is discussed without ultimate progress of any real kind, the less likely it is that anyone actually wants to talk about it again.  </p>

<p>We need prototyping, exploration, data we can point to and more concrete things we can discuss - but the longer it goes on, the more hopeless it looks and the less likely anyone is to do it.</p>
</section>

<section class="sectioning">
<h2 class="contextual-heading" style="font-size: NaNrem;">eyeo, Igalia and prototypes</h2>

<p>Igalia works on all of the web engines, and with lots of consumers of those engines to expand investment in this wonderful commons.  eyeo makes a number of products like the Adblock Browser and Adblock Plus. While some sites can offer workarounds that employ additional classes for intentionaly styling these sorts of things, plenty of other things cannot. Lots of very useful things (reader mode, ad blockers, conformance checker plugins and search are just some examples) rely on selectors and heuristics abbout trees of markup that they didn't create. They have a definite separation of concerns and thus observe these sorts of shortcommings very acutely. Having no native solutions for some of these hard problems causes <em>everyone</em> to have to find their own ways deal with it themselves, and all of them have different performance characteristics and different edge cases, and all of them require additional JavaScript. <em>That's not good for anyone</em>.  So, eyeo approached us about sponsoring work, research and prototyping on some things - among them <code>:has()</code>. <em>Can we somehow get past these impasses and make progress on this one, and make things better for the entire community?</em>  What might that look like? Can it conceivably work in the main 60fps CSS?  If not, can we provide some research and data that allows other paths like support in the JavaScript DOM methods, or a static profile?  Let's be sure to include all of important uses of selectors.</p>

<p>For the past little while, Igalia engineers have been looking into this problem. We've been having discussions with Chromium developers, looking into Firefox and WebKit codebases and doing some <a href="https://chromium-review.googlesource.com/c/chromium/src/+/2725907">initial protypes</a> and tests to really get our heads around it.  Through this, we've provided <a href="https://css-has.glitch.me/">lots of data about performance of what we have already</a> and where we believe challenges and possibilities lie.  We've begun sketching out an <a href="https://github.com/Igalia/explainers/tree/main/css/has">explainer</a> with all of our design notes and questions linked up - so it's all there in the open for people to review as we attempt to open this discussion.</p>
</section>

<section class="sectioning">
<h2 class="contextual-heading" style="font-size: NaNrem;">Today's intent: What it means</h2>

<p>The meaning of "intents" have been occasionally difficult for the larger community to understand in the same way, so I wanted to take a moment to suggest how to interpret it:  With today's intent, we're simply stating that we feel that we have gathered enough information and data on this that we feel like we're ready to share it for wider review and discussion, productively. We believe that the data suggests that it seems at least plausible to carry on with discussions around supporting a (partially limited) form of <code>:has</code> in the main, live CSS.  We would like for data, designs and limits to be discussed fairly concretely.  We would like like to carry forward with additional, concrete implementation prototyping and continue to help sort out a path forward.</p></section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES Temporal: 2 Minute Standards]]></title>
        <id>https://bkardell.com/blog/TemporalIn2Min.html</id>
        <link href="https://bkardell.com/blog/TemporalIn2Min.html">
        </link>
        <updated>2021-04-30T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[
    You might have heard that Temporal has recently reached Stage 3
    in ECMA, here's a
    #StandardsIn2Min explaination of it...
  ]]></summary>
        <content type="html"><![CDATA[
  <h1 class="contextual-heading" style="font-size: NaNrem;">ES Temporal: 2 Minute Standards</h1>
  
  <p class="segue">
    You might have heard that <code>Temporal</code> has recently reached Stage 3
    in ECMA, here's a
    <a href="2MinuteStandards.html">#StandardsIn2Min</a> explaination of it...
  </p>

  <p>
    Since it's beginnings JavaScript has had only a rudimentary
    <code>Date</code> object. It copied <code>Date</code> from an early edition
    of Java and it was intended to be used for programming just about anything
    relating to time. While Java itself quickly deprecated and improved their
    situation, JavaScript implementations didn't follow suit. It also introduced
    its own warts and quirks to <code>Date</code> along the way. As a result,
    JavaScript libraries dedicated toward reasoning about the complexities of
    time, like <code>moment.js</code> became common and essential.
  </p>

  <p>
    <code>Temporal</code>, now at stage 3 as of this writing, is the result of a
    lot of work initiated by maintainers of those projects and shepherded
    through the standards process. It introduces lots of rich APIs to the
    JavaScript standard library, hosted by a new top-level
    <code>Temporal</code> object. Large top-level introductions of this sort
    (like Temporal, Math and Intl) are exceedingly rare.
  </p>

  <p>
    <code>Temporal</code> provides a number of objects, all immutable and
    serializable, and each with their own methods for reasoning about time in
    different ways.
  </p>

  <p>
    It contains some fundamental concepts which implement standards for calendar
    systems and timezones respectively, and set the foundations for how a lot of
    methods do their work:
  </p>
  <ul>
    <li><code>Temporal.Calendar</code></li>
    <li><code>Temporal.TimeZone</code></li>
  </ul>

  <p>
    It introduces <code>Temporal.Instant</code> which is used for dealing with
    an instant in time to various degrees of precision.
  </p>

  <p>
    It also introduces a number of "plain" themed objects geared toward
    providing APIs for the different ways we think about time not simply in terms of
    different kinds of precision. For example...
  </p>

  <ul>
    <li>
      <code>Temporal.PlainTime</code> is for dealing with wall-clock time that
      is not associated with a particular date or time zone.
    </li>
    <li>
      <code>Temporal.PlainMonthDay</code>  is for date without a year components,
      useful for annual events like "The fourth of July" or "Christmas Day".
    </li>

    <li>
      <code>Temporal.PlainDateTime</code>  is for representing a calendar date
      and wall-clock time that does not carry time zone information, e.g.
      December 7th, 1995 at 3:00 PM (in the Gregorian calendar).
    </li>

    <li>
      <code>Temporal.PlainYearMonth</code>  is useful for expressing things like
      "The October 2020 edition of Vanity Fair".
    </li>
  </ul>

  <p>It also includes...</p>
  <ul>
    <li>
      <code>Temporal.ZonedDateTime</code>  is for reasoning about dates and times in
      the timezone offsets reckoned by a particular calendar
    </li>
    <li>
      <code>Temporal.Duration</code> is used for measuring the duration between two
      temporal objects.
    </li>
    <li>
      <code>Temporal.now</code> provides APIs about current the moment in time.
    </li>
  </ul>
  <figure>
    <img src="https://tc39.es/proposal-temporal/docs/object-model.svg">
    <figcaption>
      A diagram illustrating the different types, relationships and concepts
      described that make up <code>Temporal</code>
    </figcaption>
  </figure>

  <p>
    You can learn a lot more by following through links in the <a href="https://github.com/tc39/proposal-temporal"><code>Temporal</code>
    proposal repo</a>, including helpful
    <a href="https://tc39.es/proposal-temporal/docs/index.html">Reference documentation and
    examples</a>, a
    <a href="https://tc39.es/proposal-temporal/docs/cookbook.html">cookbook</a> to help you
    get started and learn the ins and outs of Temporal which include a (not
    production ready) polyfill in every page so that you can open Dev Tools and
    explore for yourself.
  </p>
  <p class="note">If you're interested in hearing about the history, development, challenges, inner workings or rationale behind any of this, I recently hosted <a href="https://www.igalia.com/chats/Temporal">an edition of our podcast on this topic with guests who worked on the standard.</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Design Affordance Controls]]></title>
        <id>https://bkardell.com/blog/DesignAffordanceControls.html</id>
        <link href="https://bkardell.com/blog/DesignAffordanceControls.html">
        </link>
        <updated>2021-04-25T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[We often use a single word (the actual word varies) to discuss "controls" . This, I believe, carries with it a fundamental assumption that they are all somehow "the same," and that has shaped how we think about them.  In this post I'll  explain why I have recently come to think that perhaps they aren't really quite the same at all.  I'll also suggest that some additional terminology which could describe a few broad classes of controls, could help us better discuss (and perhaps shape) them.]]></summary>
        <content type="html"><![CDATA[
  <h1 class="contextual-heading" style="font-size: NaNrem;">Design Affordance Controls</h1>
  
  <p class="segue">We often use a single word (the actual word varies) to discuss "controls" . This, I believe, carries with it a fundamental assumption that they are all somehow "the same," and that has shaped how we think about them.  In this post I'll  explain why I have recently come to think that perhaps they aren't really quite the same at all.  I'll also suggest that some additional terminology which could describe a few broad <em>classes</em> of controls, could help us better discuss (and perhaps shape) them.</p>

  <section class="connections sectioning">
    <h2 class="contextual-heading" style="font-size: NaNrem;">What is a "control", exactly?</h2>
 
    <p>On its face, it seems like kind of an absurdly simple question, right?</p>

    <p>However, consider this: Many UI toolkits outside the web have, at some point, explicitly defined some kind of control which could be described as "a container with scrollbars". In a way, this makes sense: When something is scrollable, there are several UI implications:</p>

    <ul>
      <li>They paint scroll bars and mouse/touch affordances.</li>
      <li>They become part of the sequential focus order. </li>
      <li>Standard keyboard control affordances for managing the scroll are added.</li>
      <li>There are events and UI states to track.</li>
      <li>They might gain an affordance to become user-sizable.</li>
      <li>...and so on.</li>
    </ul>

      <p>On the web, we don't look at the problem that way.  There is no special "scroll container" element, nor even an ARIA role for it.  Instead, elements are, first, just "Good Semantic Content", and whether they are scrollable (or not) is considered a matter of, and subject to, the design.  Overflow, and affordances related to it, are decidedly presentational.</p>

      <p>
        This is pretty interesting because, for example, authors can choose when a <code>&lt;section&gt;</code> should be "component-like" with affordances or not - they vary in pursuit of good design.
      </p>

      <p>Form controls, on the other hand, are definitely <em>not like that at all</em>. Their entire nature is to <em>always be a particular control</em>.  As we look to introducing new "controls" in HTML, I think it could be helpful to think about this sort of distinction.</p>
  </section>

  <section class="sectioning">
    <h2 class="contextual-heading" style="font-size: NaNrem;">"Design Affordance Controls"</h2>

    <p><em>I would like to argue that there are several other "common controls" (collapsible content, tabs and accordions are some examples) which have more in common with scrollable areas than they do with form controls, and that this might be worth careful consideration.</em></p>

    <p>While these components aren't simply about "overflow" (they manage actual hiddenness and have ARIA roles), they do seem to share a lot of other qualities with scroll containers:  </p>

    <ul>
      <li>They can be (and should be, I will argue) thought of, first and foremost, as <strong>natural, meaningful document content.</strong>.</li>
      <li>Whether or not these elements are "control-like" is something which should be deployed by authors <strong>subject to the design</strong> in order to provide helpful affordances for users to be able to more easily consume the content.</li>
      <li>Their interaction is not primary to the control, but <strong>secondary</strong>.</li>
    </ul>

    <p>I label these here as "Design Affordance Controls". To consider why this matters: HTML has <code>&lt;details&gt;</code> and <code>&lt;summary&gt;</code> elements which provide collapsible content and I will use them as a point of comparison.</p>

    <section class="sectioning">
      <h3 class="contextual-heading" style="font-size: NaNrem;">What about print?</h3>
      <p>When you print a page containing input collection controls, what prints is the control, in its current state.  This is entirely unsurprising. What else could it do, really?</p>

      <p>However, is this uniformly desirable?  I would suggest it is not.  In fact, it is not universally true of any of the things I have labelled "Display Affordance Controls".  Just as with scrolling, there isn't a simple "Yes, always" or "No, never" to the question of whether it should be content-like, or control like..  It is <em>reasonable</em> for an author to decide whether it should print either way.</p>

      <p>To illustrate: Imagine that I built a a site about recipes. It has sections about the 'ingredients', 'instructions' and 'dietary information'.  I might like those to display on someone's screen as collapsible sections of the sort provided by   <code>&lt;details&gt;</code> and <code>&lt;summary&gt;</code> in order to provide a a nicer design and a set of affordances for a user to consume the content more easily.</p>
 
      <figure class="captioned-image">
        <img src="/media/dac-disclosures.png">
        <figcaption>Recipes displayed with disclosure sections</figcaption>
      </figure>

      <p>But really, at the end of the day, it's just that: A convenience of design affordance.  As an author, in this case, I'd like it to print with all of the content, sans controls.</p>

      <figure class="captioned-image"> 
        <img src="/media/dac-sections.png" style="max-width: 400px;">
        <figcaption>Receipes as simple sections</figcaption>
      </figure>

      <p>With <code>&lt;details&gt;</code> and <code>&lt;summary&gt;</code>, this is not an option.  Their control-ness is hard-wired and fundamental.  This feels like a mistake.</p>
    </section>
    <section class="sectioning">
        <h3 class="contextual-heading" style="font-size: NaNrem;">Interchangeability?</h3>
        <p>Unlike the collection of input which wants to describe a single "right shape", there isn't really a "right" answer to which of the things I have labelled Design Affordance Controls we should use.  In the above example, one could easily and reasonably swap in several (maybe any) of them. Tabs, for example, are also a reasonable choice.</p>

        <figure class="captioned-image">
          <img src="/media/dac-tabs.png">
          <figcaption>Recipes displayed with sections as tabs</figcaption>
        </figure>

        <p>Because this is all <em>in pursuit of design</em>, it might even be desirable to even change our minds!  "Responsive Tabs" which allow for a control to be presented as either "tab-like" or "accordion-like" based on design constraints aren't uncommon, and are an example of just this.  Their existence helps illustrate that there are at least <em>reasons</em> to consider that this observation is relevant.</p>   

        <p>(<em>There is a <a href="#note-on-browser-tabs">Note about "browser tabs"</a> later</em>)</p>
    </section>
    <section class="sectioning">
      <h3 class="contextual-heading" style="font-size: NaNrem;">UnControling?</h3>

      <p>Even outside of print, as an author, the answer to whether I'd like something to even provide <code>&lt;details&gt;</code> and <code>&lt;summary&gt;</code> affordances varies based on the design.  This website, in fact, is an example.</p> 

      <p>If your browser window is big enough, the left side of this website (as of this writing, at least) is a bunch of information about me.  It's not, very probably, <em>why</em> you're here. You didn't come to learn about me. You want to read the <code>&lt;main&gt;</code> content.  But, that's not a design problem either... In fact, I think that showing you both and making it easy for you to get that information without being overly distracting is a <em>feature</em> of the design.</p>

      <figure class="captioned-image share-image" style="margin-top:0">
        <img src="/media/desktop-site-April-2021.png" alt="">
        <figcaption>This site, in desktop view</figcaption>
      </figure>

      <p>However, in a smaller viewport, this would become really <em>inconvenient</em> for a user. It would involve scrolling through a lot of "noise" in order to get to the actual content.  The "easy" solution might be to just <em>hide</em> it. However, as I said, making it easy to find that information is a feature.  So, on a small screen, I choose to put a disclosure widget that is collapsed by default with 'author information' in the summary.</p>

       <figure class="captioned-image share-image" style="margin-top:0">
        <img src="/media/mobile-site-April-2021.png" alt="">
        <figcaption>This site, in mobile view</figcaption>
      </figure>

      <p>
       Almost every website on earth, it seems, has some "spiritually similar" idea (hamburger menus, for example).  Cool. 
      </p>

      <p>Except... wait... is it? That's not how the API surface of <code>&lt;details&gt;</code> and <code>&lt;summary&gt;</code> work. At all.  I believe that's because of how we approached its design. I can't think of any precedent of a control that becomes... not a control.  I can, however, point to plenty of examples of "regular things" that can potentially gain affordances.</p>
    </section>
    <section class="sectioning">
      <h3 class="contextual-heading" style="font-size: NaNrem;">Enhancing vs... Unenhancing?</h3>

      <p>Just as scrollbars "enhance" regular content with affordances, Progressive Enhancement does something similar.  That's useful to think about.</p>

      <p>Assuming that content should be meaningful and non-interactive to start is a good exercise, generally.  <a href="https://www.smashingmagazine.com/2016/05/developing-dependency-awareness/">Any of a myriad of problems can get in the way</a> and if markup and styling implies something is interactive, but it doesn't wind up being so, users are left in one of two bad states:
      </p>

      <ul>
        <li>(ideally) a UI which seems to imply that a section could be collapsed, but frustratingly that won't seem to work.</li>
        <li>(much worse) a UI which seems to imply there is content (which their is) which the user  should be able to expand, but frustratingly cannot.</li>
      </ul>

      <p>This exercise is also potentially helpful in designing a new control like this for HTML itself.  Until new controls are supported by every browser (and historically, that takes a long time), the situation is not dissimilar.</p>

      <p>A more robust solution involves <em>enhancing</em> otherwise good and meaningful content (as you see in the print version above) with affordances, if that is both possible and desirable.  In fact, this is precisely what several of the original PE examples/essays did. The essence of the element didn't change, only the affordances inside it did, and only if they could. They were perfectly good on their own, and were careful to avoid the above kind of situation.</p>

      <p>But <code>&lt;details&gt;</code> and <code>&lt;summary&gt;</code> were not that.  They were just unknown elements (effectively, <code>&lt;spans&gt;</code>s). They ran together stylistically, and they had no useful meaning to assistive technology either. If we had thought of these as "Design Affordances" which <em>could</em> appear on a <code>&lt;section&gt;</code>, how much better would that have been in the interim?</p>
    </section>

    <section class="sectioning">
      <h3 class="contextual-heading" style="font-size: NaNrem;">Clues in Linking and Searching?</h3>
      <p>Pages allow authors to share links to anchors. Find-in-page allows authors to find content in the page by searching.  Today, this is a problem for <code>&lt;details&gt;</code> and <code>&lt;summary&gt;</code>, again in part because of how 'control-ness' is fundamentally baked into them.  Again, this feels like a mistake, and these are pain points that we're working on - but it's interesting to realize that the same would be the case for other controls of this class if we continue to think of them this way.</p>

      <p>I feel like these offer further evidence their UI affordances are necessarily secondary and not fundamental.</p>
    </section>
    <section class="note sectioning" id="note-on-browser-tabs">
      <h3 class="contextual-heading" style="font-size: NaNrem;">A Quick Note on "Browser Tabs"</h3> 
      <p>Lots of interfaces that we use have things we'd all refer to in polite conversation as "Tabs".  These are used as examples that confound a lot of conversations and take them in many directions. It's never the case, for example, that one would "print all the open tabs" or "view them all in a sequence".  In fact, one could reply to many of the things I've written here with "...but, browser tabs...".</p>
      <p>It's important to note that while we refer to all of these things as "tabs", most UI toolkits have entirely separate classes of "tab-like" things with distinct names.  The fundamental distinction between them is that one of those kinds of tabs (the kind in browsers, chat clients, editors and so on) are actually managing <em>windows</em>, and the other kind is managing <em>panels of content <em>inside</em> a window</em>.  On the web, our model is documents. But, there is an easy-to-imagine parallel with embedded documents here.  That is, one could perhaps make tabs out of <code>&lt;section&gt;</code>s, or perhaps out of <code>&lt;iframe&gt;</code>s. These would have roughly the same kinds of boundaries as toolkits, but (even from a user's POV) actually different expectations on several of the things noted in this post.</p>
    </section> 
    
    <section class="sectioning">
      <h3 class="contextual-heading" style="font-size: NaNrem;">Conclusions?</h3>
      <p>This post isn't actually intended to present a "solution" as much as it is to provide food for thought about how we shape the conversations as we design new things for HTML.  Perhaps even toward helping shape answers to some long open questions.  Even something as simple as "what is an accordion?" remains, believe it or not, just a bit elusive in some important ways that even the ARIA Practices Guide (APG) itself has struggled with. I hope that this line of thinking and discussion is helpful to that struggle.</p>

      <p>In truth, it's probably not even this cut and dry. As I said: These controls aren't exactly like scrollbars either. I'm definitely not suggesting we should just match that either.  It's tempting to kind of think of something like <code>input</code>'s <code>type</code> attribute here - but it's not quite that either (which is good, because that is rife with issues -- see Monica's 
        <a href="https://vimeo.com/176453149">Input I &lt;3 you, but you're bringing me down.</a> for a rough sense of them).</p>.  Instead, it seems there is very probably a small <em>spectrum</em> of "classes of controls and concerns" here that are worth thinking about carefully as we are designing new controls.   But we can't really do that unless we start talking about it somewhere.  Starting that conversation is my hope here.<p></p>

      <p>I'm currently working with lots of folks in OpenUI on trying to introduce some of these controls, and I'm hopeful we can incorporate these thoughts into our discussions.  While this is a lot more to be fleshed out, there is a version of this that I can imagine that very closely resembles <a href="https://whatwg.org/specs/web-apps/2006-01-01/#switch">a proposal from Ian Hickson from long ago</a>. Ian's proposal provided a wrapper element around otherwise good, sectioned content and would have offered minimal affordances (like grouping the headings as "tabs") and state management.  There is a lot that appeals to me about that kind of approach and could play well here.  A few of us (myself, Dave Rupert, Pascal Schilp, Jonathan Neal, Miriam Suzanne, Zach Leatherman, Greg Whitworth, Nicole Sullivan) have also been discussing bits of this. Some of us  have also been working on creating a custom element along similar lines which can be plain old sections, "tab-like" or "accordion-like".  This broke out from collaborative work that began with several of us attempting to align our ideas together on Pascal Schilp's <a href="https://genericcomponents.netlify.app/generic-tabs/demo/index.html">Generic Tabs</a> repository (that isn't the component, but it already has some nice qualities). I'm looking forward to sharing our component and more details soon.</p>

      <p>Honestly, I'd love to hear your thoughts. I feel like this is an area ripe for serious R&amp;D, study and discussion.</p>

    </section>
    <p class="thanksTo">Special thanks to several friends for proofing/commenting on this as it developed: Alice Boxhall, Jonathan Neal, Miriam Suzanne, Eric Meyer, Dave Rupert. Thanks don't imply some kind of endorsement.</p>
</section>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Optimizing The W3C Sandwiches]]></title>
        <id>https://bkardell.com/blog/W3C-Sandwiches.html</id>
        <link href="https://bkardell.com/blog/W3C-Sandwiches.html">
        </link>
        <updated>2021-01-24T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[In which I muse about a boring, but, I think important topic of flawed W3C structures and process, in a hopefully not-boring way...]]></summary>
        <content type="html"><![CDATA[
  <h1 class="contextual-heading" style="font-size: NaNrem;">Optimizing The W3C Sandwiches</h1>
  <p class="segue">In which I muse about a boring, but, I think important topic of flawed W3C structures and process, in a hopefully not-boring way...</p>

<p>Imagine that there is a trade organization which had a marathon meeting event for its 500 members every year.  It's a long meeting, and so during it, they serve sandwiches.  A break, with food and peers, it seems is really conducive to the productivity.  So, while it's a little non-obvious, while small and with no special 'powers' - the sandwiches are actually really important.  The trade organization realizes this and decides to formalize a way to make sure we always have good sandwiches.  A few weeks before they send out an email asking people:</p>

<blockquote>
<p>Please tell us an ingredient which you could provide enough of for every sandwich for the next 3 years. Your ingredient may or may not be used, we are just looking for ingredient <em>nomination statements</em> expressing what your ingredient brings to the table.  If your ingredient is chosen, we will tell you whether that is a 1, 2 or 3 year commitment.</p>
</blockquote>

<p>Even if everyone doesn't really understand how inter-connectedly important the sandwiches are, they aren't entirely apathetic about them either:  When it comes time to eat, and everyone's hungry after long meetings, there will <em>definitely</em> be opinions about the sandwiches.  </p>

<p><em>BUT...</em>  At the same time, there will incredibly be very few ingredient nominations. Why?  So many reasons!</p>

<p>Even if a person really had some vague notion that "a lot of my favorite sandwiches had pickles", their company is small, and it doesn't actually deal with pickles.  After a moment or three worth of thought about "which pickles?" and "do other people even like pickles?" and "how would I ask my boss for money to <em>offer</em> 1000 pickles... maybe" - this is quickly abandoned as not really worth the time.  Each person receiving this email knows there are 499 other organizations, and that what we need are really just 4 ingredients! Someone else - with the money and food connections will nominate anyways.</p>

<p>And so, that's what happens... Several of them are from some grocery or food service industry. Their businesses totally <em>get</em> the importance of the sandwiches, as well as what people largely "like" and they are structured in a way where this basically isn't a problem for them.  Several of them might even discuss among themselves to make sure they're bringing complimentary things... They'll nominate things like"lettuce" or "tomatoes", or maybe "cheese".  Maybe some others don't discuss, but they do a lot of sandwich adjacent work and so they still nominate some pretty general condiments that could plausibly be used on a lot of good sandwiches... maybe they offer "mustard" or "mayonnaise".  But, then there's also people with other food connections who offer other things.  In the end, we wind up with eggs, Vegemite, peanut butter, some gourmet cactus jelly, caviar, and butter.   Then, of course - there's someone who offers some not-even-food item.</p>

<p>Now, with the exception of the last one - there's not really something inherently <em>wrong</em> with any of those ingredients - but I think we could at least agree that making a sandwich from random combinations of them is likely to produce a lot of suboptimal sandwiches. </p>

<h2>Vote for pickles!</h2>

<p>Everyone should have a say here, and we need to account for multiple tastes - so the way organization goes about deciding on which sandwich everyone will have is by voting for <em>ingredients</em>.</p>

<p>Now, again -- <em>not due to apathy about the actual sandwiches, or the results of the meeting that they will effect</em> - only about 1/5th of people will actually vote for ingredients. Why?  Again, "this isn't worth my time, surely someone else can figure out sandwiches" plays in heavily. Perhaps you could even say that lack of participation an indirect recognition of what a dysfunctional way this is to make a sandwich.</p>

<p>I mean, who really has time to read the ingredient nomination statements, and also to filter out what might be just bull?  Who wants to take the time to learn about the dietary benefits of whey, or read the back and forth debates extolling the health virtues of mayonnaise over mustard - or read some people ranting about why the tomato lobby is colluding with the spinach people, putting honest bean farmers out of business - and inevitable back and forth.  Who has time to get entangled in the debate about how maybe the caviar people shouldn't even have been invited in the first place?</p>

<p>Still, the organization believes that members should make the decision,  and, it seems there are a few ways we could ask this question.  So, in early years it was asked like this:</p>

<blockquote>
<p>Here are 12 ingredients, everybody pick 4, and we'll use the some of the same ingredients from last year, plus the top 4 vote getters here to make everyone sandwiches!</p>
</blockquote>

<p>The initial sandwiches reviews seemed pretty good, actually.  Some people even praised the first sandwiches' 'distinguish tastes'.  But, slowly, a lot of people began admitting that really, they actually preferred something a little more boring, or less healthy but had been kind of afraid to admit it.</p>

<p>Also, it was really kind of a crap shoot.   There was really nothing preventing us getting a real mishmash of random ingredients that didn't go thereto at all.  Well, except for the fact that, in the end that most people were casting 4 votes, representing all of the ingredients of an actual sandwich. <em>Nobody</em> on purpose probably picked the combination of vegemite, mustard, butter and caviar - even if they really liked some of those.  This meant that there were at least some odds that lots of "common sandwich" votes were somewhat compatible.</p>

<p>
But really... that still involved a lot of luck, and after a few years, people began to kind of resent the sandwiches.  The quality of productivity, collaboration and relationships at the event suffered.
</p>

<h2>How about a nice club sandwich?</h2>

<p>But then, some people realized... Hey... Maybe a better way would be to try to talk to lots of people and put together a proposal for a good sandwich.  The whole sandwich. Let's call them the "Whole Sandwich People".  Like, can we get enough people to vote for the same way, by just saying:</p>

<blockquote>
<p>Hi.  We've taken the time to help make sure we had good ingredients, and looking at everything that is available and trying to balance lots of things, we're  recommending this nice club sandwich - &lt;here's why&gt;.  If that sounds good, order the club.</p>
</blockquote>

<p>Well, that question is a lot easier to answer, so at least <em>some</em> additional people say "yes, please, that sounds good".  The simple volume of several new people voting in the same direction was enough to generally make sure that those sandwiches won.</p>

<p>Cool!  The Whole Sandwich People <em>also</em> cared about variety and nutrition and all of the other things and so began actively working to make sure that good, compatible, but not commonly offered ingredients got nominated.  And, we got some more interesting sandwiches because of it.</p>

<h2>The Exclusive Club Sandwich</h2>

<p>In the end, not everyone was happy though.  Some kinds of ingredients just weren't getting picked anymore.  People began asking:  How can our trade organization possibly represent the tastes of the people who always offers us caviar if we never pick caviar!?  Your club sandwich is an <em>exclusive</em> club, it's biased toward the food service people!</p>

<p>The Whole Sandwich People suggested that this seemed like a weird take.  In fact, they pointed to the fact that sandwiches had gotten <em>more</em> diverse, interesting and nutritious by discussing the whole sandwich.  Sure, a lot of the ingredients were  coming from food service companies, but that's just practical realities about other parts of the dysfunctional system.</p>

<p>And, yes, the Whole Sandwich People admitted, it's true, none of our sandwiches have included caviar.  But, where is the bug? Couldn't the caviar people work with others to find a way to offer an acceptable Whole Sandwich with caviar? It might be plausible - it's not even that we necessarily hate caviar!  The truth is, we just don't know how to make a good sandwich with it, and all of our sandwich experiences with it so far are bad.  Or, if you <em>can't</em> offer a whole sandwich with caviar that people will order willingly.... <em>Maybe</em> just find something to offer other than caviar.</p>

<p>This, it seems, was unacceptable. It was seen as unfair.  The Whole Sandwich People held too much sway over sandwich determination.  So, in an attempt to improve the fairness things, the trade organization changed the question to:</p>

<blockquote>
<p>Here are 9 ingredients, everybody rank them in order of preference and they we will use a complex system whereby <em>one</em> of the things you ranked will be counted, and we'll use the 4 winners to make everyone sandwiches</p>
</blockquote>

<p>This amplifies the likelihood that things like caviar wind up our sandwiches.  That's literally the <em>feature</em>.</p>

<p>Why?  Because there is no single ingredient that makes a club sandwich.  While everyone ranks the widely approved ingredients the inevitably have to be in an order, and only one of them will count.  Meanwhile, the small but passionate group of people who are really passionate about a less common ingredient, and who are maybe even a little irked because they are never picked, just put that as #1 - which definitely counts.</p>
 
<p>Have we optimized the sandwich?  Because I thought was the goal.  I think, no.</p>

<h2>The TAG/AB Sandwiches</h2>
<p>All of this is analogy for how the W3C TAG and AB, and I've laid it out in an attempt to explain why I think this is a really silly way to do it, and why I think it should change:  <em>The "best sandwich" isn't created by talking about ingredients in isolation - you <strong>have</strong> to talk about the sandwich.</em></p>

<p>Yes, I get that sandwiches are a bit of a strained analogy.  TAG isn't <em>exactly</em> a sandwich.... Maybe "a bunch of people going to a restaurant and attempting to pick a shared menu of 4 items based on whatever random stuff is available" is a better one.  Or maybe picking a DND party is a better one still... </p>

<p>But, the fuzzy point is mostly the same with any of them: "Good" and "bad" are, except at real extremes not really judge-able in isolation.  Sure, there are some "not-actually-even-food" items we can universally say "no thanks" to, but that's also rare, and not really how it works.</p>

<p>What matters in counting is  "which one is best" and there is almost never a clear answer to that question without considering the whole.  What matters to really knowing what people want, is also asking them in such a way that they can actually participate meaningfully.</p>

<h2>How big of a problem is this, really?</h2>
<p>After all, it's been a few elections now since we changed the question, and while there were some early "surprises", things seem to be generally going alright. We just had a really big TAG election, for example, and people seem generally pretty happy with the results of the actual election part. I know I am. So... Maybe this is much ado about nothing?  Is it really worth our time to discuss?</p>

<p>I think, yes. Here's why: Good results in recent elections have been a combination of factors that won't always hold and that we shouldn't have to count on.  They as much despite the process as anything (as argued below).</p>

<p>Plus, it's just silly.</p>

<h2>How to address this...?</h2>

<p>Well, that's the big question. But, one thing seem obvious to me: We need to stop insisting that we can't talk about the sandwich and instead focus on how we talk about the sandwich all the way through the process.</p>

<p>We Whole Sandwich People have learned that even if the way the question has asked has been changed, it's still possible to help elect whole sandwiches, it's just <em>much</em> harder and requires an astonishing amount of more coordination, trust and ultimately still some luck.
</p>

<p>The point is that all of the things that we need to happen are already happening, but the process actually fights them.  That's broken.</p>

<p>I think we need to move to a more open model, but one that moves impractical noise out of the general discussion for people whom that is mostly annoying and/or confusing.  I think we need to stop being "procedurally secretive" about nominations.  I think we need to enlist a willing group of people who can help cooperatively search for candidates and make sure that we're getting ingredients that are good by a number of metrics.  I think this group should work to seek something like consensus on a menu of a few possible, "well-balanced meals" and provide recommendations that allow ACs to work with that by default or dig into ala carte options and more details only if they really want to.</p>

<p>Further, I think that rotating terms only complicates this. It's very, very simple to re-affirm seats every time - and this really lets us talk about the whole thing at once.</p>

<p>We don't really even have to change a single rule to accomplish any of this in practice, but currently the rules fight it at every step and make it an extraordinary difficult exercise. We should fix that. I intend to open some issues with some more specific proposals soon, but I'd love to hear anyone's thoughts or work collaborative with anyone to make those good proposals.</p>

]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TAG 2021]]></title>
        <id>https://bkardell.com/blog/TAG-2021.html</id>
        <link href="https://bkardell.com/blog/TAG-2021.html">
        </link>
        <updated>2020-12-31T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[The W3C is in the middle of a big, and arguably very difficult election for the W3C Techincal Architecture Group (aka TAG).  The TAG is one of two small bodies within the W3C which are elected by membership.  If you're unfamilliar with this, I wrote this exceptionally brief Primer for Busy People.  I'd like to tell you why I think this is a big election, why it is complex, what I (parsonally) think about it, and what you can do if you agree.]]></summary>
        <content type="html"><![CDATA[
  <h1 class="contextual-heading" style="font-size: NaNrem;">TAG 2021</h1>
  <p class="segue">The W3C is in the middle of a big, and arguably very difficult election for the W3C Techincal Architecture Group (aka TAG).  The TAG is one of two small bodies within the W3C which are <em>elected</em> by membership.  If you're unfamilliar with this, I wrote this exceptionally brief <a href="https://bkardell.com/blog/W3CPrimer.html">Primer for Busy People</a>.  I'd like to tell you why I think this is a big election, why it is complex, what I (parsonally) think about it, and what you can do if you agree.</p>

<p>
The current W3C TAG election is both important and complex for several reasons.  It's big because 4 of the 6 elected seats are up for election and two exceptional members (Alice Boxhall from Google and David Baron from Mozilla) are unable to run for reelection. It's big because there are) <a href="https://www.w3.org/2020/12/07-tag-nominations">nine candidates</a> and each brings different things to the table (and statements don't always capture enough). It's complex because of the voting system and participation.</p>

<p>Let me share thoughts on what I think would be a good result, and then I'll explain why that's hard to achieve and what I think we need to avoid.</p>

<section class="sectioning">
  <h2 class="contextual-heading" style="font-size: NaNrem;">A good result...</h2>

  <p>I believe the best result involves 3 candidates for sure (listed alphabetically):  Lea Verou, Sangwhan Moon and Theresa O’Connor.</p>

  <p>Let's start with the incumbents.  I fully support re-electing both Theresa O’Connor and Sangwhan Moon and cannot imagine reasons not to.  Both have a history in standards, have served well on TAG, have a diversity of knowledge, and are very reasonable and able to work well.  Re-electing some good incumbents with these qualities is a practical advantage to the TAG as well as they are already well immersed.  These are easy choices.</p>

  <p>Lea Verou is another easy choice for me.  Lea brings a really diverse background, set of perspectives and skills to the table.  She's worked for the W3C, she's a great communicator to developers (this is definitely a great skill in TAG whose outreach is important), she's worked with small teams, produced a number of popular libraries and helped drive some interesting standards. The OpenJS Foundation was pleased to nominate her, but Frontiers and several others were also supportive.  Lea also deserves "high marks".</p>

  <p>These 3 are also a happily diverse group.</p>

  <p>This leaves one seat.  There are 3 other candidates who I think would be good, for different reasons: Martin Thompson, Amy Guy and Jeffrey Yaskin.  Each of them will bring something different to the table and if I am really honest, it is a hard choice. I wish we could seat all 3 of them, but we can't.  At least in this election (that is, they can run again).</p>

  <p>For brevity, I will not even attempt to make all the cases here, but I encourage you to read their statements and ask friends. Truth be told, I have a strong sense that "any mix of these 6 could be fine" and different mixes optimize for slightly different things. Also, as I will explain, there are some things that seem slightly more important to me than who I recommend is third best vs fourth or fifth...</p>
</section>


<section style="margin: 1rem; padding: 1rem; border: 1px solid gray;" class="sectioning">
  <h2 class="contextual-heading" style="font-size: NaNrem;">TLDR; Turn out the vote</h2>
  <p><em>If you find yourself in agreement with me, more or less, I would suggest: "place the 3 I mentioned above (Lea, Tess, Sangwhan) at least your top 4 places", pick a fourth from my other list and put them in whatever order you like.</em>.</p>

  <aside class="captioned-image" style="display: grid; grid-template-columns: 1fr 1fr 1fr;">
    <img src="/media/tess.jpg" style="width: 100%" alt="tess">
    <img src="/media/lea.jpg" style="width: 100%" alt="lea">
    <img src="/media/sangwhan.jpg" style="width: 100%" alt="sangwhan">
    <p style="grid-column: 1/4">I think there are many possible great slates for TAG in 2021, but they all involve Lea, Tess and Sangwhan.  Please help support them and place them among your top 4 votes.</p>
  </aside>
  <p>If you're a W3C member, your AC Representative votes for you -- tell them.  Make sure they vote - the best result definitely depends on higher than average turnout.  Suprisingly, about 75% of membership <em>doesn't normally vote</em>.  These elections are among the rare times when there are "votes" where there are equal voices.  A tiny 1 person member org has exactly the same voting power as every mega company. </p>

  <p>If you're not a W3C member, you don't have a way to vote directly but you <em>can</em> publicly state your support and tag in member orgs or reach out to people you know who work for member orgs.  Historically this has definitely helped - let's keep W3C working well!</p>
</section>

<hr>

<section class="sectioning">
  <h2 class="contextual-heading" style="font-size: NaNrem;">STV, Turnout and Negative Preference</h2>

  <p>The W3C's election system uses STV. STV stands for "single transferrable vote".  Single is the operative word: While you express 9 preferences in this election, only one of those will actually be counted to help someone win a seat.  The counting system is (I think) rather complex, but the higher up on your list someone appears it is far more likely to be the one that counts. Each vote that is counted counts a 1 vote in that candidates' favor.</p>

  <p>Let me stress why this matters: STV optimizes for choosing diversity of opinion with demonstrably critical support.  A passionate group supporting an 'issue' candidate will all place their candidate as the #1 choice - those are guaranteed to be counted.</p>

  <p>Historically only about 100 of the W3C's <a href="https://www.w3.org/Consortium/Member/List">438 member organizations</a> actually turn out in a good election. Let's imagine turnout is even lower in 2020 and it's only 70.  This means that if a candidate reaches 18 votes (a little over 4% of membership) they have a seat, no matter how the rest of us vote - even if everyone else had and actively <em>negative</em> preference for them.</p>

  <p>Non-participation is an issue for all voting systems, but it seems like STV can really amplify outcomes which are undesirable here.  The only solution to this problem is to increase turnout.  Increasing turnout raises the quota bar and helps ensure that this doesn't happen.</p>

  <p>Regardless of how you feel about any of the candidates, please help turnout the vote.  The W3C works best when as many members vote as possible!</p>

</section>

]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020: The Good Parts]]></title>
        <id>https://bkardell.com/blog/2020-Wrap.html</id>
        <link href="https://bkardell.com/blog/2020-Wrap.html">
        </link>
        <updated>2020-12-22T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[Each year, Igalians take a moment and look back on the year and assess what we've accomplished. Last year I wrote a wrap up for 2019 and hinted at being excited about some things in 2020 - I'd like to do the same this year. ]]></summary>
        <content type="html"><![CDATA[

  
	<div id="downloadsPrefs">
		<p style="font-size: 1.5rem">Note from the author...</p>
		<p>My posts frequently (like this one) have a 'theme' and tend to use a number of images for visual flourish. Personally, I like it that way, I find it more engaging and I prefer for people to read it that way.  However, for users on a metered or slow connection, downloading unnecessary images is, well, unnecessary, potentially costly and kind of rude.  Just to be polite to my users, I offer the ability for you to opt out of 'optional' images if the total size of viewing the page would exceed a budget I have currently defined as 200k...
		</p>
		<p><label>Show me all the images when I read <input type="checkbox" id="download-all-images-pref" checked=""></label></p>
		<p><label>Don't ask me again on this device <input type="checkbox" id="download-all-images-pref-save"></label></p>
		<p><button id="setDownloadPrefs">Dismiss</button></p>
	</div>
	
  
  <h1 class="contextual-heading" style="font-size: NaNrem;">2020: The Good Parts</h1>
 
<p class="segue">Each year, Igalians take a moment and look back on the year and assess what we've accomplished. Last year I wrote a wrap up for 2019 and hinted at being excited about some things in 2020 - I'd like to do the same this year. </p>  

<p>Even in a "normal" year, making a list of things that you've actually accomplished can be a good exercise for your mental health. I do it once a month, in fact. It's easy to loose sight beyond what you're thinking of in the moment and feel overwhelmed by the sheer volume. If I can be honest with you, since it's just between us, heading into this exercise always fills me with a sense of dread.  It always seems like now is the time when you have to come to grips with how little you actually accomplished this month.  <strong>But</strong>, my experience is always quite the opposite:  The simple act of even <em>starting</em> to create a list of things you actually did can give you a whole new perspective. Sometimes, usually maybe, I don't even finish the list because I hit a point where I say "Wow, actually, that's quite a lot" and feel quite a bit better.</p>

<p>But, 2020 is, of course, not a "normal year".  It's more than fair to expect less of ourselves.  So, when I sat down to write about what we accomplished, I was faced with this familiar sinking feeling -- and I had precisely the same reaction: Wow! We did <em>a lot</em>.  So, let me share some highlights of Igalia's 2020: The Good Parts.</p>

<section class="sectioning">
  <h2 class="contextual-heading" style="font-size: NaNrem;">All the browsers</h2>

  <p>At Igalia, we are significant contributors to all of the browser engines (and several of the browsers that sit atop them too).  There's a lot of ways you can look at just <em>how much</em> we do, and none of them are perfect, but commits are one kind of easy, but fuzzy measure of comparatively how much we did in the community.  So, how much comparatively less did we do this year, than last? The opposite actually!</p>

  <p>Igalia is again the #2 contributor to Chromium (Microsoft is coming up fast though).  We are also again the #2 contributor to WebKit. Last year we raised some eyebrows by announcing that we had <em>11%</em> of the total commits.  This year: <strong>15.5%!</strong>  We also are up one place to the #6 contributors in the mozilla-central repository and up <em>three places</em> to #4 is servo!  Keep in mind that #1 in all of these are the project owners (Google, Apple and Mozilla respectively).</p>

    <figure>
      <img width="500" src="/media/webkit-2020-contributions.png" style="display:block;margin: 1rem auto;">
      <figcaption style="max-width: 400px;margin: 1rem auto;">We were huge contributors everywhere, but look at this: 15.5% of <em>all</em> WebKit Contributions in 2020!!</figcaption>
    </figure>
</section>
<section class="sectioning">
  <h2 class="contextual-heading" style="font-size: NaNrem;">We worked on <em>so many web features</em>!</h2>

<p>Some of the things we worked on are big or exciting things that everyone can appreciate and I want to highlight a little more here, but the list of features where we worked on at least one (sometimes two) implementations would be prohibitively long!  Here is a very partial list of ones we worked on that I won't be highlighting.</p>

<ul>
<li>Lazy loading </li>
<li>stale-while-revalidate </li>
<li>referrer-policy</li>
<li>Fixing bugs with XHR/fetch </li>
<li>Interop/Improvements to ResizeObserver/IntersectionObserver</li>
<li>Custom Properties performance</li>
<li>Text wrapping, line breaking and whitespace</li>
<li>Trailing ideograph spaces</li>
<li>Default aspect ratio from HTML Attributes</li>
<li>scroll snap</li>
<li>scroll-behavior</li>
<li>overscroll-behavior</li>
<li>scrollend event</li>
<li>Gamepad </li>
<li>PointerLock</li>
<li>list-stlye-type: &lt;string&gt;</li>
<li>::marker</li>
<li>Lgical inset/border/padding/margin</li>
</ul>

  <section class="sectioning">
    <h3 class="contextual-heading" style="font-size: NaNrem;">A few web feature highlights...</h3>
    <p>Here are just a few things that I'd like to say a little more about...</p>

    <section class="sectioning">
      <h4 class="contextual-heading" style="font-size: NaNrem;">Container Queries</h4>
<p>I am exceptionally pleased that we have been pivotal in moving the ball in conversations on container queries.  Not only did our outreach and discussions last year change the temperature of the room, but we got a start on two proposals and actually had CSS Working Group discussion on both.  I'm also really pleased that Igalia built a functional prototype for further review and discussion of our switch proposal and that we've been collaborating with Google and Miriam Suzanne who have picked up where David Baron's proposal left. </p>

  <figure class="captioned-image  optional">
    <img data-src="/media/unicorns.gif" alt="unicorns walking around in paradise">
    <figcaption>It's like we just found not one, but two mytical unicorns</figcaption>
  </figure>
  <p>I expect 2021 to be an exciting year of developments in this space where we get a lot more answers sorted out.</p>
</section>
<section class="sectioning">
  <h4 class="contextual-heading" style="font-size: NaNrem;">MathML</h4>

  <p>Two years ago, MathML fell into a <a href="https://bkardell.com/blog/Math.html">strange place in web history</a> and had an uncertain future in browsers. Igalia has led the charge in righting all of this.  Along with the MathML Refresh Community Group, peer implementers and help from various standards groups we now have <a href="https://mathml-refresh.github.io/mathml-core/">MathML-Core</a> - a well defined spec, with tests that define the most meaningful parts of MathML and their relation to the web platform as interoperability targets. We've made a ton of proress in aligning support, describing how things fit, and invested a lot of time this year up-streaming work in Chromium.  Some additional work remains for next year pending Layout NG work at Google, but it's looking better and better and most of it shipping behind the experimental web platform features flag today.  We also helped create and advocate for a new W3C charter for math.</p>
  <p>But let me share why I'm especially proud of it...</p>
  <figure class="captioned-image  optional">
    <img data-src="/media/math-chalkboard.gif" alt="A professor in front of a chalkboard full of math with space scenes super-imposed">
  </figure>
  <p>Because Math is <em>text</em>, and a phenomenally import <em>kind</em> of text.  The importance of begin able to render formulae is really highlighted during a pandemic, where researchers of all kinds need to share information and students are learning from home. I'm super proud to be a part of this single action that I believe really is a leap in helping the Web realize its potential for these societally important issues.</p>
  </section>
  <section class="sectioning">
    <h4 class="contextual-heading" style="font-size: NaNrem;">SVG/CSS Alignment</h4>

    <p>At the end of last year's post I hinted about something we were working on.  The practical upshots that people will more immediately relate to will be the abilities to do 3D transforms in SVG and <em>hardware accelerate</em> SVG.</p>

    <p>These are long requested enhancements but also come with historical baggage, so it's been difficult for browsers to invest.  It's a great illustration of why Igalia is great for the ecosystem.  This work is getting investment priority because Igalia are the maintainers of <a href="https://wpewebkit.org/">WPE WebKit</a>, the official WebKit port for embedded devices.</p>
    <div class="captioned-image" style="background-color: transparent; margin: 1rem 15%">
      <img src="https://wpewebkit.org/assets/svg/blue_Web_Logo.svg" alt=""></div>
    

    <p>Software on embedded devices has a marriage of unique qualities that lots of controls and displays want to be SVG-based, but also have to deal with typically low end hardware, which usually still has a GPU.  Thus, this problem for those devices is a few orders of magnitude more critical than it is elsewhere.  However, our work will ultimately fund improvements for all WebKit browsers, which also incentivizes others to follow!</p>
</section>
<section class="sectioning">
  <h4 class="contextual-heading" style="font-size: NaNrem;">OffscreenCanvas</h4>

  <p>One thing we haven't talked about yet, but I can't wait to is OffscreenCanvas.  Apple originally pioneered the <code>&lt;canvas&gt;</code> element and it's super cool and useful for a lot of stuff.  Unfortunately, it is historically tied to the DOM, did its work on the main thread and couldn't be used in workers.  This is terrible because <em>many</em> of the use cases it is really great for are real intense.  This is a bad situation - luckily, we're working on it!  Chris Lord has been working on OffscreenCanvas in WebKit and it looks great so far - everything except text portions is done and I've been using it with great results.</p>

  <p>OffscreenCanvas can be used in workers, and you can 'snap off' and transfer the context from a DOM rendered canvas to a worker too.  So great!  And guess why we're investing in it? You guessed it: Embedded.</p>
</section>
<section class="sectioning">
<h4 class="contextual-heading" style="font-size: NaNrem;">WebXR</h4>
  <p>I mean, this is kinda huge right? Igalia is investing to help move XR forward in WebKit - part of this is generalized for WebKit, and I think that is kind of awesome.  Still early days and there's a lot to do, but this is pretty exciting to see developing and I'm proud that Igalia is helping make it happen!</p>
</section>
<section class="sectioning">
  <h4 class="contextual-heading" style="font-size: NaNrem;">Important JavaScript stuff!</h4>

  <p>We Pushed and shipped public/private instance and static fields in JavaScriptCore (WebKit). Private methods are ongoing.  We've really improved coordination with WebKit at large this year, and we're constantly improving the 32bit JSC too.  We're working on WebAssembly and numerous emerging TC39 specifications we're excited about: Module blocks, decorators, bundling, Realms, decimal, records and tuples, Temporal and lots of things for ECMA 402 (Internationalization) too!</p>
</section>
</section>

<section class="sectioning">

  <h3 class="contextual-heading" style="font-size: NaNrem;">Web Related, non-feature things</h3>

  <p>There's a lot of other things that we accomplished this year at Igalia which are pretty exciting too!</p>

  <ul>
  <li><p><strong>Open Prioritization!</strong>  This year we ran a pilot experiment called <a href="https://open-prioritization.igalia.com">"Open Prioritization"</a> to start some big and complex discussions and attempt to find ways to give more people a voice in the prioritization of work on the commons.  We partnered with Open Collective and while I can't say the first experiment was flawless, we learned a lot and are moving forward with a project picked and funded by the larger community as well as establishing a collective to continue to do this!  </p></li>
  <li><p><strong>Our new podcast!</strong>  This year we also launched a podcast.  We've had great discussions on complex topics and had amazing guests, including one of the creators of CSS <a href="https://en.wikipedia.org/wiki/H%C3%A5kon_Wium_Lie">Håkon Wium Lie</a>, people from several browser vendors past and present, people who helped drive the two historically special embeddable forms in HTML (MathML and SVG), and some developer and web friends.  It's available via all of your favorite podcasting services, a playlist on our YouTube channel and <a href="https://www-ci-dev.igalia.com/24-7/chats">on our website</a></p></li>
  <li><p><strong>ipfs</strong> This year we also began working with Protocol Labs to improve some things around protocol handers - those are great for the web at large and it's interesting and exciting to see what is happening with things like IPFS!</p></li>
  <li><p><strong>Joined MDN PAB</strong> This year Igalia also joined the MDN Product Advisory Board, and we're looking forward to helping ensure that the vital resource that is MDN remains healthy!</p></li>
  <li><p><strong>WPE</strong> You might know that Igalia are the maintainers of a few of the <a href="https://webkit.org/downloads/">official WebKit ports</a>, and one of them is for embedded systems. I'm <em>really</em> pleased with all of the thins that this has allowed us to help drive for WebKit and the larger Web Platform.  However, embedded "browsers" was kind of a new topic to me when I began my work here and it's somewhat different than the sorts of challenges I am used to. With embedded systems you typically build the OS specifically for the device.  Sharing the same web tech commons is phenomenal, but for many developers like myself, my questions about embedded were difficult to explore on my own as someone who rarely compiles a browser, much less an operating system!  I'm <em>really</em> pleased with the progress we've made on this, making <a href="https://wpewebkit.org/">wpewebkit.org</a> more friendly, informative and relevant to people who might not already be experts at this, including making easy step-wise options available for people to explore.  Someone with no experience and download a raspbian based OS with WPE WebKit on it and flash it right on a Raspberry Pi just to explore.  For a lot of pet projects,  you can do a lot with that too.  That's not super representative of a good embedded system in terms of performance and things, but it is <em>very</em> easy and it's maintained by us, so it's pretty up to date.  A short step away, if you're pretty comfortable with Linux shell and ssh, you can get a minimal/optimized for Raspberry Pi 3 install you can flash right onto your Pi that runs a Weston Wayland compositor.  Finally, if you already kind of know what you're doing, we maintain Yocto receipes for developers to more easily build and maintain their real systems.</p></li>
  <li><p><strong>Vulkan! driver</strong> - 
  You might know that Igalia does all kinds of stuff beyond just the Web, we work on all of the things that <em>power</em> the web too, and kind of all the way down - so we have lots of areas of specialization.  I think it's really cool that we partnered with Raspberry Pi to create a Vulkan driver for the Mesa graphic driver stack for the latest generation of Raspberry Pi, <a href="https://www.raspberrypi.org/blog/vulkan-update-were-conformant/">achieving conformance in less than 1 year</a>, passing over 100k tests from Kronos' Conformance Test Suite since our initial announcement of drawing the first triangle!</p></li>
  </ul>
</section>
<section class="sectioning">
  <h3 class="contextual-heading" style="font-size: NaNrem;">Looking forward...???</h3>
  <p>So, what exciting things can we look forward to in 2021?  Definitely, advancing all of the things above - and that's exciting enough.  It's hard to know what to be most excited for, but I'm personaly really looking forward to watchin Open Prioritization grow and get a real good idea and very concrete progress on Container Queries issues.  We've also got our eyes on some new things we'll be starting to talk about in the next year, so stay tuned on those too.</p>

  <p>One, that I'd like to mention, however is <strong>tabs</strong>.  Over the past year, Igalia has begun to get involved with efforts like OpenUI and I've been talking to developers and peers at Igalia about tabs. I had some thoughts and ideas that I posted earlier this year.  Just recently some actual work and collaboration has been done - gettinga number of us with similar ideas together to sort  <a href="https://github.com/thepassle/generic-components/">out a useful custom element</a> that we can test out, as well as working in OpenUI on aligning all of the stars we'll need to align as we attempt to approach something like standard tabs.   It is <em>very</em> early days here, but we've gone from a vague blog post to some actual involvement and we're getting behind the idea - which is pretty exciting and I can't wait to say more concrete things here!</p>
</section>

</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Open Prioritization First Experiment Wrap Up]]></title>
        <id>https://bkardell.com/blog/FirstOPFinished.html</id>
        <link href="https://bkardell.com/blog/FirstOPFinished.html">
        </link>
        <updated>2020-11-20T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[Earlier this year, Igalia launched an experiment called "Open Prioritization" which, effectively, lets us pull money together to prioritize work on a feature in web browsers.  In this piece I'll talk about the outcome, lessons learned along the way and next steps.
  ]]></summary>
        <content type="html"><![CDATA[
  <h1 class="contextual-heading" style="font-size: NaNrem;">Open Prioritization First Experiment Wrap Up</h1>
  <p class="segue">Earlier this year, Igalia launched an experiment called "Open Prioritization" which, effectively, lets us pull money together to prioritize work on a feature in web browsers.  In this piece I'll talk about the outcome, lessons learned along the way and next steps.
  </p>
 
  <p>
  Our Open Prioritization experiment was a pretty big idea.  On the surface, it seems to be asking a pretty simple question: "Could we crowdfund some development work on browser?"  However, it was quite a bit more involved in its goals, because there is a lot more hiding behind that question than meets the eye, and most of it is kind of difficult to talk about in purely theoretical ways. I'll get into all of that in a minute, but let's start with the results...</p>

  <section class="sectioning">
<h2 class="contextual-heading" style="font-size: NaNrem;">One project advances: <code>:focus-visible</code></h2>

<p>We began the experiment with six possible things we would try to crowdfund, and I'm pleased to say that one <em>will</em> advance: <code>:focus-visible</code> in WebKit.  </p>

<p>We are working with Open Collective on next steps as it involves some decision making on how we manage future experiments and a bigger idea too.  However, very soon this will shift from a <em>pledged</em> collective which just asked "would you financially support this project if it were to be offered?" to a proper way to collect funds for it.  If you pledged, you will receive an contact when it's ready asking you to fulfill your pledge with information on how.  We will also write a post when that happens as it's likely that at least some people will not come back and fulfill their pledge.</p>

<p>As soon as this begins and enough funds are available, it will enter our developers work queue and as staff frees up, they will shift to begin work on implementing this in WebKit!    </p>

<p>We did it! We at Igalia would like to say a giant "thank you" for all of those who helped support these efforts in improving our commons.</p>
<section class="sectioning">
<h3 class="contextual-heading" style="font-size: NaNrem;">Retrospective</h3>

<p>Let's talk about some of those bigger ideas this experiment was aiming to look at, and lessons we learned along the way, in retrospect...  </p>

<ul>
<li><p><strong>Resources are finite. Prioritization is hard.</strong> No matter how big the budget, resources are still finite and work has to be prioritized. Even with only a few choices on the table to choose from, it's not necessarily easy or plain what to choose because there isn't a "right" answer.  </p></li>
<li><p><strong>There are reasonable arguments for prioritizing different things</strong>.  The two finalists both had strong arguments from different angles, but even a step back - at least <em>some</em> people  chose to pledge to something <em>else</em>.  Some thought that  supporting SVG path syntax in CSS was the best choice. They only pledged to that one. Many of these were final implementations, but this wasn't.  Some people thought that advancing <em>new</em> things that no one else seems to be advancing was the way to go.  Others supported it because they thought that it was really important to boost ones that are help Mozilla.  There just weren't <em>enough</em> people either seeing or agreeing with that weighting of things.</p></li>
<li><p><strong>Cost is a <em>factor</em></strong> It's not an exclusive factor - the cheapest option by far (SVG Path in CSS/Mozilla) was eliminated earlier.  There are other reasons <code>:focus-visible</code> made some giant leaps too, but - at the end of the day the bar was also just lower.  The second place project never actually managed to pull ahead, depite hoving more actual pledged dollars at one point.</p></li>
<li><p><strong>Investing with uncertainty is especially hard</strong> .  Just last week, Twitter exploded with excitement that Google was going to prototype some high level stuff with Container Queries. Fundamental to Google's intent is <em>CSS containment in a single direction</em>.  CSS does not currently define containment in a single direction, but it does define the <em>containment</em> module where it would be defined.   Containment was, in part, trying to lay some potential groundwork here.  When we launched the project, I wrote about this: WebKit doesn't currently support the containment that <em>is</em> defined already and is a necessary prerequisite of any proposal involving that approach. The trouble is: We don't <em>know</em> if that will be the approach, and supporting it is a big task.  Building a high level solution on the magic in our <code>switch</code> proposal, for example, doesn't require containment at all.   Adding general containment support was the most expensive project on our list, by far.  In fact, we could have done a couple of them for that price.  This makes the value proposition of that work very speculative. Despite being potentially critically valuable for the single biggest/longest ask in CSS history - that project didn't make the finals when we put it to the public either.</p></li>
<li><p><strong>Some things are difficult to predict</strong>. Going into this, I didn't know what to expect.  A single viral tweet and a mass of developers pitching in $1 or $2 could, in theory, have funded any of these in hours.  While I didn't expect that, I did kind of expect some amount of funds in the end would be of that sort.  Interestingly, that didn't happen.  At all.  Depite lots of efforts trying to get lots of people to pledge very small dollars even asking specifically, and making it possible to do with a tweet - very, very few did (literally 1 on the winning project pledged less than five dollars).  The most popular pledge was $20 with about a quarter of the pledges being over $50, and going up from there.</p></li>
<li><p><strong>Matching funds are a really big deal</strong>.  You can definitely see why fundraisers stress this.  For the duration of this experiment, we saw  periods of little actual movement, despite lots of tweets about it, likes and blog posts.  There were a few giant leaps, and they all involved offers of matching dollars.  Igalia ourselves, The A11Y Project and AMPHTML all had some offer of matching dollars that really seemed to inspire a lot more participation.  The bigger the matching dollars available, the bigger the participation was.</p></li>
<li><strong>Communication is hard. These might not have been the most ideal projects, in some respects</strong>.  This last bullet is complicated enough that I'll give it it's own section.</li>
</ul>

<section class="sectioning">
<h4 class="contextual-heading" style="font-size: NaNrem;">Lessons learned: Communication challenges</h4>

<p>While I am <em>tremendously</em> happy that <code>inert</code> and <code>:focus-visible</code> were our finalists and both did very well, I am biased.  I helped advocate for and specify these two features before I came to Igalia, working with some Googlers who also did the initial implementations.  I also advocated for them to be included in the list of projects we offered.  However, I failed to anticipate that the very reasons I did both of these would present challenges for the experiment, so I'd like to talk about that a bit...</p>

<p>Unfortunately a confluence of things led to a lot of chatter and blog posts which were effectively saying something along the lines of "Developers shouldn't have to foot the bill because Apple doesn't care about accessibility and refuses to implement something. They don't care, and this is evidence proof - they are the last ones to not implement" and I wound up having a lot of conversations trying to correct the various misunderstanding here.  That's not everyone else's fault, it's mine.  I should have taken more time to communicate these things clearly, but for the record, nothing about this is really correct, so let me take the time to add the clarity for posterity...</p>

<ul>
<li><p><strong>On last implementations</strong> The second implementations only recently began or completed in Firefox, and one of those was also by Igalia.  It seems really unfortunate and not exactly fair to suggest that being a few weeks/months behind, and especially when that came from outside help, is really an indictment.  It's not.  As an example, in the winning project, Chromium shipped this by default in October 2020.  Firefox is <em>right now</em> pending a default release. Keep in mind that vendors don't have perfect insight into what is happening in other browsers, and even if they did reallocating resources isn't a thing that is done on a whim: Different browsers have different people with different skills and availability at any given point in time.</p></li>
<li><p><strong>On refusal to implement</strong> This is 100% incorrect. I want to <em>really</em> stress this:  Every item on our list comes from the list of things that are 'wants' from vendors themselves that need prioritization and are among the things they will be considering taking up next.  If not funded here, it will <em>definitely</em> still get done - it's just impossible to say when really, and whatever priority they give it, they can't give to something else.  This experiment gives us a more definite timeframe <em>and</em> frees them to spend that on implementing something else.</p></li>
<li><p><strong>On web developers shouldn't have to foot the bill</strong>.  Well, if you mean contributing dollars directly in crowdfunding in order to get the feature, we absolutely don't (see above bullet).  However, generally speaking, this was in fact part of the conversation we wanted to start.  Make no mistake: You are paying today, indirectly - and the actual investment back into the commons is inefficeint and non-guaranteed.  It's wonderful that 3 organizations have seemed to foot the bill for decades, but <a href="https://bkardell.com/blog/Reimagining.html">starting a conversation about whether it is talking about that</a> is definitely part of the goal here.</p></li>
<li><p><strong>On "Apple doesn't care about accessibility"</strong> This one makes me really sad, not only because I know it isn't true and it seems easy to show otherwise, but also because there are some really great people from Apple like James Craig who absolutely not only care very deeply but often help lead on important things.</p></li> 
<li><p><strong>On "it's wrong to crowdfund accessibility features"</strong>Unfortunately, it seems the very things that drew me to work on these in the first place wound up working against us a little: Both  <code>inert</code> and <code>:focus-visible</code> are interesting because they are "core features" to the platform that are useful to everyone.  However, they are designed to sit at an intersection where they happily have really out-sized impact for accessibility.  There are good polyfills for both of these which work well and somewhat reduce the degree of 'urgency'.  I really thought that this made for a nice combination of interests/pains might lead to good partnerships of investment where, yes, I imagined that perhaps some organizations interested in advancing the accessibility end of things and who have historically contribute their labors, might see value in contributing to the flame more directly.  Perhaps this wasn't as wise or obviously great as I imagined.</p></li>
</ul>
</section>
</section>
<section class="sectioning">
<h3 class="contextual-heading" style="font-size: NaNrem;">Wrapping up</h3>

<p>All in all, in the end - despite some rocky communications, we are really encouraged by this first experiment.  Thank you to everyone who pledged, boosted, blogged about the effort, etc.  We're really looking forward to taking this much further next year and we'd like to begin by asking you to share which specific projects you'd be interested in seeing or supporting in the future?  Hit us up on <a href="https://twitter.com/briankardell">@briankardell</a> or <a href="https://twitter.com/igalia">@igalia</a>.</p>
</section>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[All Them Switches: Responsive Elements and More]]></title>
        <id>https://bkardell.com/blog/AllThemSwitches.html</id>
        <link href="https://bkardell.com/blog/AllThemSwitches.html">
        </link>
        <updated>2020-11-05T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[In this post I'll talk about developments along the way to a 'responsive elements' proposal (aka container queries/element queries use cases) that I talked about earlier this year, a brief detour along the way, and finally, ask for your input on both...]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">All Them Switches: Responsive Elements and More</h1>
	
	<p class="segue">In this post I'll talk about developments along the way to a 'responsive elements' proposal (aka container queries/element queries use cases) that I talked about earlier this year, a brief detour along the way, and finally, ask for your input on both...</p> 
    <script src="../prism.js"></script>
    <link rel="stylesheet" href="../prism.css">
		<p>I've been talking a lot this year about the web ecosystem as a commons, its health, and why I believe that diversifying investment in it is both important and productive<sup><a href="https://bkardell.com/blog/Beyond.html">1</a>,<a href="https://bkardell.com/blog/EcosystemHealth.html">2</a>,<a href="https://bkardell.com/blog/Reimagining.html">3</a>,<a href="https://www.igalia.com/24-7/chats">4</a>,<a href="https://open-prioritization.igalia.com">5</a></sup>.  Collectively, at Igalia, believe this and <em>we choose to invest in the commons ourselves too</em>.  We try to apply our expertise toward helping solve hard problems that have been long stuck, trying to listen to developers and do things that we believe can help further what we think are valuable causes.  I'd like to tell you the story of one of those efforts, which became two - and enlist your input..
		</p>
		
		<section class="sectioning">
			<h2 class="contextual-heading" style="font-size: NaNrem;">Advancing the Container Queries Cause</h2>
		<p>
		As you may recall, back in Feburary I posted <a href="https://bkardell.com/blog/TowardResponsive.html">an article</a> explaining that we had been working on this problem a bunch, and sharing our thoughts and progress and just letting people know that <em>something</em> is happening... People are listening, and trying. I also shared that our discussions also prompted David Baron's work toward another possible path.  
		</p>
		<p>
		We wanted to present these together, so by late April we both made informal proposals to the CSS working group of what we'd like to explore.  Ours was to begin with a <a href="https://gist.github.com/bkardell/e5d702b15c7bcf2de2d60b80b916e53c"><code>switch()</code> function in CSS</a> focused on slotting into the architecture of CSS in a way that allows us to solve currently impossible problems.  If we can show that this works and progress all of the engines, the problem of sugaring an even higher level expression becomes possible, but we deliver useful values fast too.</p>

    <p class="note">Neither the CSS working nor anyone involved in any of the proposals is arguing that these are an either/or choice here.  We are pursuing options and answering questions, together.  We all believe that working this problem from both ends has definite value in both the short and long term and are mutually supportive.  We are also excited by Miriam Suzanne's recent work.  They are almost certainly complimentary and may even wind up helping each other with different cases.</p>

    <p>Shortly after we presented our idea, Igalia also said that we would be willing to invest  time to try to do some prototyping and implementation exploration and report back.</p>
	</section>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Demos and Updates</h2>
		
		<p>My colleague Javi Fernadez agreed to tackle initial implementation investigations with some down time he had.  Initially, he made some really nice progress pretty quickly, coming up with a strategy, writing some low-level tests and getting them passing. But, then the world got very... you know... hectic.</p>

		<p>However, I'm really happy to announce today that that we have recently completed enough to to share and to say we'll be able to take this experience back to report to CSSWG pretty soon.</p>
      <p class="note">
        The following demos represent research and development. Implementation is limited, not yet standard and was done for the purposes of investigation, dicussion and to answer questions necessary for implementers. It is, nevertheless, real, functioning code.
      </p>
      <div class="captioned-image">
        <iframe width="560" height="315" src="https://www.youtube.com/embed/cWub_3wActI" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
         <p>A running demo in a build of Chromium of an image grid component designed independently from page layout, which uses the proposed CSS <code>switch()</code> function to declaratively, responsively change the <code>grid-template-columns</code> that it uses based on the size available to it.</p>
      </div>
      <p>Cool, right?  Here's a <a href="https://youtu.be/8QFST9MvjyA">short "lightning talk" style presentation on it</a> with some more demos too (note the bit of jank you see is dropped frames from my recording, rendering is very fluid as they are in the version embedded above)...</p>
     
      <p>So - I think this is pretty exciting... What do you think?  Here are answers to some questions I know people have</p>
      <details>
        <summary>FAQ</summary>
        <dl>
          <dt>Why a function and not a MQ or pseduo?</dt>
          <dd><a href="https://bkardell.com/blog/TowardResponsive.html">My post from Feb</a> and the proposal explains that this is not an "instead of", but rather a " simpler and powerful step in breaking down the problem, which is luckily also a very useful step on its own".  The things we want ultimately and tend to discuss are full of <em>several</em> hard problems, not just one. It's very hard to discuss numerous hypotheticals all at once, especially if they represent enormous amounts of work to imagine how they slot together in existing CSS architecture.  That's not to say we <em>shouldn't</em> still try that too, it's just that the path for one is more definite and known.  Our proposal, we believe, neatly slots out a few of the hardest problems in CSS and provides an achieveable answer we can make fast progress on in all engines and lessen the number of open questoons. This could allow us to both take on higher level sugar next, but also to fill that gap in user-land until we do.  Breaking down problems like this is probably a thing you have done on your own engineering projects.  It makes sense.</dd>
          <dt>Why is it called <code>inline available size</code>?</dt>
          <dd>The short answer is because that is accurately what it actually represents internally and there are good arguments for it I'll save for a more detailed post if this carries on, but don't get hung up on that, we haven't begun bikeshedding details of how you write the function and it will change. In fact, these demos use a slightly different format than our proposal because it was easier to parse.  Don't get hung up on that either.</dd>
          <dt>Where can you use switch?</dt>
          <dd>You can use anything anywhere, but it will only be valid and meaningful in certain places. The function will only provide an <code>available-inline-size</code> value to switch in places that the CSS WG agrees to list. Sensibly what you can say is that these will <em>never</em> include things that could create circularties because they are used in derermining the available size.  So, you wont be able to change the display, or the font with a <code>switch()</code> that depends on <code>inine-available-size</code>, but anything that changes properties of a layout module or paint is probably fair game. CSS could make other switchable values available for other properties though.</dd>
          <dt>Why doesn't it use min-width/max-width style like media queries?</dt>
          <dd>Media Queries L4 supports these examples, we just wanted to show you could.  You could just as easily use min-width/max-width here!</dd>
        </dl>
      </details>
    </section>

		<section class="sectioning">
			<h2 class="contextual-heading" style="font-size: NaNrem;"><em>Bonus Round:</em> Switching gears...</h2>
			<p>Shortly after we made our switch proposal, my friend Jon Neal opened a github issue based on some twitter conversations.  For the next week or two this thread was very busy with lots of function proposals that looked vaguely "switch-like".  In fact, a number of them were also using the word "switch". From these, there are 3 ideas which seem interesting, look somewhat similar, but have some (very) importantly different characteristics, challenges and abilities. They are described below.
 			</p>
 			<section class="sectioning">
 				<h3 class="contextual-heading" style="font-size: NaNrem;">nth-value()</h3>
 				<p>This proposal is a function which lets a variable represent an index into a list of possible values. Its use would look like this:</p>
 				<pre><code class="language-javascript">.foo {
  color: 
    nth-value(
      var(--x); 
      red; 
      blue; 
      yellow
    );
}</code></pre>
 			</section>
 			<section class="sectioning">
 				<h3 class="contextual-heading" style="font-size: NaNrem;">cond()</h3>
 				<p>This proposal is a function which allows you to pass pairs of math-like conditions and value associations, as well as a default value.  The conditions are evaluated from left to right and the value following the first condition to be true is used, or the default if none are. Its use would look like this:</p>
 				<pre><code class="language-javascript">.foo {
  margin-left: 
    cond(
      (50vw &lt; 400px) 2em, 
      (50vw &lt; 800px) 1em, 
      0px
    );
}</code></pre>
 			</section>
 			<section class="sectioning">
 				<h3 class="contextual-heading" style="font-size: NaNrem;">switch()</h3>
 				<p>This (our) proposal is a function which works like <code>cond()</code> above, but can provide contextual information only available at appropriate stages in the lifecycle.  In the case of layout properties, it would have the same sorts of information available to it as a layout worklet, thus allowing you to do a lot of the things people want to do with "container queries" as in this example below (available-inline-size is the contextual value provided during layout).  Its use would look like this:</p>
 				<pre><code class="language-javascript">/* (proposed syntax, to be bikeshed much.. note the demos use a less flexible/different/easier to implement syntax for now ) */ 
.foo {
  grid-template-columns: 
    switch(
      (available-inline-size &gt; 1024px) 1fr 4fr 1fr;
      (available-inline-size &gt; 400px) 2fr 1fr;
      (available-inline-size &gt; 100px) 1fr;
      default 1fr;
    );
}</code></pre>
 			</section>

 			<p>As similar as these may seem, almost everything about them concretely is different.  Each is parsed and follows very different paths around what can be resolved and when, as well as what you can do with them.  <code>nth-value()</code>, it was suggested by Mozilla's Emilio Cobos, should be <em>extremely</em> easy to implement because it reuses much of the existing infrastructure for CSS math functions.  In fact, he went ahead and implemented it in Mozilla's code base to illustrate.</p>

 			<p>While things were too hectic to advance our own proposal for a while earlier this year, we did have a enough time to look into that and indeed, the <code>nth-value()</code> proposal was fairly simple to implement in Chromium too!  In a very short time, without very sustained investment, we were able to create a complete patch that we could submit.</p>

 			<p>While <code>nth-value()</code> doesn't help advance the container queries use cases, we agree that it looks like a comparatively easy win for developers, and it might be worth having too.</p>

 			<p>So, we put it to you: Is it?</p> 
 
 			<p>We would love your feedback on both of these things - are they things that you would like to see standards bodies and implementers pursue?  We certainly are willing to implement a similar prototype for WebKit if necessary if developers are interested and it is standardized.  Let us know what you think via <a href="https://twitter.com/igalia">@igalia</a> or <a href="https://twitter.com/briankardell">@briankardell</a>!</p>
		</section>
	
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Numeric Literal Separators: 2 Minute Standards]]></title>
        <id>https://bkardell.com/blog/NumericSeparators.html</id>
        <link href="https://bkardell.com/blog/NumericSeparators.html">
        </link>
        <updated>2020-09-08T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[Part of #StandardsIn2Min, an effort to provide short, but useful information about standards. Follow @StandardsIn2Min for a low-stress way to keep up, 2 minutes at a time.]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Numeric Literal Separators: 2 Minute Standards</h1>
	<p class="segue">Part of <a href="2MinuteStandards.html">#StandardsIn2Min</a>, an effort to provide short, but useful information about standards. Follow @StandardsIn2Min for a low-stress way to keep up, 2 minutes at a time.</p>
    <script src="../prism.js"></script>
    <link rel="stylesheet" href="../prism.css">
    
	<p>Imagine if we didn't have spaces...</p>
	<pre>Imagineifyouhadtoreadallofthesentencesinthispostlikethis.</pre>

	<p>What a nightmare that would be.  Separators are really useful for humans.  However, for most of JavaScript's history, code like this wasn't uncommon...</p>

	<pre><code class="language-javascript">var x = 10000000;</code></pre>

	<p>This is, basically, the same problem.  How many is that?  It's too hard for our eyeballs to parse.  If we were to display that in any form intended to be readable, we'd use some kind of separators to put these into hundred, thousands, millions, etc..  Like this... <code>10,000,000</code></p>

	<p>Numeric separators allow us to achieve this same visual separation for readability in code, using the <code>_</code> (underscore) character. The same example above could be written now as..</p>

	<pre><code class="language-javascript">var x = 10_000_000;</code></pre>

	<p>That is, obviously, an improvement for readability.</p>

	<p>In fact, JavaScript allows for several kinds of numeric literals beyond simple integers and these separators can be employed in all of them for visual separation.  We have decimals (like <code>10_000.00</code>), binary (using 'b', like <code>0b1101_0010</code>), octal (using 'o' like <code>0o7_6_5</code>) and hexidecimal  (using '0x' like <code>0xA0_B2_C3</code>), and BigInt (using 'n' like <code>100_000_000_000_000n</code>).</p>

	<p>There are just a few limitations to be aware of..</p>

	<ol>
		<li>You cannot use two contiguous separators</li>
		<li>You cannot end a number with a separator</li>
		<li>You cannot begin a number with a leading 0 immediately followed by a separator</li>
	</ol>	

	<p>That's about all there is to it.  It has rich support in both modern, shipping engines and is also usable by transpilers.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Reimagining the Vendor-Only Model]]></title>
        <id>https://bkardell.com/blog/Reimagining.html</id>
        <link href="https://bkardell.com/blog/Reimagining.html">
        </link>
        <updated>2020-08-12T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[I have been trying to organize my personal thoughts on this and figure out how to carefuly articulate them for a while now.  I hadn't planned on posting this just yet but recent events and discussions make me think that maybe it is worth sharing.]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Reimagining the Vendor-Only Model</h1>
	<p class="segue">I have been trying to organize my personal thoughts on this and figure out how to carefuly articulate them for a while now.  I hadn't planned on posting this just yet but recent events and discussions make me think that maybe it is worth sharing.</p>

	<p>I've been talking a lot this year about the health of the Web Ecosystem<sup><a href="https://bkardell.com/blog/EcosystemHealth.html">[1]</a>, <a href="https://www.igalia.com/chats/ecosystem-health">[2]</a>, <a href="https://www.igalia.com/chats/ecosystem-health-ii">[3]</a>,</sup>, kind of trying to raise the larger discussion that we should have a discussion about how we think about it and re-consider how we ensure it remains (or increases) its vibrance.   Our recent open-prioritization experiment is meant, in part, to prompt some of this discussion and begin looking at ways to make things better.  Recent news from Mozilla, it seems, has done as much to prompt some urgency on this discussion in people's minds, so let's dig into it.</p>
 
	<p>One comment that I heard a lot over the years goes something like this...</p>

	<blockquote>
	  "This is vendors  <em>responsibility</em> - and their companies make bajillions of dollars on the web... Why don't they just hire more people?.
	</blockquote>

	<p>It's a very natural question since this is the way we tried look at it in practice for roughly the first 25 years, and it's <em>mostly</em> how many of us still think about it.  It's hard to even imagine something else with that kind of inertia.  And... <em>Maybe</em> that model is fine.</p>

	<p>But then again... <em>Maybe not</em>.  I think it's worth considering together, because I am ever increasingly on the "probably not" side. So, now that the conversation is started, let me try to explain why...</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">The trouble with the vendor-only model...</h2>

		<p>In the entire world, at the time of this writing, only 3 organizations currently make the level of investments necessary to maintain a rendering engine at all.  Developers sometimes express frustration at the level of investment because 2 of these 3 organizations are part of the most profitable companies on earth, and they have chosen to invest very differently.  That's fine.  You can continue to do that, and I'm not suggesting that is <em>invalid</em> ... But I think this somewhat of a red herring and that we might be missing the more important conversation.</p>

		<p>At some level, what is <em>far more interesting</em> than the specific arbitrary amount and how it relates to their profits (by this argument both of them could, in theory, invest more) is the fact that they are under no actual obligation to do so, and that <em>in the end,there are no guarantees</em> about continued level of investment.</p>

		<p>Don't get me wrong: I'm tremendously happy that they do, and I absolutely want them to continue playing a core role - just not alone.  I think this is too important to not discuss - because we've already seen several varieties of changes here over time.  Whatever the world looks like today - the only thing you can be sure of is that change is inevitable.  As hard as it is to believe, <em>all</em> the paradigms of organizational power will eventually shift.  The Fortune 500 changes, ultimately many declare bankruptcy and/or are completely re-imagined.  Even if we are extremely fortunate and a company really <em>wants</em>, at its very core, to put in a huge level of investment - there may come a day when they just <em>can't</em>. </p>

		<p>In other words: The traditional model of a few big vendors voluntarily funding development of the Web with very specific revenues puts <em>all</em> of eggs in a very particularly centralized and fickle basket. Just this week, there is related news from Mozilla, kind of demonstrating the latter point.</p>

		<p>Conversely: diversifying investments in the commons would buffer it significantly - and thankfully, it would seem that there are plenty of opportunities to do so. Let's look some..</p>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">Diversifying investments</h3>

			<p>The most obvious and immediate thing to do is to try to expand the sorts of things that have already begun happening and working...</p>

			<p>Finding additional ways of funding an organization like Mozilla itself is a good idea.  Experimenting with new models for funding development like Brave or Puma which could potentially make a browser itself actually profitable are interesting ideas too.</p>

			<p>Some things, like CSS Grid, are examples of really big investments from <em>non-browser vendors</em>.  A whole lot of that implementation in two browsers was funded by Bloomberg Tech and done by Igalia thanks to the increasingly open and collaborative nature of all of the engines.   That is great too!  There are many wealthy organizations out there (Fortune companies)who can help expand investment like that.  If you work for an organization who is intersted in that, reach out to me!</p>

			<p>However, this avenue isn't immediately appealing even to a lot of big companies.  Could we do more?</p>

			<p>Sure, why not!  There is a much bigger group still of big companies who perhaps won't, themselves, fund a whole feature. What we are trying to show with <a href="http://open-prioritization.igalia.com">open-prioritization</a> is that there are many ways that we can pool money toward a specific purpose. Several big companies can share the costs.  That seems good, and it's <em>one thing</em> that open-prioritization allows for: <em>A comparatively small number of really big businesses working better together would be excellent all on its own</em>.  </p>

			<p>But then... If we're exploring diversifying funding, why place some arbitrary limits on "bigness"?  What makes them special?  Perhaps you don't have to be a mega-company to help advance things?  Experimenting with this is also part of what open-prioritization is about -Maybe there doesn't even have to be a single answer.  In fact, maybe it's better if there isn't! </p>
		</section>
		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">Exploring <em>many</em> models</h3>

			<p>When I was a kid, and cable television was "new", my grandmother thought it was just ridiculous that someone would <em>pay</em> for television. After all, it came over the air wave "for free".  Of course... It wasn't free, and despite it costing a lot to produce and run, it was a money making endeavor.  The cost to maintain a station is comparatively tiny compared to the potential profits they could make from shoving advertising in our eyeballs.  You paid.  All the way through the system.  A small amount of your product purchases funded advertising, which funded broadcast.</p>

			<p>Actually, the web isn't that different here.  It is traditionally largely supported by very few revenues, mainly advertising in search.  When ad revenue takes a hit, so do the budgets.  </p>

			<p>But over time we've created lots of ways to explore different models.  When it comes to watching TV and movies, I haven't seen "traditional commercial TV" in years - I use some other model to pay for content more directly.  And, honestly, this has been good in a whole lot of ways.  It's generated some real good content even.  Still, there are other forms of short form content - podcasts or music services, for example, that I actually prefer the advertising model for.  And, you can also donate to public radio.  </p>

			<p>Open prioritization is aimed at exploring all of the different ways that we can realize our potential for power and give people <em>opportunities</em> to improve things in many ways.</p>

			<p>With a way to pool funding, there doesn't have to be artificial barriers.  We can give smaller organizations opportunities to participate however they can:  Maybe that is simply through advocating/lobbying bigger companies for specific dollars for development of specific thing.  Perhaps sometimes they don't even need a bigger company.  Perhaps together, several smaller organizations can rally together to act as a big one?  It seems good to allow them to.  </p>

			<p>The one thing that you'll notice that all answers have in common is that ultimately, somehow <em>lots</em> of people are paying in small amounts, and lots of little bits add up to a lot.</p>

			<section class="sectioning">
				<h4 class="contextual-heading" style="font-size: NaNrem;">The potential power of collectives</h4> 

				<p>With no arbitrary limits, even developers themselves could play a big, very direct role... If we want to. </p>

				<p><em>Should we</em>?  I don't know!  </p>

				<p>I'd love to talk about it though because I think that hidden in here is something with <em>immense potential for good</em> by voluntarily even small commitments simply by realizing our sheer numbers. This is sort of the power of collectives.  If you're looking for interesting analaogies, check out <a href="https://www.piamancini.com/">Pia Mancini's Talks/Media posts</a> explaining things like how and why this can also work for governments.</p>

				<p>Consider that meetup.com alone lists something like 18 million people who identify as Web developers.  Using that as just some kind of working number:  If even 1/10th of those developers decided to voluntarily contribute a single dollar each month, this would be over 21.5 million dollars annually that we could use to collectively <em>directly</em> decide what should happen.  This seems very plausible as you need far less than 1/10th if we assume that some people would be willing to give $2 or $5 or maybe even $10.</p>

				<p>In other words, in addition to all of the other ways that we can explore, even we developers actuallly have <em>enormous</em> potential untapped power even with <em>very limited kinds of investment</em> to play <em>a role</em> (not exclusively)... That's more than we can convince most big companies to invest, to directly shape things today.  That would be some <em>extreme</em> diversification, and a real "commons".  To <em>me</em> that seems really good to have in the mix... If we want it.</p>

				<p>I guess the question is: Do we? </p>

				<p>I am willing to accept the possibility that it is possible that the answer is simply "No thanks" - but I think it's great that at least we have the choice/opportunity and an avenue to begin to consider <em>all of these things</em>, directly, and have the discussion.  I think that's a real positive.  What do you think? I'd love to hear from you.  If you like this idea, pass it on and maybe consider pledging $1 to one of the pledge collectives in our <a href="https://open-prioritization.igalia.com">open-prioritization experiment</a> to help advance the larger ideas and conversation.</p>

				<a href="https://open-prioritization.igalia.com">
				<div class="captioned-image" style="background-color: transparent;">
					<img src="/media/open-prioritization.png" alt="Open Prioritization, by Igalia: An experiment in crowdfunding prioritization">
				</div>
				</a>
				
			</section>
		</section>
	</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Open Prioritization and Advocacy]]></title>
        <id>https://bkardell.com/blog/OpenPrioritization.html</id>
        <link href="https://bkardell.com/blog/OpenPrioritization.html">
        </link>
        <updated>2020-07-13T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[I love the Web, and I want it to thrive.  It is an incredible open commons that makes so much of modern life possible, and better.  If you're reading this, chances are pretty good that the web has even enabled your career.  Mine too!  But there's also pretty good odds that you think it could be better.  I agree!  Let me tell you about an experiment at visibly making it better, together.]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Open Prioritization and Advocacy</h1>
	<p class="segue">I love the Web, and I want it to thrive.  It is an incredible open commons that makes so much of modern life possible, and better.  If you're reading this, chances are pretty good that the web has even enabled your career.  Mine too!  But there's also pretty good odds that you think <em>it could be better</em>.  I agree!  Let me tell you about an experiment at <em>visibly</em> making it better, together.</p>
	
	<p>The web is 30 years old. In that time we've learned a lot about the problem space involved. I write a lot about the challenges we've faced, and am a regular advocate for the idea that we can do better.  I believe that when we lean on pragmatic answers and include more people as directly as possible, we all win.  The commons wins.  That's why I am so excited about our new experiment...</p>

	<div class="captioned-image" style="background-color: transparent;">
		<img src="/media/open-prioritization.png" alt="Open Prioritization, by Igalia: An experiment in crowdfunding prioritization">
	</div>


	<p>If you're a fan of The ShopTalk show, <a href="https://shoptalkshow.com/407/">I first publicly discussed the idea there back in <em>April</em></a>. But, as you might have noticed, the world has been full of snags in 2020 and things got a little delayed.  But finally, here we are!</p>

	<p>There will be lots of posts describing what its about, it's a big idea. But, in a very few words: Here are six concrete web features that we can crowdfund together toward advancing actual work.  Here is a means of having a tangible voice in how we advance this commons that we all share.  Below is a short  (5 min) video that describes it and answers questions submitted by some friends we talked to about it early...</p>

	<div class="video-container captioned-image" style="background-color: transparent;">
		<iframe src="https://www.youtube.com/embed/xCRxNVbUqhk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
	</div>

	<p>More details are available at <a href="https://igalia.com/open-prioritization">open-prioritization.igalia.com</a>, and that's where you can pledge, and it contains more details too.  But before you pledge anything, I'd like to offer some thoughts on it before you go.</p>

	<p>I think that we'll see that prioritization is <em>hard</em>.  I think we'll see that we probably don't all automatically agree on which thing is <em>most worthy</em> of prioritization.</p>

	<p><em>And that's ok</em>... In fact, it's really interesting.</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Which of the 6 features best to support...</h2>

		<p>Everything is best.  It depends who you ask.  Part of the purpose of this experiment is to show that groups can find new ways to <em>advocate</em> and <em>work together to decide to do concrete things</em>. So let me attempt to do just that and get the ball rolling...</p>

		<p>Let me tell you how <em>I prioritized</em>, and why - and advocate for the ones I think are the best choices.  You can judge for yourself whether that makes sense and make your own decisions, or share your own advocacy.</p>

		<p>First off, note that you have a lot of expressive power here:  I pledged <em>something</em> to <em>everything</em> because I really believe in the idea.  I think think that changing the status quo and advancing <em>any</em> of these in a new way is a positive result.  What I did is vary <em>how much</em> I helped anything along the way to it's goal.  My minium was $5, my max was $40, but that could just as well be $1 or $5.  If you pledge $1, that is $1 worth of funding of the commons that didn't exist before and lots of $1's can get it done too.</p>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">The implmentation projects I pledged less to...</h3>

			<ul>
	
				<li>
					<p><strong>Selector list support for `<code>:not</code> in Chromium</strong>`</p>

					<p>I pledged $5 (1/9600th of the goal) to supporting selector lists in Chromium.  Chrome already spends way more than anyone else, and is by far the most dominant browser.  Generally speaking, I am more interested in helping to level things out.  Almost as importantly to me: It's only a second implementation - it doesn't achieve universality in the way some others do. Those are more valuable to me. A second implementation is better than a just first, and it's a necessary step along the way, for sure.  However, it still leaves me without for a while.  In a very tangible way, the last implementation is worth a lot.  Finally, while it offers something toward specifity issues, mostly, it's just sugar.  Would I like it? Sure, but it feels like there not a long of "bang for the buck".</p>
				</li> 

				<li>
					<p><strong>CSS <code>lab()</code>` colors in Firefox</strong></p>

					<p>I gave $5 toward CSS's lab colors in Firefox too (the same degree toward the goal as <code>:not</code>).  This was a tough one, I'm not going to lie. It is potentially very valuable, but it is the kind of investment you only fully realize at the end of several stages. This is, in fact, one of the reasons it's been slow to get traction. We have to get this to get colors level 5.   We want this in design tools.  But the real value is only when we have all of the next steps, even across the platform (like in canvas too).  It would also appear that this is not  yet a "cross the finish line" investment.</p>
				</li>


				<li>
					<p><strong>CSS <code>d</code> (SVG path) support in Firefox</strong></p>

					<p>I also pledged $5 toward supporting SVG (d) path in CSS in Firefox (but that is 1/2600th of the goal).  It seems less important than others to me on a number of counts.  It also doesn't help us cross a finish line: Once this is done, it still isn't in WebKit. That said, it is very good bang for the buck and I think we could get it done.</p>
				</li>
	
				<li>
					<p><strong>CSS <code>contain</code> in WebKit</strong></p>

					<p>I pledged $10 toward supporting containment in WebKit (1/7100th of the the goal).  Again, this is tough.  It is a last mile - only WebKit doesn't support it.  However, the price tag is much bigger too, and my big challenge here is that I don't know what the payoff really looks like is in practice. It can improve performance, which is great, but for me - it's extra.  It can be used in conjunction with ResizeObserver for some pretty good approximations of container queries, which is great too.  But it isn't <em>100% clear</em> that it is a necessary element for container queries. In fact, in <a href="https://bkardell.com/blog/TowardResponsive.html">our proposal</a> and experiments to far, it isn't necessary for a whole bunch of use cases.  But... it's uncertain. If it turns out to be critical, and we haven't invested in it, it's only that much longer until we finally arrive. So... Sigh... That's a tough one.</p>
				</li>
			</ul>
		</section>
		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">My top choices: <code>inert</code> and <code>focus-visible</code></h3>

			<p>This leads me to my top choices: <code>:focus-visible</code> (I pledged $40 - 1/875th of the goal) and <code>inert</code> ($40 or 1 1200th of the goal)- both in WebKit.  </p>

			<p>Why these?  Well, because I think they are the most valuable in a lot of ways.   Of course, I'm biased:   I worked on the design and championing of both of these features with my friends Alice Boxhall and Rob Dodson, including writing and popularizing polyfills and iterating on the details with practical feedback and experience under our belts.  And now, here we are a few years later and these are <em>last miles</em> - only one browser doesn't have them implemented or isn't implementing yet.  We can change that.</p>

			<p>I did this work on my own time. as a developer, before I came to work for Igalia because there were real problems my teams were facing every day. Worse, they were right at the intersection of UX, DX and accessibility so the pains were very real.  So, let me tell you about what they are and why I think they're worth giving that last push.</p>

			<section class="sectioning">
				<h4 class="contextual-heading" style="font-size: NaNrem;"><code>inert</code></h4>

				<p>There are a whole bunch of design patterns that require you to manage a whole bunch of other properties enmasse:  Make them unclickable, make their text unselectable, hide them from screen readers via ARIA, take them out of sequential focus temporarily.  Probably the easiest example of this is when a dialog is open - the rest of the page is 'there' but kind of 'inert'.  In fact, inert was as a term to the HTML specification when <code>&lt;dialog&gt;</code> was spec'ed.  But this isn't the only time when you want this behavior and, in fact, it is useful in a number of other use cases - but it's hard enough that even a lot of common UI libraries get it wrong.</p>

				<p><code>inert</code> exposes the ability to say "the stuff inside this element should be all of those things" in a simple way via a reflecting attribute - that is, you can set it in markup as an attribute, or via DOM property (which updates the attribute).</p>

				<p>You can read more about it, including other use cases and details <a href="https://github.com/WICG/inert/blob/master/explainer.md#use-cases">on the WICG explainer</a> (the related pull request to HTML itself is pending).</p>
			</section>

			<section class="sectioning">
				<h4 class="contextual-heading" style="font-size: NaNrem;"><code>:focus-visible</code></h4>


				<p>Research shows that way too many people disable the focus indicator, at the cost of accessibility.  Well, there's kind of a rational explanation for why this happens so much, and that is that CSS's <code>:focus</code> pseudo-class is just plain broken.</p>

				<p>From very early days, browsers have used various heuristics to make the native focus ring valuable and, at the same time, unobtrusive.  There are times when an element gets focus where showing the indicator just <em>feels bad</em> and is there for no particularly really good reason for it to be there. The use cases are not all the same: If you click on a password field in a busy environment, for example, it's very important that you understand that your typed characters will land in the obscured field -- so you will <em>always</em> get a focus indicator.  If you click on a button, on the other hand, and it gets a focus indicator, that might be disorienting... <em>But</em> if you <em>keyboard navigate to that button</em>, then you <em>need</em> to see the indicator.</p>

				<p>Unfortunately, designs frequently don't "work" with only the native indicator, and the trouble is that traditionally the only tool that designers have to style the focus indicator is :focus, and it doesn't care about any of that.  The net result is that, unfortunately, attempting to use <code>:focus</code> to make the focus indicator work better for your site results in unfamilliar and disorienting UX for everyone.  Given only bad choices, the answer that too many make is the easy one: Simply disable it.</p>

				<p><code>:focus-visible</code>, on the other hand, only matches if the indicator would natively be shown, taking into account all of the browser UX research and preventing this disconnect.  It is, in our experience, provably easier to get right, and more successful.</p>
			</section>
		</section>
		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">What about you?</h3>

			<p>What about you, will you support something? Will you help advocate for the priority of something specific?  I (and we at Igalia at large) would love to hear your thoughts - share them on social media with the hashtag <code>#openprioritization</code> so that we can try to collect them.</p>
		</section>
	</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Web Engine Diversity and Ecosystem Health]]></title>
        <id>https://bkardell.com/blog/EcosystemHealth.html</id>
        <link href="https://bkardell.com/blog/EcosystemHealth.html">
        </link>
        <updated>2020-05-26T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[For many years, we've seen lots of blog posts and conversation on the topic of "browser engine diversity".  I'd like to offer a slightly tilted view of this based instead on "the health of the ecosystem", and explain why I think this is more valuable measure and way to discuss these topics.]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Web Engine Diversity and Ecosystem Health</h1>
	
	
	<p class="segue">For many years, we've seen lots of blog posts and conversation on the topic of "browser engine diversity".  I'd like to offer a slightly tilted view of this based instead on "the health of the ecosystem", and explain why I think this is more valuable measure and way to discuss these topics.</p>
	<p>Back in January, Jeremy Keith <a href="https://adactio.com/journal/16331">compared the complexity of browser engine diversity to political systems</a>...</p> 
	<blockquote>
	<p>If you have hundreds of different political parties, that’s not ideal. But if you only have one political party, that’s very bad indeed!</p>
	</blockquote>
	<p>I like this analogy because I think he's right in even more ways than he intended. It's almost self-evident: 1 is too few, a hundred is too many - it's just chaos and noise.  But what is the ideal number?  This answer dogs us a lot, in part because it is not only unanswerable, it's actually kind of a red herring. I think there's something to this that leads to an important takeaway about how we think about the problem...</p>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Numbers and goals...</h2>
		<p>The interesting part about this analogy is that the simple number of political parties isn't actually a very meaningful measure: Parties can differ a lot, or they can differ a little.  6 parties that barely disagree is quite a different thing than 3 that disagree substantially.  Further, it's not simply a matter of giving voice to every dissenting opinion that matters either: There are political parties formed on ideas of hate, for example. Adding those doesn't add good things.  In short, what really matters is the <em>goal</em> of those numbers.</p>
		<p>In the case of the political analogy, the real aim is about what makes for a healthy, effective and just model of governance.  Similarly on the topic of "browser engine diversity", I believe that the real goal is "What makes for a healthy and effective ecosystem?" and that the numbers we frequently talk about (and how) can easily lead us into perhaps the wrong takeaways.</p>
	</section>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Older engines and diversity</h2>
		<p>It is fairly common that discussions of browser diversity point to the Web's own history for examples of "why engine diversity matters": IE vs Netscape are often held up.  IE's dominance and ability to dictate the market (or even kill it in this case) was overcome by diversity.  This is true, but very incomplete:  There's a lot more beneath the surface...</p>
		<p>Consider, for example, the fact that for a time there were <em>only two</em> mainstream browsers - and the very dominant one (IE) was both  entirely proprietary and based on a single proprietary OS.</p>
		<p>Consider how different this could have been, if IE had been open source and properly licensed.  Even if Microsoft didn't want it to run on other operating systems, someone else could step in and fill that gap.  If Microsoft walked away from the Web, or worse, went belly up, someone could fork and take over the project.  If, for any reason at all, the primary maintainer cannot prioritize - other people and organization could more directly invest in advancements.</p>
		<p>A while later, Opera's Presto was very interesting, even multi-OS - but ultimately similarly proprietary.</p>
		<p>So, while we had greater 'diversity', these numbers alone aren't a great measure of the overall health of the ecosystem.</p>
	</section>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">The most healthy, open ecosystem ever.</h2>
		<p>This is in stark contrast to the situation today: In important ways, we are a <em>more</em> diverse, efficient and healthier ecosystem with the three multi-os, open source engines we have left (Blink, Gecko and WebKit) than when we had had more and were dominated by projects that weren't that at all.</p>
		<div class="note">
			A lot of people seem to want to suggest that there aren't really 3 today because blink was born from a fork of WebKit, or because they think that WebKit is somehow "Just for iOS".
			<p>There are certainly 3 <em>entirely</em> different JavaScript engines, and 3 <em>entirely</em> different architectures.  There are some bits that remain similar, but the truth is that that this is neither new nor easily solvable.  Web engines today are so astonishingly complex (measured in tens of millions of lines of code) that we only get new ones through evolution.  For the most part, this has been true for a long time.  Even Netscape was a "take 2" from many of the same minds from Mosaic.  Mozilla was created from a rework of Netscape.  Even IE was born by licensing the Mosaic code.  WebKit was born by forking KHTML.  In other words: The critical investment required to create a full-blown compliant browser from nothing would be mind-boggling if everything were stopped today - and it never stops.</p>
		</div>
		<p>Today, the 3 that remain are all multi-OS.</p>
		<blockquote><em>"...Wait, even WebKit?"</em> - you, just now.</blockquote>
		<p>Yes!  I'm glad you asked!  The GNOME flagship Epiphany/Web browser for Linux is WebKit based -- and <em>billions</em> of devices are based on Embedded WebKit.  PS4 is a fun example of something lots of people might be familliar with -- not only the Web browser on your PS4, but in fact lots of the UI itself is made with Web content running in a WebKit based browser.  But chances are pretty good that you encounter emdedded WebKit all the time: On cable boxes, smart TVs and appliances, kiosks, car and airplane infotainment systems, digital signage and so on.</p>
		<p>This is possible because WebKit (and all of the engines today) are open source.  Because of this, they all receive investments more widely than the org that maintains them, and that's expanding in important ways that are very good for the health of the ecosystem.</p>
		<p>Igalia, where I work, for example are able to work on all of the browsers and help expand investment in advancing the commons.  The list of things we have helped advance, and who has helped fund that is growing all the time: From recent things in JavaScript like class fields and Big Integer, to CSS features like CSS Grid, or features in HTML like lazy loading - the benefits of this are clear.</p>
		<p>This also leads to lots of interesting new opportunities.  For example, we are the creators/maintainers of WPE, the official WebKit Port for Embedded that powers tons of those devices mentioned above. This matters a lot because a rising tide lifts all boats in the commons.  You can see an example of this in that Igalia is advancing work on SVG2 and hardware acceleration for SVG in WebKit - a topic which has failed to get the prioritization for years, but is especially critical for lots of embedded use cases.  If you're interested in this, as well as <a href="https://www.igalia.com/chats/Igalia-Chats-Niko-SVG-WPE" rel="nofollow">some interesting history of SVG, WebKit, HTML/CSS and embedded browsers, have a listen to this.</a></p>
	</section>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Opportunities to do better...</h2>

		<p>There is another interesting thing here that is always left out of these discussions but I think is considerably interesting in this reframing.  A funny little quirk of history is that while we say there are 3 rendering engines, that's only <em>partially</em> true.</p>
		<p>More specifically, there are 3 <em>modern browser rendering engines</em>,  and <em>a bunch of other rendering engines that aren't that</em>.</p>
		<p>Amazon, for example, has a renderer that is used for ebooks and printing.  PrinceXML has a renderer used for print.  Antenna house too.  And there are more still.</p>
		<p>For the most part, these are proprietary and what they do and don't support isn't necessarily clear cut.  Their support for modern standards is pretty ragged and the gaps are only likely to grow faster. This is a shame as there are lots of potentially useful things for these industries, like Houdini which are unlikely to ever exist for them.</p>
		<p>This is a topic I'd love to see discussed more for several reasons - but mainy they center on the fact that it is just harder for us to move forward <em>together</em> if things are too fragmented.  Instead of growing together and a rising tide lifting all boats - the boats are kind of all in entirely different bodies of water.</p>
		<p>I would love to see some effort to resolve this.  Imagine if these vendors came into the fray and either invested in basing their work on modern engines (hopefully various), <em>or</em> pulled together to create something new.  That <em>might</em> be the one practical way we could arrive at an actual viable 4th engine somehow.</p>
		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">Why now is a good time to discuss it</h3>
		<p>Most of these engines also contain some things that were developed in standards organizations but which no browser supports... That's kind of why they were created.  However, there are new opportunities to align...</p>
		<p>Web engine architectures are like a lot of engineering projects - they grow, they get crufty, you get locked into certain boundaries that you know you'd like to escape.  However,until you do you can't really afford to tackle certain kinds of problems.  That's a big part of why <em>browser</em> engines today don't do a lot of the things you needed to fill their use cases.  Browser architectures have traditionally, generally not been well-prepared for the problems of print or ebooks, and that's part of why we find ourselves in the current situation.</p>
		<p>However, for many years, there has been much rework and rearchitecture of layout engines aimed at solving precisely the fundamental sorts of things that prevented those sorts of things from being considered.</p>
		<p>Stir in that most of our office suites and things are now web based and there's considerable incentives to figuring out things like good print and pagination.</p>
		</section>
	</section>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">More open <em>prioritization</em></h2>
		<p>But it's not just the projects being open source that matters, it's also that this affords us new opportunities for standardization itself.</p>
		<p>Ultimately, it is the calculus of prioritization which impacts our ability to get things done almost more than anything else.  Historically, lots of companies get together and, effectively, ask that a very few companies do the work.  They are big organizations with big investments, to be sure - but they are all constrained by hard limits.  The gauntlet of issues surrounding our ability to prioritize everything from attention to actual implementation have stymied many a topic.</p>
		<p>But in this new age, companies like Igalia are showing that there is potentially a whole new game here: Where centralized, concrete investments from outside that small group can lift up the commons,  benefit everyone and help drive progress.</p>
		<p>In other words: Things are <em>better</em> and <em>healthier</em> because we continue to find better ways to work <em>together</em>. And when we do, <em>everyone</em> does better.</p>
	</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Interactive Elements: A Strange Game]]></title>
        <id>https://bkardell.com/blog/StrangeGame.html</id>
        <link href="https://bkardell.com/blog/StrangeGame.html">
        </link>
        <updated>2020-04-29T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[
      It can seem especially frustrating to a lot of developers that we don't have more elements "out of the box" as part of HTML. I mean: Where are the tabs? How do we not have tabs by now? It seems like almost every week this comes up in some fashion or other. In this piece I'll talk a little about why, how to see this for what it is, how we're trying to move forward - and also present an interesting experiment for your consideration and feedback that may help inform some of these efforts.  If you want, you can skip right to the 'new idea/experiment', but I think this background is pretty helpful in understanding it, so please, come back and read it...]]></summary>
        <content type="html"><![CDATA[
    
    
	<div id="downloadsPrefs">
		<p style="font-size: 1.5rem">Note from the author...</p>
		<p>My posts frequently (like this one) have a 'theme' and tend to use a number of images for visual flourish. Personally, I like it that way, I find it more engaging and I prefer for people to read it that way.  However, for users on a metered or slow connection, downloading unnecessary images is, well, unnecessary, potentially costly and kind of rude.  Just to be polite to my users, I offer the ability for you to opt out of 'optional' images if the total size of viewing the page would exceed a budget I have currently defined as 200k...
		</p>
		<p><label>Show me all the images when I read <input type="checkbox" id="download-all-images-pref" checked=""></label></p>
		<p><label>Don't ask me again on this device <input type="checkbox" id="download-all-images-pref-save"></label></p>
		<p><button id="setDownloadPrefs">Dismiss</button></p>
	</div>
	
    <h1 class="contextual-heading" style="font-size: NaNrem;">Interactive Elements: A Strange Game</h1>
    <p class="segue">
      It can seem especially frustrating to a lot of developers that we don't have more elements "out of the box" as part of HTML. I mean: <em>Where are the tabs? How do we not have tabs by now?</em> It seems like almost every week this comes up in some fashion or other. In this piece I'll talk a little about why, how to see this for what it is, how we're trying to move forward - and also present an interesting experiment for your consideration and feedback that may help inform some of these efforts.  If you want, you can <a href="#chess">skip right to the 'new idea/experiment'</a>, but I think this background is pretty helpful in understanding it, so please, come back and read it...</p>

    <p>
      Let's have a look at <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element" target="_blank">HTML so far</a>:  ~10 of the elements are the 'boilerplate stuff': &lt;html&gt;, &lt;body&gt;, &lt;head&gt; and metadata stuff - &lt;link&gt;, &lt;meta&gt;, &lt;base&gt;, &lt;style&gt;, &lt;script&gt;, &lt;title&gt;. There's a few elements for linking and embedding other content and multimedia, and a few with special powers like &lt;template&gt; and &lt;slot&gt;. And then the rest:  ~30 are "weak semantics about text" that aren't interactive and don't have signficant (any) special meaning necessarily and are primarily just things with default CSS stylesheet rules. About 15 are "weak semantics about text, but meaningfully weak" - stuff like lists.  ~15 are sectioning or landmarks.  11 more are about tables - a 2 dimensional relationship of text.  14 are about forms. And then two are... well... something else.  We'll come back to that. And ~30 are deprecated.
    </p>

    <p>The route to all of these elements was a little different - and they have different costs associated with them, and offer different value.  One thing that's interesting to note is that the majority of them are what Dave Rupert refers to as "Spicy Divs".  That is, there's not much to them - they aren't complex or interactive, and they don't bring a ton of real world value. That's not to say they are <em>without value</em>, but ultimately we spend a lot of time and bandwidth in standards debating what often amount to silly things because of it.  &lt;main&gt; is a kind of a good example.  Nothing wrong with it as an element, it's great, in fact - it just has a long and complex backstory that ultimately cost a lot relative to its real world value and proven use.  Tons of time defining and debating &lt;address&gt;, which isn't really that meaningful to browsers, and then lots of evangelism telling people they're using it wrong - only in the end to eventually have to admit that it ultimately means the thing people used it as.</p>
 
    <p>The second thing to notice is that there there are <em>very few</em> interactive elements.  Further, most of the ones we usually talk about are about <em>forms</em>.  And that lead us to this: Interactive, form-related elements on the web are... tricky.</p>

    <section class="sectioning">
      <h2 class="contextual-heading" style="font-size: NaNrem;">The form-related game</h2>
    <p>
      On the one hand, there's a lot to like about native, interactive form controls. In theory, they can
      bring a simple declarative form with all kinds of goodness in terms of platform integration, portability and centralized work on accessibility and UX.
    </p>
 
    <p>
      Unfortunately...
    </p>

    <pre class="wargames">...primary goal has not yet been achieved
&gt; What is the primary goal?
To win the game.</pre>

    <p>More simply: Despite a lot of work, and huge investments, people still gravitate toward custom implementations. That's not good for anybody.</p>

    <p><em>Why are native form controls hard?</em></p>
    

    <p>Well... So many reasons, but to start with, the one that they could really do without is that they got off to a tricky start by design.</p>
      

    <section class="sectioning">
      <h3 class="contextual-heading" style="font-size: NaNrem;"><pre>&lt;input type="WOPR"&gt;</pre></h3>

    <p>
      <em>Most</em> of the form-related controls are created based on
      <code>&lt;input type-"..."&gt;</code>. You've probably heard someone suggest that
      this is great because in cases where it isn't supported, simply
      providing the text field is fine. However, this is incomplete and we've been paying the price for it for a long time.</p>

    <pre class="wargames">&gt; People sometimes make... mistakes.</pre>

    <p>Did you ever notice how the JavaScript API surface of input works differently based on the type?  If the type is number and you type gibberish that looks remotely 'potentially numbery' like '12312e314124', then <code>.value</code> will be '' (empty string).  Or, the checkbox type has a checked property, but that means that input type=number has that property too... What does it do? Anything!? Or, have you ever noticed how <code>.selectionStart</code> and <code>.selectionEnd</code> actually would initially  <em>throw</em> if you tried to use them on a numeric input type?! (<a href="https://github.com/whatwg/html/pull/1006">fixed by Simon Pieters</a>).  If not, go have a watch of <a href="https://vimeo.com/144980655">Monica Dinculescu's <code>&lt;input&gt;</code> I ♡ you, but you're
        bringing me down</a> -- a 45 minute talk about <em>just this</em>.</p>

    <p>  
      Ultimately, many of these problems stem from us accepting the illusion presented that a date picker <em>is a</em> kind of text input.
    </p>

    <figure class="captioned-image optional">
      <img data-src="/media/10-wargames-falken.png" alt="Faulken pointing to NORAD screens">
      <figcaption>Stephen Falken: Uh, uh, General, what you see on these screens up here is a fantasy; a computer-enhanced hallucination. Those blips are not real missiles. They're phantoms.</figcaption>
    </figure>

    <p>
      Realistically, a date picker <em>isn't</em> a text input.  Perhaps at an HTTP level, or even a database level, it's just a value - but controls are about how to <em>populate</em> values, and that's quite a different thing. It's not an <em>is-a</em> relationship:  A date picker is a
      completely different complex control with potentially lots of complex interactions: Different things
      it needs to communicate, lots of sub-iteractions to manage, and so on.
    </p>

    <p>All of this is why you might hear people suggest "LSP" or <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">"Favor composition over inheritance"</a> as a better alternative.</p>

    <section class="sectioning">
      <h4 class="contextual-heading" style="font-size: NaNrem;">Acceptable Losses?</h4>
      <p>This is exacerbated by the fact that at the end of the day, developers are left with some pretty unappealing choices: Something is going to be sacrificed.</p>

      <p>
        Color pickers provide a great example of how this plays out in practice: Will developers building the sorts of tools that use a color picker allow a simple input field as the fallback until <em>every browser</em> ships something acceptable?  Seems like not much of a choice really.
      </p>

      <p>
        Sadly the story for 'polyfilling' an element also still isn't great: It's really just 'replacing it with something else entirely'.
        So, at the end of the day, you've got to go and find something that is a good quality stand in anyway.  Finally, since literally <em>everything your code relies on understanding the DOM</em>, and that stand in will have entirely <em>different</em> DOM, you now have two entirely different interactive trees to worry about. Yikes.
      </p>

      <p>
        Further, this situation isn't necessarily short lived, historically.  The reality is that lacking universal support can be the case for a long time: Native
        support for
        <code>&lt;input type="color"&gt;</code> was added to the last major
        browser... <em>Checks notes...</em> <strong>last year</strong>.
      </p>

      <p>
        Even after all of that... Guess what? It still isn't <em>acceptable</em>
        for a lot of people because it isn't styleable -- and in fact, it has entirely different UI and features everywhere. While this <em>can</em> occasionally be very useful on some kinds of devices, it makes things like providing helpful documentation hard.  Worse, even the native ones weren't super keyboard accessible either.
      </p>

      <p>
        So... That's a lot of barriers and disincentives.

      </p>

      <p>
        Conversely, a custom solution can solve all of these problems <em>now</em>... So it shouldn't actually be surprising that developers often
        choose a custom solution: There are no 'acceptable losses' for developers here - all of the choices are somehow bad.
      </p>
    </section>

    <section class="sectioning">
      <h4 class="contextual-heading" style="font-size: NaNrem;">Learn, dammit.</h4>
      <p>
        Now, let's talk about how we get out of this mess. 
      </p>
      <p>
        You'll be happy to know that there <em>are</em> efforts to both learn and
        improve existing native interactive elements. If you haven't seen Greg
        Whitworth and Nicole Sullivan's talk
        <a href="https://www.youtube.com/watch?v=ZFvPLrKZywA">HTML Isn't Done</a> from
        Chrome Dev Summit last year, I would highly recommend it (below).
      </p>
    <figure class="captioned-image optional">
      <iframe width="560" height="315" src="https://www.youtube.com/embed/ZFvPLrKZywA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
    </figure>

    <p>
      There's also been a heck of a lot of work to make it possible for authors to
      define their own interactive elements that work just like the native ones. The
      idea is to empower developers to explore the space and try to help
      find the really sweet spots that strike all of the right balances.
    </p>

    <p>
      It's worth pointing out <em>why</em> this is useful - it's not just an
      academic exercise that is trying to push responsibility to developers. It's
      important because the truth is: <em>We don't actually know how</em>. We
      need to be able to throw lots of things at the wall and see what sticks.
      The trouble is, currently (historically) failure is <em>really</em> slow and
      <em>really</em> expensive -- and even our most educated 'guesses' at
      improvement are still just that: Guesses. We haven't proved we have this
      figured out yet.
        </p>

    <figure class="captioned-image optional">
      <img data-src="/media/wopr.jpeg" alt="WOPR">
      <figcaption>We need something like the WOPR for playing out possible answers without doing harm: failing, and learning - that's what the custom elements stuff is all about.</figcaption>
    </figure>
 

    <section class="sectioning">
      <h5 class="contextual-heading" style="font-size: NaNrem;"><pre class="wargames">Shall we play a (different) game?</pre></h5>

    <p>
      Ok, but hold on.... Let's talk about <em>non-form related interactive controls</em> now.  Realistically, we've come up with really only 1 strictly generic non-form-related UI control in 30 years: <code>&lt;details&gt;</code>.  That "other" one in my intial list.  Wow... And we've had that done for like 10 years, right?  Let's see, it's been supported universally since... <em>checks notes...</em>
      <strong>Jan 14, <em>2020</em></strong>. Waaaaat?</p>

    <p>But... Again, it has most of the same kinds of general problems. In the most
      recent HTTP Almanac data, it was the 102nd most used HTML element... Can you
      even <em>name</em> 101 other HTML elements?  It has styling problems.  It's misunderstood.  It was hard to polyfill well without just creating other problems.
    </p>

    <p>So... This is terrible.</p>
 
    <p>
      Our continued problems in this space are part of the reason there is hesitancy
      to take up entirely <em>new</em> things... Like, tabs.
    </p>

    <p>
      Back in 2015, I managed to get a number of people in Web standards (especially
      a11y) interested in working on a possible new element proposal for HTML which
      would have given not only the tabset but some other things as
      well. Determined not to be doomed by the same sorts of stylability
      problems, we set out to define things that would become shadow parts and
      themes and custom properties and so on.
    </p>

    <p>
      But, in many ways, it wasn't great. Recently, this has got me to thinking:
      What if this isn't even the right game we're playing? What if for
      <em>some</em> elements at least - non-form associated ones - the right lesson to take away is that this is an unnecessary exercise in futility?
    </p>

    <p>
      Maybe we need a <em>different</em> kind of experiment: One that just says
      "Strange game. The only winning move is not to play".
    </p>
    </section>

    <section class="sectioning">
      <h5 class="contextual-heading" style="font-size: NaNrem;"><pre class="wargames">How about a nice game of chess?</pre></h5>
    <p>
      So, here's the basic idea: What if we just created a resilient pattern
      focused on mainly <em>function</em> and <em>meaning</em> -- and
      <em>hardly at all on the UI aspect</em>. What if instead of inventing complex
      new ways to strike the balance of preventing authors from styling too much, we
      mostly just acknowledged the fact that they want to, and... let them.
    </p>

    <p>
      What if, like with <code>&lt;video&gt;</code> you could kind of just take
      control of the UI, but... maybe without throwing it away entirely.
    </p>

    <p>
      I spoke with Greg Whitworth about this, who has been investigating how to improve the existing controls on the Web (see also <a href="https://gwhitworth.com/blog/2019/10/can-we-please-style-select/">Can we please style select?</a>.  
    </p>

    <p>
      In fact, he completely agreed with the overall premise and went on to described how...</p>

    <blockquote>
      The core mission of Open UI, a new W3C community group, is to document the anatomies, behaviors and states of components and controls from across frameworks. By doing this, we can ensure that the key pieces that folks don't want to re-create, they don't have to. We've got a few different ideas that are beginning to take shape but changes like this are like peeling an onion. <em>If it's a new control/component then it would be a bit more straight forward but the most painful controls we've found have been on the web since the 90s.</em> So we'll be gathering telemetry and ensuring that any modifications we ultimately propose are web compatible.
    </blockquote>

    <p>
      In our conversation we discussed how things like tabs seem like an interesting target where this kind of thing
      might just work really well. The particular shape of the tabs problem lends
      itself, I think, to easily trying something completely different and entirely without past baggage.</p>

    <p> 
      So, in that light 
      <a href="https://panel-set.glitch.me/reciepe.html">here's a demo/link to just such an experiment</a> which gives us... <em>tabs!</em> - and which we think has some nice qualities:
    </p> 

    <ul>
      <li>
        It is a declarative <em>decorator</em> over otherwise good but
        non-interactive semantics. That means there's no miss of differing
        interaction issues here caused by complex inheritance. It's <em>composition</em>.
      </li>
      <li>
        It doesn't change your light DOM, and it <em>barely</em> uses Shadow DOM.
        There's no "two trees" problem, and there's not secrets or new
        challenges. Go ahead, use CSS and JavaScript.
      </li>
      <li>
        It adds the functionality: roving focus, keyboard handling, accessibility stuff and a simple container for you. That's it, really.
      </li>
      <li>
        If you really <em>want</em> to opt in to some simple 'default styles' and like the 'minor tweaksonly' approach, it has an attribute that enables 'native' look and feel, with a bit less flexibility, but which might be enough for some people.  It just starts with the assumption that that's not the case.
      </li> 
    </ul>

    <p>So... that's it. It could for sure use more work, but WDYT? Would you try it out?  Let us know your thoughts?  Such experiments will be useful in informing work and directions for efforts like Open-UI and possible future standards.</p>

    <p>Will it help?  To be honest, I don't know, but maybe the right way to learn involves trying something really different, and I'm open to anything...</p>

     <figure class="captioned-image optional">
      <iframe width="560" height="315" src="https://www.youtube.com/embed/7FogV4Qv8p8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
    </figure>
</section>

</section></section></section>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Making Sure Content Lives On...]]></title>
        <id>https://bkardell.com/blog/ArchivingByDefault.html</id>
        <link href="https://bkardell.com/blog/ArchivingByDefault.html">
        </link>
        <updated>2020-03-09T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[
        In which I describe a problem, share a possible solution that you can use today, and, hopefully start a conversation... 
    ]]></summary>
        <content type="html"><![CDATA[
    <h1 class="contextual-heading" style="font-size: NaNrem;">Making Sure Content Lives On...</h1>
    <p class="segue">
        In which I describe a problem, share a possible solution that you can use today, and, hopefully start a conversation... 
    </p>

    <p class="note">(If you already know the problem, and you're looking for the solution, check out <a href="https://github.com/bkardell/auto-archive/blob/master/README.md">the documentation over on GitHub</a>)</p>

    <p>There's a series of problems that I experience literally all the time:  Link rot and the disappearance of our history.  I have written posts on blogging platforms that no longer exist.  I have written guest posts for sites that no longer exist.  I frequently wish that that content still existed - not only still existed, but was findable again.  I have researched hard and bookmarked or linked to obscure but important history which, you guessed it: no longer exists.  This is tremendously frustrating, but also just really sad (more on this later)...</p>


    <p>This is one thing that really interests me about a potentially future decentralized web - we could do better here. At the same time, we often have to deal with the Web we have now - not the one we wish existed. So, let's look the state of this today?</p> 

    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: NaNrem;">Archiving today</h2>

        <p>Luckily, when content disappears, I can often turn to the Internet Archive and the Wayback Machine to find content.  But the truth is that they've got a very tough challenge.  Identifing all the things that need indexing is really hard.  If you have a relatively small blog or site, especially, it can be hard to find.  Then, even if it gets found, how do they know when you've got some new content?  So, the net result is that no matter how good a job they do - a lot of really interesting stuff can wind up not being findable today there either.</p>

        <p>History itself makes this problem even harder: It's very unpredictable.  Often things are considerably more interesting in only in hindsight.  Things also tend to seem a lot more stable in the short term than they are in reality in the long arc of history:  Even giant "too big to fail", semi-monopolies ultimately shift, burn out or even just break their history.  One of the wisest things I ever heard was an older engineer who told me if they could impart one things to students it was this - all the paradigms that you think are forever will shift. Once upon a time IBM ruled the world.  Motorola was absolutely dominant.  Once upon a time, SourceForge was the shit.  Then GitHub.  Once upon a time Netscape won the interwebs, and then they lost it to Microsoft who won it even bigger.  Then Microsoft lost it again.</p>  

        <p>It's ok if you don't share my desire, but I <em>personally</em>, want to be sure my content continues to exist, and people can find it via old links despite all of these uncertain futures.  Today, the best chance of that is in the Internet Archive.  So, how can I be more confident that it does? </p>

        <section class="sectioning">
            <h3 class="contextual-heading" style="font-size: NaNrem;">Maybe... Just ask?</h3>
            <p>Interestingly, a lot of these problems get hella simpler if you just ask.</p>

            <p>For a really long time now (as long as I can remember the Wayback Machine existing), you can go to https://archive.org/web/, enter a URL under the heading 'Save page now' and click the button. </p>

            <p>A notification model is way, way simpler than somehow trying to monitor and guess - and we use this same basic pattern for several things in engineering.  It's quite success at keeping things efficient.</p>

            <p>The trouble here is, I think, that it is currently manual.  It's unlikely that I'm going to do that every time I add a new blog post, even thought that's <em>exactly</em> what I want to do.</p>

            <p>Maybe we can fix that?</p>

        </section>

        <section class="sectioning">
            <h3 class="contextual-heading" style="font-size: NaNrem;">Asking by default...</h3>
            <p>
                Recently, this got me to thinking... What if it were really easy to incorporate this into whatever blog software you use today?  Think about it:  RSS continues to thrive, in part, because you hardly have to know about it - it's so comparatively easy (entirely free in some cases in that it is just part of the software you get).  If you could incorporate this into your system in somewhere between 0 and 30 minutes, would you?  
            </p>

            <p>
                Every now and then I have a thought like this that seems so clear to me that I figure "surely this must exist? Why do I not know about it?"  So, I asked around on social media.  Surprisingly, I could find no one who was aware of such a thing. What about publicly exposing an API? Do they? Maybe? Kinda?  Could we make it easier?
            </p>

            <p>
                Brendan Eich cc'ed Jason Scott from the Internet Archive into the conversation.  Jason cc'ed in Mark Graham, the Director for the Wayback Machine.  Mark got me access to a service and set up this little experiement to try it out. 
            </p>
        </section>
        <section class="sectioning">
            <h3 class="contextual-heading" style="font-size: NaNrem;">But how to get there?</h3>
            <p>
                One of the challenges here is how to make something 'easy' when there are so many blogging systems and site hosting things.   Submitting a URL automatically, even, is technically not hard - but fitting that into each system is a little more work.  Then, each of these uses different frameworks, languages, package managers and so on.  I don't really have time to build out 100 different 'easy' solutions just to start a conversation.  In fact, I want this for myself, and currently my setup is very custom - it's all stuff I wrote that works for me but would be more or less useful to someone else.
            </p>

            <p>
            But then I had a thought:  There's actually lots of good stuff in the Web we have for tackling this problem.
            </p>

            <section class="sectioning">
                <h4 class="contextual-heading" style="font-size: NaNrem;">Existing, higher level hooks</h4>
            <p>
                HTTP is already a nice, high-level API that doesn't really care about how you built your site, but it might not be automatically obvious or convenient regarding how to plug into it.  We already have lots of infrastructure too... As I said, almost everyone has an RSS feed and almost everyone has some kind of 'publish' process.  Maybe I could make it easy for huge swaths of people by just tapping into some big patterns and existing machinery.  What I really wanted, I thought, was just a flexible and easy to integrate service.  It doesn't have to block your build, it isn't absolutely critical, it's just "hey... I just published a thing."  
            </p>
            <p>
                So, I decided to try this..
            </p>

            <p>I created an HTTP service with a Cloudflare worker.  Cloudflare workers are interesting because they're deployed at the edge, they sleep when youre not using them and you can process up to 100k requests per-day for free.  Since they kind of spin up as needed, handling errors for this kind of thing is easy too - you aren't going to pollute the system somehow.  In fact, they seem kind of ideally suited for this kind of thing.</p>

            <p>This seems very good actually because blogs, especially personal blogs, tend to churn out content "slowly".  That is, 100k requests per day seems like plenty for a few orders of magnitude more blogs than that. So... Cool.  </p>

            <p>
                Basically - you send an HTTP Post to this service with the content-type `application/json` and provide some stuff in the body.  But <em>what</em> you provide can differ to make integration very easy regardless of what kind of setup you have.  It allows, effectively 3 'shapes' that I've put together that should fit nicely and easily into whatever system you already have today and be easy to integrate.  For my own blog, hosted on gh pages, it took ~5 minutes.  If you're interested in trying it out or seeing what I came up with  <a href="https://github.com/bkardell/auto-archive/blob/master/README.md">check out the experiment itself</a>, try it out.</p>
            </section>
            <p>I think it should be pretty easy and flexible, but I don't know, wdyt?  Are you willing to try it?  Is this an interesting problem?  Should the Wayback maybe offer something like this itself?  How could it be better?
            </p>
        </section>
    </section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Toward Responsive Elements]]></title>
        <id>https://bkardell.com/blog/TowardResponsive.html</id>
        <link href="https://bkardell.com/blog/TowardResponsive.html">
        </link>
        <updated>2020-02-12T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[In this piece I'll talk about the "Container Queries" problem, try to shine some light on some misconceptions, and tell you about the state of things.]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Toward Responsive Elements</h1>
	
	<p class="segue">In this piece I'll talk about the "Container Queries" problem, try to shine some light on some misconceptions, and tell you about the state of things.</p>
	
	<script src="../prism.js"></script>
    <link rel="stylesheet" href="../prism.css">
    

	<p>As developers, watching standards can be frustrating.  We might learn of some new spec developing, some new features landing that you weren't even aware of - maybe many of these are even things you don't actually care much about.  In the meantime, "Container Queries," clearly the single most requested feature in CSS for years, appears to be just... ignored.</p>

	<p>What gives? Why does the CSS Working Group not seem to listen?  After all of these years -- why isn't there some official CSS <em>spec</em> at least?</p>

	<p>It's very easy to get the wrong impression about what's going on (or isn't) in Web standards, and why.  This isn't because it is a secret, but because there is just so <em>much</em> happening and so many levels of discussion it would be impossible to follow it all.  The net result is often that things the view from the outside can feel kind of opaque - and our impression can easily be a kind of a distorted image.  Shining some light on this sort of thing is one of my goals this year, so let's start here…</p> 

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">N <em>problems</em></h2>
		<p>One of the more difficult aspects of "Container Queries" is that there isn't actually a nice, single problem to discuss.  Many discussions begin with how to write them - usually in a way that "feels kind of obvious" -- but this usually (inadvertently) often creates a <em>stack</em> of new asks of CSS and numerous conflicts.  These wind up derailing the conversation.  In the process, it can also (inadvertently) hand-wave over tremendous complexity of what turn out to be very significant particulars and important aspects of CSS's current design and implementation.  This makes it very hard to focus a discussion, it is easily derailed.</p>
 
		<p>A big part of the challenge here is that depending on how you divide up the problem, some of these asks would suggest that fundamental changes are necessary to the architectures of browser engines.  Worse:  We don't even know what they would be. Unfortunately, it's very hard to appreciate what this <em>means</em> in practice since so much of this, again, deals with things that are opaque to most developers.  For now: suffice it to say that any such re-architecture could require a entirely unknown (in years) speculative amount of work in order to create and prove such an idea - and then many more years of development per-engine.  Worse, all of this would be similarly invisible to developers in the meantime.  Did you know, for example, that there are multiple many year long efforts with huge investments underway <em>already</em> aimed at unlocking many new things in CSS?  There are - and I don't mean Houdini!</p>

		<p>Ok, but what about container queries...</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">What <em>is</em> happening in this space?</h2>
		<p>The truth is that while it might look like nothing much is happening, there have been <em>lots</em> of discussions and efforts to feel out various ideas.  They have mostly, unfortunately, run into certain kinds of problems very quickly and it's not been at all easy to even determine which paths aren't dead ends.</p>
		<p>More recently, many have instead turned to "how do we make this into more solvable problems?" and "How do we actually make some progress, mitigate risk - take a step, and and actually get something to developers?"</p>
		<p>Two important ideas that have gotten a lot of traction in this time are 'containment' and ResizeObserver, both of which force us to tackle a different set of (hopefully more answerable) problems - allow us to lay what we think are probably necessary foundations to solving the problem, while enabling developers to meet these and other use cases more effectively, and in more timely fashion.</p>
	
		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">Lightspeed progress, actually...</h3>
			<p>Standards move at a scale unfamilliar to most of us.  Consider that we shifted the stalemate conversation and <code>ResizeObserver</code> was envisioned, incubated, speced, tested, agreed upon, <em>iterated on</em> (we got things wrong!) and implemented <em>in all browsers</em> in about 2 years (with Igalia doing the latest implementation in WebKit thanks to some sponsorship from AMP).  Containment is shipping in 2 of 3 engines.</p>
			<p>This is standards and normalization of something really new for developers at light speed.</p>
		</section>
		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">But... this is incomplete.</h3>
			<p>Yes, it is.</p>
			<p>In the <a href="https://webkit.org/blog/9997/resizeobserver-in-webkit/" rel="nofollow">announcement about Igalia's implementation of ResizeObserver in WebKit</a>, I included an overly simple example of how you could create responsive components with very few lines of code that actually worked, regardless of how or why things resized.  But... no one wants us to ultimately have to write JavaScript for this… Literally nobody that I know of - so what gives?
			</p>
			<p>First, by treating it this way, we've made some incredible, <em>actual</em> progress on parts of the problem in very short time - for the first time.   All browsers will have <code>ResizeObserver</code> now.  In the meantime developers will <em>at least</em> have the ability to do a thing they couldn't actually do before, and do the things they could do before more efficiently and experiments can understand a little more about how it actually has to work.   That's good for developers - we don't have to wait forever for something better than what we have now... But it's also good for problem solving: As things settle and we have more answers, its allowed us to focus conversations more and ask better next questions.</p> 
		</section>
		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">We <em>definitely</em> care about moving futher!</h3>
	<p>For the last several months, I and some folks at Igalia have been working on this space.  We're <em>very</em> interested in helping find the connections that bring together developers, implementer and standards bodies to solve the problems. </p>
	<p>Internally, we have had numerous sessions to discuss past proposals and tackle challenges. I've been researching the various user-space solutions: How they work, what their actual use is like on the Web, and so on.  In developer space we've worked a lot with folks active in this space: I've met regularly with Tommy Hodgins and Jon Neal, and had discussions with folks like Eric Portis, Brad Frost, Scott Jehl and several others.</p>
	<p>But we've also talked to people from Google, Mozilla and Apple, and they've been very helpful and willing to chat - both commenting on and generating new ideas and discussions.  I really can't stress enough how helpful these discussions have been, or how willing all of the CSSWG members representing browser vendors have been to spend time doing this.  Just during the recent travel for the CSS Working Group face to face, I had <em>numerous</em> breakout discussions - many hours worth of idea trading between Igalians and browser folks.</p>
	<p>I wish I could say that we were 'there' but we're not.</p>
	<p>As it stands it seems that there are kind of a few 'big ideas' that seem like they could go somewhere - but not actually agreement on whether one or both of them is acceptable or prioritization yet.</p>
	<section class="sectioning">
		<h4 class="contextual-heading" style="font-size: NaNrem;">Current ideas...</h4>
		<p>
			There does seem to be some general agreement on at least one part of what I am going to call instead "Responsive Design for Components" and that is that flipping the problem on its head is better.  In other words: Let's see if we can find a way talk about how we can expose the necessary <em>powers</em> in CSS, in a way that is largely compatible with CSS's architecture today... even if writing that looks absolutely nothing like past proposals at first.
		</p>
		<p>
			There seems to be some agreement at large that this is where the hardest problems lie and separating that part of the discussion from things that we <em>can</em>  already sugar in user-space seems helpful for making progreess.  This has led to a few different ideas…
		</p>
		<section class="sectioning">
			<h5 class="contextual-heading" style="font-size: NaNrem;">Lay down small, very optimal paths in CSS</h5>
			<p>One very good idea generated by lots of discussion with many people during CSS Working Group breakouts sprang from a thought from Google's Ian Kilpatrick…
			</p>
			<p class="note">I am constantly impressed by Ian's ability to listen, pull the right threads, help guide the big ship and coordinate progress on even long visions that enable us to exceed current problem limits.  You probably don't hear a lot about him, but the Web is a lot better for his efforts…</p>
			<p>The crux of the idea is that there seems to be one 'almost natural' space that enables a ton of the use cases we've actually seen in research.  Some community members have landed on not entirely dissimilar ideas: creating something of an 'if' via calc expressions to express different values for properties. The idea goes something like this:</p>
			<p>Imagine that we added a function, let's call it "switch" which allows you to express something "like a media query" with several possible values for a property.  These would be based on the available-inline-width during the layout phase.  Something like this…</p>

			<pre><code class="language-css">.foo {
	display: grid;
	grid-template-columns: switch(
	 	(available-inline-size &gt; 1024px) 1fr 4fr 1fr;
	 	(available-inline-size &gt; 400px) 2fr 1fr;
		(available-inline-size &gt; 100px) 1fr;
		default 1fr;
	 );
}</code></pre>
			<p>
				See, a a whole lot of the problems with existing ideas is that they heave to loop back through (expensive) phases potentially several times and make it (seemingly) impossible to keep CSS rendering in the same frame - thus requiring fairly major architectural changes.  It would need to be limited to properties that affect things only <em>during layout</em>, but another practical benefit here is that it would be not that hard to start some basic prototyping and feel this out a little in an implementation without actually committing to years of work.  It would be, very likely, deliverable to developers in a comparatively short amount of time.
			</p>
			<p>
				<em>Importantly: While it makes sense to expose this step to developers, the idea really is that if we could get agreement and answers on this piece, we would be able to discuss concretely how we sugar some better syntax which effectly distills down to this, internally.  Nicole Sullivan also has some ideas which might help here, and which I look forward to learn more about.</em>
			</p>
		</section>  
		<section class="sectioning">
			<h5 class="contextual-heading" style="font-size: NaNrem;">Better Containment <em>and</em>...</h5>
			<p>There is another interesting idea generated primarily by David Baron at Mozilla.  In fact, David has a whole series of proposals on this that would lay out how to get all the way there in one vision.  It is still being fleshed out, he's writing something up as I write this.</p>
			<p>I've seen some early drafts and it's really interesting but it's worth noting that it also isn't without a practical order of dependencies.  Effectively, everything in David's idea hinges on "containment in a single direction".  This is the smallest and most fundamental property - the next step is almost certainly to define and impement that and if we have that then the next things follow more easily - but so do many other possibilities.</p>
			<p>This information as a property potentially provides an <em>opportunity</em> for an optimization of what would happen if you built any system with <code>ResizeObserver</code> today, where it might be possible to avoid complete trips through the event loop.</p>
			<p>It isn't currently clear how some questions will be answered but David is one of the most knowledgable people I know, and there's a lot of good stuff in here - I look forward to seeing more details!</p>
		</section>
		<section class="sectioning">
			<h5 class="contextual-heading" style="font-size: NaNrem;">Some new experiments?</h5>
			<p>Another idea that we've tossed around a bunch at Igalia and with several developers punts on a few hard of these hard questions whose answers seem hard to speculate on and really focus instead on the circularity problem and thinking about the kind of unbounded space of use cases developers seem to imagine. Perhaps it "fits" with option B even...</p>
			<p>These would be a kind of declarative way, in CSS, to wire up finite states. They would focus on a laying down a single new path in CSS that allowed us to express pattern of what to observe, how to observe it, how to measure and say that an element was in a particular state.  The practical upshot of this is that not just Container Queries, but lots and lots of use cases that are currently hard to solve in CSS, but are entirely solvable in JS with Observers become suddenly possible to just express via CSS without asking a lot of new stuff CSS - and doing that might <em>present</em> some new optimization opportunities, but it might not -- and at least we wouldn't block moving forward.</p>
		</section> 

		<section class="sectioning"> 
			<h5 class="contextual-heading" style="font-size: NaNrem;">So what's next?</h5>
			<p>In the coming months I hope to continue to think about,  explore this space and continue discussions with others.  I would love to publish some research and maybe some new (functional) experiments with JS that aim to be 'closer' to a path that might be paveable.  We have raw materials and enough information to understand some of where things are disjoint between what we're asking for and the practical aspects of what we're proving.</p>
			<p>Ultimately, I'd like to help gather all of these ideas back into a place where we have enough to really dig in in WICG or CSSWG without a very significant likelihood of easy derailment.  Sooner rather than later, I hope.</p>
			<p>In the meantime - let's celebrate that we have actually made progress and work to encourage more!</p>
		</section>
	</section> 
</section> 
</section>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unlocking Colors]]></title>
        <id>https://bkardell.com/blog/Unlocking-Colors.html</id>
        <link href="https://bkardell.com/blog/Unlocking-Colors.html">
        </link>
        <updated>2020-01-01T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[
		Despite the fact that I draw and paint, and am involved with CSS, I am actually generally not good at design. Color, however, is endlessly fascinating. As there have been many color-oriented proposals for CSS, to enable people who are good at design, I thought it might be nice to write about an important, but underdiscussed bit that's necessary in order to really unlock a lot - and how we can help.
	]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Unlocking Colors</h1>
	<p class="segue">
		Despite the fact that <a href="https://www.instagram.com/kardellbrian/">I draw and paint</a>, and am involved with CSS, I am actually generally not good at design. Color, however, is endlessly fascinating. As there have been many color-oriented proposals for CSS, to enable people who <em>are</em> good at design, I thought it might be nice to write about an important, but underdiscussed bit that's necessary in order to really unlock a lot - and how we can help.
	</p>
	

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">First... What even is color?</h2>

		<p>When you look at real physical things, what you perceive as color is a reflection of which wavelengths of light bounce back at you without being 'swallowed up' by the pigment.    Pigments are subtractive, light is additive.  That is, if you combine all of the colors of light, you get a pure white - and if you combine all of the pigments you get a pure black.</p>

		<p>There is 'real information' that exists in the universe, but there are also real constraints when talking about color:  If the light shining on that pigment doesn't contain all of the possible wavelengths, that color will look different, for example. Or, if your monitor can't physically create true pure white or pure black, things are a little skewed.</p>

		<p>When we're doing things digitally there's another important constraint:  We also have to <em>store</em> colors with some number of bits and format, express those somehow, and be able to reason about them.   Storing 'really accurate true values' would require a lot of bits and machines (at various points in time) weren't capable of creating, managing or displaying - either efficiently, or at all.  As a result, over the years we've created a lot of interesting tradeoffs with regard to color.</p>
		</section>

		<section class="sectioning">
			<h2 class="contextual-heading" style="font-size: NaNrem;">Color spaces</h2>
			<p>If you can imagine a true rainbow, with all of the real possible colors in the universe, the set of those you can actually represent (and how you move about in it) is called a 'color space'.  The limits of a color space are called its  gammut.  Because your monitor works with light, it is an additive process and 'Red' 'Green' and 'Blue' combined to create white (once upon a time, with actual CRTs).  Along the way, we created the sRGB color space.  The sRGB color space is a limited section of the rainbow, which is kind of narrow compared to all of the possible colors that exist in nature, but is very optimized for machines and common cases.  Below is an example from  <a href="https://en.wikipedia.org/wiki/SRGB" rel="nofollow">wikipedia</a> illustrating sRBG and color spaces illustrating the sRGB color space.  The colors within the triangle are part of the sRGB color space.</p>

			<aside class="captioned-image optional">
				<img src="https://upload.wikimedia.org/wikipedia/commons/6/60/Cie_Chart_with_sRGB_gamut_by_spigget.png" alt="sRGB color space, visualized">
			</aside>


			<p>But, the point is that these tradeoffs aren't always desirable.</p>

			<p>Today, for example, we have machines capable of recording or displaying things with a much wider gammut -- the stuff outside the triangle. Your monitor does, and if you have a TV capable of HDR (hi dynamic range) that's got a wider gammut, for example... And then, there's the math…</p>
		</section>

		<section class="sectioning">
			<h2 class="contextual-heading" style="font-size: NaNrem;">Humans vs machines</h2>
			<p>It's more than just efficiency.  sRGB, as I said, is really built for machines - and humans and machines are quite different.  If I showed you a color and asked you to guess the value in RGB, mapped that to sRGB space and showed you on your monitor, chances that you could get it very close are pretty low in general. You can test this theory with <a href="http://hex-guess.glitch.me/">hex-guess.glitch.me</a>.  Further, there's not great odds that you could efficiently zero in on closer and closer simply because it's a little unnatural.  This is why we have created things like like hsla which some people think is easier to reason about 'more saturated' and 'lighter' and a circle of color is potentially a little easier to think about.  But it's not just that one uses RGB either, it's that the color space itself has weird characteristics.</p> 

			<p>This plays in especially if we want to reason about things mathematically - for example - <em>in creating design systems.</em></p>

			<p>Our design systems, ideally, want to reason about colors by 'moving through the color space'.  Doing things like mixing colors, lightening, darkening, can be done well only if they include a sense of how our eyes really <em>work</em> rather than how machines like to think about storing and displaying. That is, if I move this one aspect just a little bit, I expect it to have the same effect no matter what the color I start with is... But in sRGB space, that really isn't true at all.  The sRGB space is not perceptually uniform.  The same mathematical movement has different degrees of perceived effect depending on where you are at in the color space.  If you want to read a designer's experience with this, here's an <a href="https://v6.robweychert.com/blog/2019/12/dynamic-color-javascript-hsl/">interesting example</a> which does a good job struggling to do well.</p>

			<section class="sectioning">
				<h3 class="contextual-heading" style="font-size: NaNrem;">Some examples…</h3>

				<p>This is, of course, very hard to understand if you don't live in this space because we're just not used to it.  It doesn't sound intuitive, or maybe it sounds unnecessarily complex - but it really isn't.  It's kind of simple: the RGB color spaces aren't built for humans to reason about mathmetically, really, that's it.  Here are some examples where it is easy to see in action...</p>

			<p class="codepen" data-height="500" data-theme-id="default" data-default-tab="result" data-user="bkardell" data-slug-hash="NWWZPdL" style="height: 500px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="NWWZPdL">
  <span>See the Pen <a href="https://codepen.io/bkardell/pen/NWWZPdL">
  NWWZPdL</a> by Brian Kardell (<a href="https://codepen.io/bkardell">@bkardell</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async="" src="https://static.codepen.io/assets/embed/ei.js"></script>

			<p>Recently, my friend and co-author of the CSS Colors specification, Adam Argyle also ran a twitter poll asking this question "Which of these is ligher".  Polls are tricky for stuff like this because people "assume" it's a trick question somehow.  Nevertheless, there was overwhelming agreement that #2 was lighter… Because, well, it is.</p>

			<blockquote class="twitter-tweet"><p lang="en" dir="ltr">HSL vs LAB:: lightness 💡<br><br>Same colors from our tricky color poll, but this time I've shown LAB's version of the same color over top. Notice how much closer LAB's lightness value is to the results of our poll! <br><br>🎨 color spaces aren't all the same y'all! <a href="https://t.co/AIEs0amdWY">https://t.co/AIEs0amdWY</a> <a href="https://t.co/xkEguq3KZG">pic.twitter.com/xkEguq3KZG</a></p>— Adam Argyle (@argyleink) <a href="https://twitter.com/argyleink/status/1201908189257555968?ref_src=twsrc%5Etfw">December 3, 2019</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

			<p>There's another great illustration of this in that <a href="https://v6.robweychert.com/blog/2019/12/dynamic-color-javascript-hsl/">earlier article  struggling with this</a>…</p>

			<aside class="captioned-image optional">
				<img src="https://v6.robweychert.com/assets/images/2019-12-15-fig09-luminance-spectrum.svg" alt="">
				<div>The perceived brightness of all of the hues in a spectrum with the same saturation and lightness... It's quite clear they're different.</div>
			</aside>

			
		</section>
		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">This matters a lot...</h3>

			<p>This matters a lot, for example, if you wanted to create a design system which mathematically reasons about color contrast (just like the author of that article).</p>

			<p>There are color spaces like Lab and LCH which deal with the full spectrum and have qualities like perceptual uniformness.  Thus, if we want <a href="https://github.com/w3c/csswg-drafts/issues/3187#issuecomment-499126198">great color functions for use in real design systems</a> everyone seems to agree that having support to do said math in the Lab/LCH color spaces is the ideal enabling feature.  It's not <em>exactly</em> a prerequisite to doing useful things.  In fact, a lot of designers it seems aren't even aware of this quality because we've lived so long with the sRGB space.  However, realistically, we get the most value if we invest in having support for these two color spaces first.  They are also well defined, don't require a lot of debate and are non-controversial.  Having them would make everything else so much the better, because they give us the right tools to help the actual humans.</p>

			<p>Recently, Adam opened <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1026287" rel="nofollow">this issue</a> in Chromium. (<em>Update: Since this post Simon Frasier has also opened <a href="https://bugs.webkit.org/show_bug.cgi?id=205675" rel="nofollow">this issue</a> in WebKit)</em>.</p>
		</section> 
		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">Let's get this done.</h3>

			<p>To recap... We have two CSS color related functions which:</p>

			<ul>
				<li>Are not controversial</li>
				<li>Are quite mature and widely used color standards</li>
				<li>Are important for accesibility</li>
				<li>Are important for design systems</li>
				<li>Make all of the other design system related work much more attractive</li>
				<li>Are actually some of the easiest things we could do in CSS</li>
				<li>Just aren't getting done</li>
			</ul>

			<p>Chances are pretty good, I think, that as a designer or developer reading this, you'll find that last bullet irritating.  You might be asking yourself "<em>But why isn't it getting done?  Wouldn't that help so much?</em>".  The answer is neither as offensive nor complex as you might imagine, it's kind of simple really: Yes, it would - but there's <em>just so much in the pipeline</em> already.  In the end, <em>everyone</em> (including browser vendors) has to prioritize the work in the queue with available resources and skills. There are only so many people with the particular skills to be working on this available, and there are lots of important or interesting things competing for their prioritization.</p>

			<p>I recently wrote <a href="https://bkardell.com/blog/Beyond.html" rel="nofollow">a post about this problem</a> and how Igalia enables us to move things like this.  We have shown that we can get big things done - like CSS Grid.  This is a small thing in terms of effort and cost with an outsized impact. We don't need to wait, ask for the browsers to move this in their priority queues, we just need someone to see the value in funding the work - and it's not huge.  <em>We can get this done.</em></p>

			<p>So, <em>if your organization is interested in design systems, or how you can help move important standards work, this is a great entry point for discussion and I'd love to talk with you.  My Twitter dms are open as well.</em></p><em>
		</em></section><em>
	</em></section><em>
</em>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2019, That's a Wrap.]]></title>
        <id>https://bkardell.com/blog/2019-Wrap.html</id>
        <link href="https://bkardell.com/blog/2019-Wrap.html">
        </link>
        <updated>2019-12-16T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[As 2019 draws to a close and we look toward a new year (a new decade, in fact) Igalians like to take a moment and look back on the year.  As it is my first year at Igalia, I am substantially impressed by the long list of things we accomplished.  I thought it was worth, then, highlighting some of that work and putting it into context: What we did, how, and why I think this work is important the open web platform and to us all…]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">2019, That's a Wrap.</h1>
 
<p class="segue">As 2019 draws to a close and we look toward a new year (a new decade, in fact) Igalians like to take a moment and look back on the year.  As it is my first year at Igalia, I am substantially impressed by the long list of things we accomplished.  I thought it was worth, then, highlighting some of that work and putting it into context: What we did, how, and why I think this work is important the open web platform and to us all…</p>


<section class="sectioning">
	<h2 class="contextual-heading" style="font-size: NaNrem;">All the Browsers…</h2>

	<p>All of the browser projects are open source now and we are active and trusted committers to all of them.  That's important because browser diversity matters and we're able to  jump in and lend a hand wherever necessary.  The rate at which we contribute to any browser can vary from year to year for reasons (many explained in this post), but I'd like to illustrate what that actually <em>looked like</em> in 2019.  Let's look at the commits for 2019…</p>

	<p class="note">Commits are an imperfect kind of measure.  Not all commits are of the same value (in fact, value is hard to qualify here).  It doesn't account for potentially lots and lots of downstream work that went into getting one upstream commit.  Even figuring out how to count them can be tricky.  Looking at them purely as a vague relative scale of "how much did we do", they're one useful illustration.  That's how I'd like to you view these statisics - about our slice of the commit pie, and not anyone elses.</p>

	<section class="sectioning">
		<h3 class="contextual-heading" style="font-size: NaNrem;">Chromium</h3>

		<p>During BlinkOn this year, you might have seen a number of mentions about our contributions to Chromium in 2019: We made the second most commits after Google this year.  </p>

		<figure>
		<img width="300" src="https://pbs.twimg.com/media/EJWhOZeUwAAicpP?format=jpg&amp;name=4096x4096" style="display:block;margin: 1rem auto;">
		<figcaption>Just one of the slides shared from Google’s presentation at blinkon 2019 showing 1782 commits from Igalia at that point in 2019…</figcaption>
		</figure>

		<p>Chromium, if you're not aware, is a <em>very</em> large and busy project with lots of big company contributors, so it's quite exciting to show the level at which we are contributing here. (Speaking of imperfections in this measure - all of our MathML work was done downstream and thus commits toward this very significant project aren't even counted here!)</p>
	</section>
	<section class="sectioning">
		<h3 class="contextual-heading" style="font-size: NaNrem;">Mozilla</h3>

		<p>This year, our contributions to Mozilla projects were  relatively small by comparison.  Nevertheless, 9 Igalians still actively contributed over 160 commits to servo and mozilla-central in 2019 placing us in the top 10 contributors to servo and the top 20 to mozilla-central.</p>

		<figure>
		<img width="300" src="/media/2019-contributions-to-servo.png" style="display:block;width: 100%;">
		<figcaption>A little over 1% of contributions to Servo were by Igalians in 2019 (over 3.4% of non-Mozillan commits).</figcaption>
		</figure>

		<p>As an aside, it's pretty great to see that the #1 committer to mozilla-central this year is our friend Emilio Cobos (by a wide margin, over 2-to-1).  Emilio completed an Igalia Coding Experience in 2017… and gave a great talk at least years Web Engines Hackfest.  Congratulations Emilio!</p>
	</section>
	<section class="sectioning">
		<h3 class="contextual-heading" style="font-size: NaNrem;">WebKit</h3>

		<p>Very importantly: We are also the #2 contributor to WebKit.  In 2019 37 Igalians made over 1100 commits to WebKit this year, delivering ~11% of the total commits.</p>

		<figure>
		<img width="300" src="/media/webkit-contributions-2019.png" style="display:block;width: 100%;">
		<figcaption>Almost 11% of all commits to WebKit in 2019 were from Igalians.</figcaption>
		</figure>

		<p>In fact, if we zoom out and look at what that looks like <em>without</em> Apple, our level of committment is even more evident…</p>

		<figure>
		<img width="300" src="/media/webkit-contributions-2019-sans-apple.png" style="display:block;width: 100%;">
		<figcaption>60% of all non-Apple commits to WebKit in 2019 were from Igalians.</figcaption>
		</figure>

		<p>I think this is important because there's a larger, untold story here which I look forward to talking more about next year.  In short though: While you might think of WebKit as “Apple”, the truth is that there are a number of companies invested and interested in keeping WebKit alive and increasingly competitive, and Igalia is key among them.  Why? Because 3 of the 5 downloads available from webkit.org are actually maintained by Igalia.  These WebKit browsers are used on <em>hundreds of millions of devices</em> already, and that's growing.  Chances are even pretty good that you've encountered one, maybe even have one, and just didn't even know it.  </p>
	</section>
	<section class="sectioning">
		<h3 class="contextual-heading" style="font-size: NaNrem;">A Unique Role…</h3>

		<p>As I explained in my post earlier this year <a href="https://bkardell.com/blog/Beyond.html">Beyond Browser Vendors</a>: Igalia does this work by uniquely expanding the ability to prioritize work and allowing us all to better collectively improve the commons and share the load.</p>

		<p>Bloomberg, as you might know, funded the development of CSS Grid.  In 2019 they continue to fund a lot great efforts in both JavaScript and CSS standardization and implementation. To name just a few in 2019:  In CSS they funded some paint optimizations, development of <code>white-space: break-spaces</code>, <code>line-break: anywhere</code>, <code>overflow-wrap: anywhere</code>, <code>::marker</code> and <code>list-style-type: &lt;string&gt;</code>.  In JavaScript, <code>BigInt</code>, Public and Private Class Fields, Decorators and Records and Tuples.</p>

		<p>But they weren't remotely alone: 2019 saw many diverse clients funding some kind of upstream work for all sorts of reasons.  Google AMP, as another example, funded a lot of great work in our partnership for Predictability efforts.  Several sponsors helped fund work on MathML.  Our work with embedded browsers has helped introduce a number of new paths for contributions as well.  We worked on Internationalization, accessibility, module loading, top-level-await, a proposal for operator overloading and more.</p>

		<p>I'm also very proud of fact that we are an example of what we preach in this respect:<em>  Among those who sponsor our work is… us.</em> Igalia cares about doing things that matter, and while we are great at finding ways to help fund the advancement of work that matters, we're also willing to invest ourselves.</p>
	</section>
 
	<section class="sectioning">
		<h3 class="contextual-heading" style="font-size: NaNrem;">So, what matters?</h3>

		<p>Lots of things matter to Igalia, here are a few broad technical areas that we priortized in 2019…</p>

		<section class="sectioning">
			<h4 class="contextual-heading" style="font-size: NaNrem;">Predictability</h4>

			<p>This year MDN organized a giant survey which turned up a lot of interesting findings about what things caused developers pain, or that they would like to see improved.  Several of these had to do with uneven, inconsistent (buggy) or lacking implementations of standards.</p>

			<p>Thanks to lots of clients, and some of our own  investment, we were able to help here in a big way.  This year we were able to resolve a number of incompatibilities, fix bugs, create a lot of tests, and fix bugs that cause a lot of developer pain.
			<a href="https://blog.amp.dev/2019/12/16/our-2019-contributions-to-web-platform-interoperability/">AMP, notably, has sponsored a lot of these important things in partnership with us</a>, even funding 'last implementations' of important missing features to WebKit like <code>ResizeObserver</code> and preloading for responsive images. </p>

			<p>In 2019, 20 Igalians made 343 commits to Web Platform Tests, adding thousands of new tests and placing us among the top few contributors..</p>

			<figure>
			<img width="300" src="/media/2019-contributions-to-WPT.png" style="display:block;width: 100%;">
			<figcaption>In 2019, Igalia was the #3 contributor to Web Platform Tests, after Google and Mozilla.</figcaption>
			</figure>

			<p>We were also among the top contributors to Test262 as well… Great contributions here from our friends at Bocoup!  We are two very unique companies in this space - contributing to the open web with a different kind of background than most. It's excellent to see how much we're all accomplishing together - just between the two of us, that's approaching 60% of the commits!</p>
			<figure>
			<img width="300" src="/media/2019-contributions-to-test262.png" style="display:block;width: 100%;">
			<figcaption>We're among the top contributors to Test262 as well.</figcaption>
			</figure>
		</section>
		<section class="sectioning">
			<h4 class="contextual-heading" style="font-size: NaNrem;">Acccessibility</h4>

			<p>“Accessibility is very important to us” might sound like a nice thing to say, but at Igalia it's <em>very</em> true.  We are probably accessibility on Linux's greatest champions.  Here's what Igalia brought to the table in 2019:</p>

			<p>As the maintainers of the Orca screen reader for the Gnome desktop we did an enormous amount of work this year with over 460 commits (over 83%) in 2019 to Orca itself.  </p>

			<figure>
			<img width="300" src="/media/2019-contributions-to-orca.png" style="display:block;width: 100%;">
			<figcaption>Over 83% of all commits to Orca in 2019 were from Igalians.</figcaption>
			</figure>

			<p>We were also active contributors for lots of the underlying parts (at-spi2-atk, at-spi2-core).  And, thanks to investment from Google, we were also able to properly implement ATK support in Chromium, making Chrome for Linux now very accessible with a screen reader.  We also actively contributed to Accerciser, a popular Python based interactive accessibility explorer.</p>
		</section>
		<section class="sectioning">
			<h4 class="contextual-heading" style="font-size: NaNrem;">Standards</h4>

			<p>Of course, all of our implentation work is predicated on open <em>standards</em>, and we care deeply about them, and I'm proud of our participation.  Here are a few highlights from 2019:</p>

			<p>Igalia's <a href="https://www.igalia.com/igalian/jdiggs">Joanmarie Diggs</a> is the chair the ARIA Working Group, and co-editor of several of its related specifications.  Igalia had the second most commits to the ARIA specification itself - almost 20% in 2019 behind only Adobe (well done Adobe!). </p>

			<figure>
			<img width="300" src="/media/2019-contributions-to-ARIA.png" style="display:block;width: 100%;">
			<figcaption>Almost 1/5th of contributions to ARIA came from Igalians in 2019.</figcaption>
			</figure>

			<p>We were also the top 3 contributor to the <a href="https://w3c.github.io/html-aam/">HTML Accessibility API Mappings 1.0</a> and actively contributed to <a href="https://w3c.github.io/accname/">Accessible Name and Description Computation</a>.  </p>

			<p>This year, during the CSS Working Group's Face-to-Face meeting at the Mozilla offices in Toronto, our colleage <a href="https://www.igalia.com/igalian/obrufau">Oriol Brufau</a> was unanimously, and quickly appointed as co-editor of the CSS Grid Specification.</p>

			<p>2019 also saw the hiring of Nikolas Zimmerman, <a href="https://twitter.com/briankardell/status/1185278473931231232">bringing the original authors of KSVG</a> (the original SVG implementation) back together at Igalia.  We've nominated Niko to the SVG working group and we we're so excited to share what he's working on (see end of post):</p>


		</section>
		<section class="sectioning">
			<h4 class="contextual-heading" style="font-size: NaNrem;">Math on the Web</h4>

			<p>Enabling authors to share text was an original goal of the Web.  That math was an important aspect of this was evident from the very earliest days at CERN, however, because of a complex history and lacking implementation in Chromium, this remained elusive and without a starting point for productive conversation.  We believe that this matters to society, and resolving and enabling a way to move forward it is the right thing to do.</p>

			<p>With some initial funding from sponsors,  this year we also helped to steadily advance and define an interoperable, modern and rigorous <a href="https://mathml-refresh.github.io/mathml-core">MathML Core</a> specification which is well integrated with the Web Platform to provide a starting point. Igalia's Fred Wang is the co-editor of MathML Core, and we've implemented alongside and completed an initial implementation thanks to lots of hard work from Rob Buis and Fred, and worked to write tests and align high quality interoperability.</p>


			<figure>
			<img width="300" src="/media/mathml-implementations-2019.png" style="display:block;width: 100%;">
			<figcaption>Modern interoperabilty and high quality rendering by July 2019.</figcaption>
			</figure> 

			<p>We filed the <a href="https://groups.google.com/a/chromium.org/forum/m/?utm_medium=email&amp;utm_source=footer#!msg/blink-dev/OOZIrtSPLeM/QsTCnouFDgAJ">Intent to Implement</a> and began the process of upstreaming.  As part of this, we have also created a corresponding <a href="https://github.com/mathml-refresh/mathml-core/blob/master/docs/explainer.md">explainer</a> and filed for a <a href="https://github.com/w3ctag/design-reviews/issues/438">review with the W3C Technical Architecture Group (TAG)</a>.  We've seen positive movement and feedback and several patches have already begun to land upstream toward this long, <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=6606#c84">popular and overdue issue</a>.  Thanks to our work, we will soon be able to say (interoperably), that the Web can handle original use cases <a href="https://www.w3.org/MarkUp/HTMLPlus/htmlplus_45.html">defined at CERN in the early 1990s</a>.</p>
		</section>
		<section class="sectioning">
			<h4 class="contextual-heading" style="font-size: NaNrem;">Outreach and Community</h4>

			<p>Standards are a complex process and we believe that enabling good standardization requires input from a considerably larger audience than is historically able to engage in standards meetings.  Bringing diverse parts of the community together is important.  This has historically been quite a challenge to achieve.  As such, we've been doing a lot in this space.  </p>

			<ul>
			<li><p>Each year we organize an annual Web Engines Hackfest and bring together attendees from all over the world with varying interests around browsers and Web standards come together.  Last October we held this event at our offices in A Coruña Spain.  There were many <a href="https://www.youtube.com/playlist?list=PL4sEzdAGvRgDCN6qACHWs04mQQTWBkdGq">great talks</a> and a lot of great collaboration and discussion.  </p></li>
			<li><p>We began a number of JavaScript outreach groups with different stakeholders.  We meet with each monthly, review and discuss what's happened recently or is brewing new in TC39 and related standards <a href="https://github.com/js-outreach/js-outreach-groups">see </a>.  One of these efforts has also spawned a new effort <a href="https://twitter.com/StandardsIn2Min">Standards in 2 Minutes</a> to allow developers to more easily stay in touch.</p></li>
			<li><p>We joined in partnership on a new effort <a href="https://webwewant.fyi">WebWeWant.fyi</a> which aims to do more direct outreach from standards right to developers, where they are with regard to creating useful feedback into the system.</p></li>
			<li><p>We partnered with colleagues at Bocoup to contribute the research, writing and tooling for the <a href="https://almanac.httparchive.org/en/2019/markup">2019 Web Almanac's chapter on Markup</a>, including for the first time data about non-standard and custom elements with an eye toward answering the question “What new cow paths are being laid down that HTML should consider standardizing”.</p></li>
			<li><p>We began outreach to publishing, design and editorial communities within the W3C and have been connecting discussions with browser vendors on how to move a whole lot of exciting things forward.</p></li>
			<li><p>We gave a lot of talks and participated in a lot of events, here are just a few that there are videos of…</p>

			<ul>
			<li>
			<a href="https://www.youtube.com/watch?v=C1JcKq3NzWU" rel="nofollow noreferrer noopener" target="_blank">Grid Implementation Details</a> by Manuel Rego at CSS Day</li>
			<li><a href="https://www.youtube.com/watch?v=GLi37QPSOv4&amp;list=PLe9psSNJBf74yYiVXDXz8UnRnWf3NHzS-">Standardizing JavaScript Decorators in TC39</a> by Dan Ehrenberg
			</li>
			<li>
			<a href="https://youtu.be/Q8Z1D2i61j8" rel="nofollow noreferrer noopener" target="_blank">MathML in Browsers</a> by Frédéric Wang at Web Engines Hackfest</li>
			<li><a href="https://www.youtube.com/watch?v=ceiUozUFF3Y">Web APIs in Node.js Core: Past, Present, and Future</a> at JSConf EU by Joyee Chung</li>
			<li><a href="https://www.youtube.com/watch?v=Rc2TpO7WXYc&amp;t=486s">JavaScript Class Features: A case study in TC39</a> by Dan Ehrenberg</li>
			<li>
			<a href="https://youtu.be/Rc2TpO7WXYc rel=" nofollow="" noreferrer="" noopener"="" target="_blank">Improving Website Performance with CSS Containment</a> by Manuel Rego at CSSconf EU</li>
			<li><a href="https://www.youtube.com/watch?v=gS3wLIoQAAY&amp;feature=youtu.be" noreferrer="" noopener="" target="_blank">The Battle of the Event Loops</a> by Ujjwal Sharma at HolyJS</li>
			<!--li>
			<a href="https://slides.com/briankardell/60-21-22-23#/" rel="nofollow noreferrer noopener" target="_blank">The Web Commons:Past, Present and Future</a> by <em>brian</em>. Abstractions II</li -->
			<li>
			<a href="https://www.youtube.com/watch?v=AqzztIpGCD8" rel="nofollow noreferrer noopener" target="_blank">Implementing Accessibility for the Web Platform</a> by Martin Robinson at Web Engines Hackfest</li>
			<li><a href="https://www.youtube.com/watch?v=olSQai4EUD8">This.Javascript: State of Browsers panel, representing WebKit</a>, several TC39 panels like <a href="https://www.youtube.com/watch?v=m8KfqLPgi_w">this one from JSConf EU</a>, some podcasts, like <a href="https://www.youtube.com/watch?v=weVNrflT-vU">Talkscript</a> and started doing some <a href="https://www.youtube.com/watch?v=dw6QDmH7Sgs">interviews of our own.</a></li>
			</ul>

			</li><li>
				<p>We wrote a lot of blog posts  too, here are a few I chose to highlight here that I thought were particularly interesting:</p>
				<ul>
					

			<li>
			<a href="https://blogs.igalia.com/mrego/2019/06/19/speaking-at-css-day-2019/" rel="nofollow noreferrer noopener" target="_blank">Speaking at CSS Day 2019</a> (a post about what it takes to implement and ship a new feature) by Manuel Rego</li>

			<li>
			<a href="https://bkardell.com/blog/OnePlatform.html" rel="nofollow noreferrer noopener" target="_blank">One Platform</a> (a post about resolving historical co-evolutionary oddities in the platform so we can more forward) by <em>Brian Kardell</em>
			</li>


			<li>
			<a href="https://blogs.igalia.com/jfernandez/2019/06/10/a-new-terminal-style-line-breaking-with-css-text/" rel="nofollow noreferrer noopener" target="_blank">A terminal-style line breaking with CSS Text</a> by javif</li>


			<li>
			<a href="https://blogs.igalia.com/mrego/2019/01/11/an-introduction-to-css-containment/" rel="nofollow noreferrer noopener" target="_blank">An introduction to CSS Containment</a> by rego</li>

			<li>
			<a href="https://bkardell.com/blog/Beyond.html" rel="nofollow noreferrer noopener" target="_blank">Beyond Browser Vendors</a> (a post the not-often discussed reasons why we get the features that we do, and the changing landscape that enabled new ideas) by <em>Brian Kardell</em>
			</li>

			<!-- li>
			<a href="https://docs.google.com/document/d/1DpwvJsDhMc32UGxxKVo1hGlaYLGwPWIVi37o8nt-pH0" rel="nofollow noreferrer noopener" target="_blank">Google AMP (a review)</a> by cathie, fred and rob</li -->

				</ul>
			</li>

			</ul>
			
		</section>
	</section>
	<section class="sectioning">
		<h3 class="contextual-heading" style="font-size: NaNrem;">2020…</h3>
		<p>So, I think we did some amazing and important things in 2019.  But, as amazing as it was: <em>Just wait until you see what we do 2020</em>. </p>

		<p>In fact, we're excited about so many things, we couldn't even wait to give you a taste...</p>


		<blockquote class="twitter-tweet"><p lang="en" dir="ltr">I just published an article about my first large project <a href="https://twitter.com/igalia?ref_src=twsrc%5Etfw">@igalia</a> on my blog: enabling CSS 3D transformations in <a href="https://twitter.com/webkit?ref_src=twsrc%5Etfw">@webkit</a> SVG. I am looking forward to your comments - checkout <a href="https://t.co/SMWXnY5Iwv">https://t.co/SMWXnY5Iwv</a>.<br><br>I am excited :-)</p>— Nikolas Zimmermann (@NikolasZimmerm1) <a href="https://twitter.com/NikolasZimmerm1/status/1205136265835888640?ref_src=twsrc%5Etfw">December 12, 2019</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
	</section>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES Private Class Features: 2 Minute Standards]]></title>
        <id>https://bkardell.com/blog/PrivateFieldsIn2Min.html</id>
        <link href="https://bkardell.com/blog/PrivateFieldsIn2Min.html">
        </link>
        <updated>2019-10-24T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[A number of proposals come together to provide 'private' versions of most of the class-related concepts from ES6. Let's have a #StandardsIn2Min oriented look...
  ]]></summary>
        <content type="html"><![CDATA[
  <h1 class="contextual-heading" style="font-size: NaNrem;">ES Private Class Features: 2 Minute Standards</h1>
  <p class="segue">A number of proposals come together to provide 'private' versions of most of the class-related concepts from ES6. Let's have a <a href="2MinuteStandards.html">#StandardsIn2Min</a> oriented look...
  </p>

  <script src="../prism.js"></script>
  <link rel="stylesheet" href="../prism.css">

  <p>The new private class features (fields and methods, both instance and static) all use a new <code>#</code> to talk about private-ness.  These offer compile time guarantees that only the code in this class, or instances of this class can access these things.  In defining and using a private property, for example, you could write:</p>
  <pre><code class="language-javascript">class Point {
  #x = 0
  #y = 0
  
  constructor(x=0, y=0) {
    this.#x = x
    this.#y = y
  }
  
  toString() {
    return `[${this.#x}, ${this.#y}]`
  }
}

let p = new Point(1,2)
</code></pre>

  <p>The result is that you can now create a <code>Point</code> object which encapsulates its actual maintenance to these variables.  These private properties are not accessible from the outside, as we'll see.</p>

  <section class="sectioning">
    <h2 class="contextual-heading" style="font-size: NaNrem;">The <code>#</code> sigil and 'private space'</h2>
    
    <p>The very new and perhaps most important bit to understand is that the name of private things must begin with the <code>#</code> <em>sigil</em>, and its use is symmetrical.  That is - in order to declare a class property as private, its name must begin with a <code>#</code>.  To access it again later, you'll use the name beginning with <code>#</code> again, as in <code>this.#x</code>.  Attempts to access it from the outside will throw.</p>

    <pre><code class="language-javascript">// x isn't #x it will log undefined..
console.log(p.x)

// #x used from an instance outside throws.
console.log(p.#x)
  
&gt; Uncaught SyntaxError: Undefined private field undefined: must be declared in an enclosing class</code></pre>

    <p>What's subtle but important about this is that the symmetrical use of the sigil lets it be known unambiguously to both compilers and readers whether we intended to access or set something in public space, or private space.  This also means that while you can choose the same readable characters, <em>you can't actually wind up with properties with the same names in both spaces</em>: The private ones will always include the <code>#</code></p>

    <p>This makes a lot of sense because, for example, the names that you choose for public fields should not be dictated by the internal, <em>private</em> fields of your super class.  The following then is entirely possible and valid:</p>

    <pre><code class="language-javascript">class X {
  name = 'Brian'
  #name = 'NotBrian
  
  constructor() {
    console.log(this.name) // Brian
    console.log(this.#name) // notBrian
  }
}

let x = new X()

console.log(x.name) // Brian
// (attempting to access x.#name throws)</code></pre>

    <p>Since the name simply begins with the sigil, it's  tempting to think that you can access private fields dynamically, for example, via <code>[]</code> notation.
    However, you can't.  You also cannot access private fields of a Proxy target through the Proxy, they aren't accessible through property descriptors or <code>Object.keys</code> or anything like that.  This is by design as doing so, would be self-defeating, making things available outside the class as well (as you can read about <a href="https://github.com/tc39/proposal-class-fields/blob/master/PRIVATE_SYNTAX_FAQ.md#why-doesnt-thisx-access-the-private-field-named-x-given-that-thisx-does">in the FAQ</a>).</p>
  </section>
  <section class="sectioning">
    <h2 class="contextual-heading" style="font-size: NaNrem;">Why the #, specifically?</h2>
    <p>Why this particular character was chosen was very widely discussed, and lots of options were weighed.  You can read more about this in the <a href="https://github.com/tc39/proposal-class-fields/blob/master/PRIVATE_SYNTAX_FAQ.md#why-was-the-sigil--chosen-among-all-the-unicode-code-points">FAQ</a> as well, but the simplest answer is: That's the one, single character option, which we could make work without fouling up something else.</p>

    <section class="sectioning">
      <h3 class="contextual-heading" style="font-size: NaNrem;">All the private things</h3>

      <p>Once you understand the above, the rest flows pretty naturally.  We get private methods that are pretty self explanitory:</p>

      <pre><code class="language-javascript">class Counter extends HTMLElement {
  #x = 0
   
  render() { this.innerHTML = this.#x; }  
 
  #handleClicked() {
    ++this.#x;
    this.render();
  }

  constructor() {
    super();
    this.render();
  }

  connectedCallback() {  
    this.addEventListener('click', this.#handleClicked);
  }

}

customElements.define('x-counter', Counter);</code></pre>
    <p>and private static fields too...</p>
    <pre><code class="language-javascript">class Colors {
  static #red = "#ff0000";
  static #green = "#00ff00";
  static #blue = "#0000ff";
}</code></pre>
  </section>
  <section class="sectioning">
    <h3 class="contextual-heading" style="font-size: NaNrem;">Learn More</h3>
    <p>This is, of course, merely an 2 minute introduction. To learn a lot more details about this, including it's history, rationale about design choices, find links to the spec draft, and much more, check out the <a href="https://github.com/tc39/proposal-class-fields">TC39 class fields proposal repository</a>.</p> 
  </section>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Beyond Browser Vendors]]></title>
        <id>https://bkardell.com/blog/Beyond.html</id>
        <link href="https://bkardell.com/blog/Beyond.html">
        </link>
        <updated>2019-09-16T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[I'd like to explain what I think is potentially the most exciting set of changes that have taken place in the latter stages of the Web's history: Why we are now collectively considerably more in control of our own destinies and have moved "beyond browser vendors".]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Beyond Browser Vendors</h1>
	<p class="segue">I'd like to explain what I think is potentially the most exciting set of changes that have taken place in the latter stages of the Web's history: Why we are now collectively considerably more in control of our own destinies and have moved "beyond browser vendors".</p>
	<p> 
		For most of the history of the Web, browser vendors have played an exceptionally critical role in standardization. This isn't a secret, in fact, it's widely discussed. What is less widely discussed is why that is. Frequently, most of our discussions give this very political origins, or assume it is about power struggles. But in fact, much of it has been for pretty considerably less intriguing reasons: It was a sort of predictable, natural outflow of the reality that we had created.
	</p>
	<p>
		The first popular web browser (Mosiac) was proprietary. For a good chunk of our history, either all or most of the deployed browsers were built upon proprietary stuff, managed entirely by a single company.
	</p>
	<p>
		This matters a lot because it meant that, practically speaking, everyone who is not a browser, including the myriad of organizations that participate in standards efforts are, effectively asking a small number of companies to invest money and manage priorities and budgets very particularly.
	</p>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Mundane Realities</h2>
		<p>What's very, very difficult to appreciate from the outside is just how much is impacted, historically, by the fairly boring and entirely mundane fact above and that browser vendors aren't actually that special.</p>

		<p>That is, they ultimately operate very much like most other organizations: They have a budget, carved out of some larger company. That company has some larger goals.</p>

		<p>Their organization has an org chart with managers, teams, and projects, and QAs. They hire staff with specialized skills (these can be quite specialized). They have tasks and processes and annual reviews, and goals, and so on.</p>

		<p>Code and approaches are adapted, they look for ways to improve performance, extend ideas, make things more modular, and so on.</p>

		<p>Each quarter, then, managers have to decide how to maximize the budget in a way that includes an intersection of things in the pipeline (or that they might be interested in introducing), which best align with larger organizational goals,for which they have free resources with the right skills to do that work this quarter.
		</p>

	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">The Under Discussed, Big Impacts</h2>
		<p>If you can imagine a conveyor belt of ideas that ultimately land as tasks to be implemented, you can understand some of the problem. Even given the exact same inputs, different people can make pretty different, but entirely reasonable and defensible choices. And the inputs aren't remotely the same. Perhaps it takes one vendor twice as long to implement because this feature is much harder in their architecture, or they simply have less resources, or perhaps they're in the middle of reworking their layout, or... There are myriad reasons why these things get prioritized and worked differently.</p>

		<p>If you were to consider nothing else at all, you can see why things get gummed up. There is an absolute gauntlet that something has to run in order to become a standard, even when there isn't particular controversy.</p>

		<p>Practically speaking, this leads to misses. It leads to things backing up. The more backed up things get, the less likely a browser vendor is to entertain new ideas and spend a lot of time discussing things that doesn't directly align with their existing investments and priorities.</p>

		<p>Things that come from another vendor, on the other hand, are more likely to place more direct pressure on them to respond.</p>

		<p>Worse still, this creates kind of a feedback loop that ultimately winds up with a reality that yields near total <em>practical</em> domination of Web standards by browser vendors for reasons that aren't really especially political ones.  These outcomes are not because of controvery, nor even particularly intentional.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">A different story...</h2>
		<p>"But we do manage to get things done, even big things, rather quickly, when we really want to, right?" Is a refrain I've heard a lot. What about CSS Grid, for example? Grid seemed to drop everywhere at pretty much the same time, in 2017. It seemed like it happened very quickly to many of us, and I've heard this comment a number of times. If this isn't and illustration of vendors aligning on big ideas, prioritizing things, and getting things done fast when they want to, I don't know what is... Right? Here's the interesting part: <em>It isn't that at all.</em>

		</p><p>And what it is <em>is far more interesting and exciting.</em></p>
 

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">The backstory of CSS Grid</h3>
			<p>In 1996, Bert Bos, Dave Raggett, and Håkon Lie were the authors of a proposal called "<a href="https://www.w3.org/TR/WD-layout.html" rel="nofollow">Frame-Based Layout</a>" which attempted to tackle the idea of a grid-oriented layout controlled by CSS.  That completely failed to get uptake and implementations.</p>
			<p>At the end of 2005, Bert Bos put some of these ideas forward again in <a href="https://www.w3.org/TR/2005/WD-css3-layout-20051215/" rel="nofollow">CSS Advanced Layout</a>.  This kind of then became <a href="https://www.w3.org/TR/2009/WD-css3-layout-20090402/" rel="nofollow">CSS Template Layout</a> in 2009.  Not one browser shipped any of this.  It was important to the print industry though, so they invested and made their own renderers for print.</p>
			<p>Fast foward to 2011, Microsoft reframes this work as <a href="https://www.w3.org/TR/2011/WD-css3-grid-layout-20110407/" rel="nofollow">Grid Layout</a> and pretty much just documented what they shipped in IE10.  But then, that's it.  It sat there, in no small part because it had some real problems, having been mostly developed by Microsoft for specific use cases.</p>

			<p>But then something changed, what?  Well, a lot of things, but very importantly, the model of it all.</p>

		</section>
	</section>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Open</h2>

		<p>Something happened along the way in our history:  Both the standards process, and the the Web Platform itself got increasingly open.</p>

		<p>In fact, today <em>all</em> of the implementations are open, and that's a big part of how we moved grid.</p>

		<p>Most of the work on CSS Grid in both WebKit and Chromium (Blink) was done, not by Google or Apple, but by teams at Igalia.</p>
 
		<p>Think about that for a minute:  The prioritization of its work was determined in 2 browsers not by a vendor, but by an investment from Bloomberg who had the foresight to fund this largely uncontroversial work.</p>

		<p>This isn't a unique story, it's just a really important and highly visible one that's fun to hold up.   In fact, just in the last 6 months engineers as Igalia have worked on CSS Containment, ResizeObserver, BigInt, private fields and methods, responsive image preloading, CSS Text Level 3, bringing MathML to Chromium, normalizing SVG and MathML DOMs and a lot more.
		</p>

		<p>Igalia <em>loves</em> open, and open standards - it's what we <em>do</em>.  We participate in TC39, W3C, WHATWG and Khronos.  We work on V8, JavaScriptCore, SpiderMonkey. Our teams work on Chromium, Gecko/Servo, WebKit.  We work very 
		closely <em>with</em> browser vendors.  Openness can really change the economics involved and remove 
		some previously difficult hurdles. This allows 
		us all (including browsers vendors) to address more 
		of those things than we could before.</p>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">The possibilities</h3>
			<p>This is the really exciting reason that I came to work at Igalia:  Igalia potentially entirely shifts the standards paradigm.  All this stuff still has a lot of costs to manage along the way.  Browsers still play a hugely important role in reviews, managing questions of maintenance and so on - but, finally, we can begin to imagine a world in where we can more <em>collectively</em> prioritize and cooperate.</p> 

			<p>Imagine the possibilities of all of the things we could get done <em>together</em>.  Lots and lots of stuff is just <em>stuck</em>- and many of the causes for this are ultimately because of things that are more organizational than because something is particularly controversial.  We can help break the cycle and give those uncontroversial things implementation priority.</p>

			<p>All we have to do is decide a thing is important enough, and there are lots of ways to do that.  We're already doing a lot and I think we've just begun to scratch the surface of what is possible.</p>

			<p>Imagine, for example, a world in which organizations or groups very interested in moving a set of topics simply came together and helped collectively prioritize and fund the efforts of those things, for example.  We could get things <strong>done</strong>.  Things that have lingered.  Honestly, the possibilities seem endless:  From discrete proposals that are critically important to a small group to broad ideas like color systems that touch everything from design to accessibility... Or, good print support from the same rendering engines? New core capabilities to help make things more extensible that are just moving too slow?</p>

			<p>Our possible future is very exciting, and more than ever in our collective hands to determine!  If you're interested in learning more, or have questions, you can <a href="https://www.igalia.com/contact/">contact Igalia</a>, or come and find me at TPAC if you happen to be here.</p>

		</section>


	</section>




]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Top Level Await: 2 Minute Standards]]></title>
        <id>https://bkardell.com/blog/TopLevelAwaitIn2m.html</id>
        <link href="https://bkardell.com/blog/TopLevelAwaitIn2m.html">
        </link>
        <updated>2019-08-20T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[My first post in a new effort #StandardsIn2Min to provide short, but useful information about developing standards.]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Top Level Await: 2 Minute Standards</h1>
	<p class="segue">My first post in a new effort <a href="2MinuteStandards.html">#StandardsIn2Min</a> to provide short, but useful information about developing standards.</p>
    <script src="../prism.js"></script>
    <link rel="stylesheet" href="../prism.css">
	<p> 
		Previously, in order to use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await#Examples" rel="nofollow"><code>await</code></a>, code needed to be inside a function marked as <code>async</code>.  This meant you couldn't use await at the 'top-level' (outside of any function notation).  At first, this might seem like a minor annoyance. Just put the code you want to await into an <code>async function() {....}()</code> and call it, right?
	</p>
	<p>
		Yes, and (mostly) no.  While being able to use <code>await</code> at the top-level is generally useful - the real <em>value</em> in it (the problem that it solves) has a lot to do with modules.
	</p>
	<p>
		Modules are already asynchronous, and have a declarative <code>import</code> and <code>export</code>, and those also expressed at the top-level.  The practical implication of this was that if you wanted provide a module which relied on some asynchronus task in order to be useful - for example, connecting to a database - you had really no good options.  You might make every method in your own API internally dependent on that promise.  But, this is extra complicated.  All of your methods need to return promises, whether that makes sense, or not.  If errors do occur, they are late, and in the wrong place.  Or, you could make your API <code>export</code> that promise somehow.  "Somehow" because there are several models for how you can choose to do this.  Worse, whichever promise exporting model you chose, users of your module are left with <em>precisely the same problem</em>, creating a kind of domino effect.</p>

		<p><em>That's</em> what the new <a href="https://github.com/tc39/proposal-top-level-await">top-level <code>await</code></a> proposal (stage 3 as of the time of this writing) really solves.  With it, you can write something like this.</p>

<pre><code class="language-javascript">// products.js 
import { fictionalDb } from './fictionaldb.js' 
import { config } from './db-config.js'
 
// connect() is promise returning
let connection = await fictionalDb.connect(config)

export default {
	recent: function () {   
	   // use the connection to return recent products
	}
	
	discontinued: function () {
	   // use the connection to return discontinued products	
	}
}</code></pre>

	<p>It seems incredibly small - one word on line 6.  However, the magic and value really comes in how this module can now be used: You <em>just <code>import</code> it</em> like any other module.</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">If you're curious about how it <em>works</em></h2>

	<p>The real magic here is largely in the definition of a standard <em>protocol</em> that imports and exports can reason about internally.  To explain: You can think about modules as <em>really</em> including both their actual <em>expressed</em> exports, and, a new implicit internal promise used by the module system's internal protocol.  While you're expressing your dependencies without that, the module system will (roughly) expand this internally as an implicit <code>Promise.all</code> around anything waiting for export.</p>

	<p>For example, given the code:</p>
	<pre><code class="language-javascript">import { a } from './a.mjs';
import { b } from './b.js';
import { c } from './c.js';

console.log(a, b, c)</code></pre>
	<p>The module system, internally, sees (again, roughly) this:</p>
	<pre><code class="language-javascript">import { _internalPromise as aPromise, a } from './a.js';
import { _internalPromise as bPromise, b } from './b.js';
import { _internalPromise as cPromise, c } from './c.js';

// the module system creates this promise 
// and uses it to know your module is ready.
export const _internalPromise = 
	Promise.all([aPromise, bPromise, cPromise])
		.then(() =&gt; {
   			console.log(a, b, c);
		});</code></pre>
	<p>The net result is that modules are fetched in parallel and executed in order until the first await, and then waits until they are all complete before resolving the module itself.</p>
	</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2 Minute Standards]]></title>
        <id>https://bkardell.com/blog/2MinuteStandards.html</id>
        <link href="https://bkardell.com/blog/2MinuteStandards.html">
        </link>
        <updated>2019-08-20T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[A short explanation of a new effort]]></summary>
        <content type="html"><![CDATA[
    <h1 class="contextual-heading" style="font-size: NaNrem;">2 Minute Standards</h1>
    <p class="segue">A short explanation of a new effort</p>

    <p>For a while now, we've been running some 'outreach groups'.  Originally started informally by my colleague at <a href="https://igalia.com" rel="nofollow">Igalia, </a><a href="https://twitter.com/littledan" rel="nofollow">Dan Ehrenberg</a>, it's become a set of monthly meetings with various groups of stakeholders in <a href="https://tc39.github.io" rel="nofollow">TC39</a> and the Web at large which I really look forward to.  The <a href="https://github.com/js-outreach/js-outreach-groups" rel="nofollow">groups</a> are meetings of people who work on Tooling, people who work on Frameworks and Libraries and Educators, with folks who work on standards.  The goals of all of them, at the end of the day, is to figure out how we all work better, together.</p>
    
    <p>The Educators Group has talked a bit about a number of efforts, but there's one conversation we've been having that I think is pretty interesting. I dont know of any developer who isn't interested in what is going on in standards, but the economics of this is currently kind of hard. We're interested in a whole bunch of other things too. There's lots of good content - too much in fact, coming at us from a million directions and it's all competing for our time and attention. We have jobs, and families, and pets, hobbies and lives. I love a lot of long form things, I'm excited when I see them in my stream, but they pile up and I have to choose. I only have so many slots of time where I can actually afford to consume 10, 15, 30 or 40 minutes worth of information. It can feel a little overwhelming sometimes.</p>

    <p>So, we're going to try something new: 2 Minute Standards.  Think of it as "standards news, in brief".  The basic idea is pretty simple: Like a news segment, it's got to contain pertinent facts, more than a tweet - but it's air time is limited, as the name would suggest, to 2 Minutes.  That can come in a number of forms: An article that is 500 words or less, a two minute video, or a short web comic/zine.  The idea though is to ultimately give developers some channel with reasonable economics for staying 'generally informed'.  In the end, that's frequently what we want anyways: We can't know everything, we just need to know <em>enough</em> to know what it is, why it is, and that it is there when we're ready to learn more.  We'd like to be able to roughly understand it if it comes up. A maximum of 2 minutes per day, and almost certainly not even that much, seems... unintimidating and managable.</p>

    <p>So, that's the idea.  We're still discussing many of the details about how to make this really 'click' in a bigger way: How to create as a sort of channel you can follow?  For now, it seems better to start with something simple and perhaps to begin to get feedback on the idea.  To this end, we'll post things with the hashtag #StandardsIn2Min, and others can too. If you see something fly by with the hashtag you can always find it again later on the twitter feed and, hopefully, expect that it will take no more than 2 minutes to consume.  However, we will also manage the Twitter account <a href="https://twitter.com/StandardsIn2Min" rel="nofollow">@StandardsIn2Min</a>, where we'll work to curate those hashtags too and create a manageable (honestly, probably slow) pace that never asks for more than two minutes of your attention in a day to keep up. Let us know what you think about the idea!</p>
    

    <p class="thanks-to">Thanks to the <a href="https://github.com/js-outreach/js-outreach-groups" rel="nofollow">educators group</a> for all of their help discussing and creating, and especially to <a href="https://twitter.com/laurieontech" rel="nofollow">Laurie Barth</a> and <a href="https://twitter.com/jorydotcom" rel="nofollow">Jory Burson</a> for helping get this post put together quickly!
    </p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[One Platform™]]></title>
        <id>https://bkardell.com/blog/OnePlatform.html</id>
        <link href="https://bkardell.com/blog/OnePlatform.html">
        </link>
        <updated>2019-07-09T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[Let's talk about making SVG and MathML less special.]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">One Platform™</h1>
	<p class="segue">Let's talk about making SVG and MathML <em>less special</em>.</p>

<p>As I mentioned in  <a href="https://bkardell.com/blog/Math.html" rel="nofollow">Harold Crick and the Web Platform</a>, the HTML specification contains a section on "Other Embedded Content" which specifically mentions SVG and MathML.  In that piece I explained their unique histories - how they wound up being "special" and how I felt this leaves them in a kind of unique place in the platform that deserves some similarly "special" attention in order to resolve.</p>

<p>What I mean by this, <em>in part</em>, is that we need to think about how to make them <em>less</em> special, so that we are reasoning about things as One Platform™ as evenly as possible.  I'd like to illustrate and talk about two simple examples:</p>

<section class="sectioning">
	<h2 class="contextual-heading" style="font-size: NaNrem;">What is this element?</h2>
	<p>The HTML parser parses these things specially.  While this is a kind of advantage we don't expect to be repeated, it actually came at a cost of historically <em>disadvantaging</em> the actual elements that we had to work with.  They lacked basic/general interfaces that are otherwise common among any other element in HTML. There's really no great reason for this and we should unweird it - it's not hard.  Last year, this work began by providing a mixin that could be used in <a href="https://github.com/whatwg/html/pull/3543#issuecomment-375579673">SVG</a>, and we'd like to <a href="https://mathml-refresh.github.io/mathml-core/#dom-and-javascript" rel="nofollow">do the same for MathML</a> which lacked any kind of IDL at all.</p>
	<p>What does this mean in practice?  Well, it means that if you grab a reference to a MathML element, for example, and try to set it's <code>.style</code> property - what happens?  It blows up.  Why?  Because if you ask it what is it's <code>.constructor</code>, the answer is just <code>Element</code>.  But you can style it with CSS just fine.  Common things like <code>data-*</code> attribute and tab indexes just don't work, trying to access any of over 100 common API properties or methods that Just Work anywhere else will throw, or not function.  All of this is unnecessarily weird, for not great reasons.</p>
	<p>This is a <em>really basic thing</em> and it's not at all hard to do technically.  It seems unlikely that the parser will change, and everyone agrees that MathML is a reasonable thing to send to a browser (whether they believe that it is necessary that the browser itself renders that or not), so I am not sure why this should be controversial.  This is a useful normalization of basic, low level platform things. It feels like <em>everyone</em> should support this.</p>
	<p>Generally, let's make them both as <em>unspecial</em> as possible - which leads to the other thing...</p>
	</section>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">How do we move forward?</h2>
	<p><em>HTML</em> has had, and continues to have, a whole lot of thought and efforts to define "how to move forward". Figuring out the underpinnings of both the platform features necessary and a process enables the Web to really work and flourish is a big effort.  A wide range of efforts over the last several years like Custom Elements, Shadow DOM, Houdini, AOM, modules (and types of modules), ways to share stylesheets, Import Maps and built-in modules are all, in some ways proposing elements of possible solutions to the basic question "How do we move forward?"  A lot of this takes a long time and advancing frequently requires compromises in the interim.</p>
	<p>Recently, new conversations have begun attempting to assemble these into a larger possible vision and discuss resolving compromises made along to really answer this question.</p>
	<p>However, currently, SVG and MathML, exist at least partially outside many of those years of conversations and thought.  It feels important to at least stop and consider the question: How do these move forward?  And, if that doesn't look like the rest of the platform -- why not?  Figuring out how to align with HTMLs "forward plans" seems very valuable.</p>
	<p>I don't have concrete answers here, but I'd like to start making these things part of the conversation.  For example...</p>
	<section class="sectioning">
		<h3 class="contextual-heading" style="font-size: NaNrem;">Polyfilling Elements, Custom Elements and Built-ins</h3>

		<p>One of the more interesting recent conversations recently is around <a href="https://github.com/whatwg/html/issues/4696">moving forward and polyfilling elements</a>.   It is, of course, very early.  This issue and related efforts are intended to <em>open</em> conversation by offering some larger picture that we can talk about.  One interesting conversation, I think, would be to think about how this <em>might</em> relate to SVG and MathML.  The topics of Custom Elements and Shadow DOM, for example, are two that are thus far historically outside of SVG and MathML.</p>
		<p>One way of looking at it in the thread offers that we <em>might</em> say that HTML itself is <em>largely</em> (not completely) 'done'.  Not standards, just the core of HTML itself.  It offers that what you could do then is import other support, and that support could <em>also</em> potentially be shipped down natively by the browser or polyfilled.</p>
		<p>But, how does this apply to SVG and MathML? Is there real use in asking these questions?  We think so.</p>

		<p>While we're not entirely sure where larger conversations about how HTML will move forward will go, as part of <a href="https://mathml.igalia.com" rel="nofollow">our efforts to implement MathML Core in Chromium</a> (the engine Chrome, Edge, Samsung, Brave, UC Browser and lots of apps share), we are asking lots of questions about how things <em>fit</em> into the platform more naturally.  In this, we've recently done some interesting experimenting with some of these concepts in order to ask potentially useful questions.  We believe these are both interesting 'at large', and actually very useful in helpng us make sure we're thinking about all of the right and necessary things.</p>
		<p>If you're interested, you can read more on <a href="/blog/MathForward.html">some experiments (with implementation) and discussions around them regarding Shadow DOM, Import Maps and potentially prefix-less custom elements for MathML</a> and how we feel this is both compelling and helpful.</p>
		<p>While the MathML Community Group is aware that these questions are far from settled, they were universally excited to see such talks begin in HTML and <em>very</em> interested in making sure that they're thinking about those things too: Being a part of that conversation, and sorting out how we can move forward together as One Platform™, with less 'specialness'.</p>
		<p>If you think this is interesting or useful, please share your support and let someone know.</p>
		</section></section>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Moving Math Forward, Thoughts and Experiments]]></title>
        <id>https://bkardell.com/blog/MathForward.html</id>
        <link href="https://bkardell.com/blog/MathForward.html">
        </link>
        <updated>2019-07-09T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[
		In this piece, I explain details on thoughts on experiments and conversations around moving Math forward on the Web.
	]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Moving Math Forward, Thoughts and Experiments</h1>
	<p class="segue">
		In this piece, I explain details on thoughts on experiments and conversations around moving Math forward on the Web.
	</p>
		
	<p>For some context, <a href="https://mathml.igalia.com" rel="nofollow">my team is actively working on implementing MathML in Chromium</a> (the engine Chrome, Edge, Samsung, Brave, UC Browser and lots of other share), more specifically MathML Core.  MathML has long had implementations in Safari and Firefox and has an 
	intersting history that leaves it in a very unique spot.
	</p>
	<p>MathML Core, defines the comparatively small, but well defined and mostly interoperable subset of MathML - with an aim of resolving uniqueness.  It provides details about how it actually <em>fits</em> into the layers platform in well defined ways and to explain their existing magic in terms of the platform - to expose it if is it new.  As such, in indirectly aims to provide a basis for moving <em>many</em> things forward.</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">A thought experiment</h2>
	<p>Recently conversations in the web platform at large have begun about <a href="https://github.com/whatwg/html/issues/4696">moving HTML forward and polyfilling elements</a>.   Since we are actively working on a 'core' ourselves, we thought this would be an interesting discussion and experiment:  We asked "What if MathML Core was largely 'done' and you would import other support to move forward?"  Those things <em>could</em> potentially be shipped by a browser, but there's no guarantee they ever would.  However, they could also be loaded as polyfills and in standard means that help omit many of the problems that traditional polyfills create.</p>
	<p>To explain this, we took some elements that <em>aren't</em> in MathML Core, but are specified elsewhere, as an interesting stand in.  One such example is an element called <code>mfenced</code>.  <code>mfenced</code> is just a "more convenient way" of writing some math that has a lot of 'fences' (parens, pipes, braces, and so on).  The original spec even said "It is strictly equivalent to this expanded, longer form".</p>
	<p>Today, 'polyfills' exist for it if your browser doesn't support it, and today, those work by (if your browser doesn't support it) destroying your tree and replacing it with the equivalent version, at some undefined point in time.</p>
	<p>We experimentally changed very little in our implementation and it now considers any MathML 'unknown element' as on the whitelist of elements which can have a Shadow DOM.  We used a simple stand-in using Mutation Observer to allow any of those to be defined without a dash, and wrote a polyfill for <code>mfenced</code> which simply expands it into Shadow DOM.</p>
	<p>For purposes of discussion, we illustrated how we could, in theory, use MathML Core, import some new vocabulary (potentially a future proposal, or just some slang) and easily expand it into some Shadow DOM, leaving you with the tree that you authored and all of the things just fitting together nicely and predictably. Below is a screenshot from our actual implementation experiment.</p>
	<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/8e0c8bf38ccd6fa1a20a3d3fa2299a7e32291d32/68747470733a2f2f63646e2e676c697463682e636f6d2f39303035373538332d326137392d343662372d623565662d36636566336265383764613625324653637265656e73686f7425323066726f6d253230323031392d30372d303725323031322d35322d35302e706e673f763d31353632353138353030313933"><img src="https://camo.githubusercontent.com/8e0c8bf38ccd6fa1a20a3d3fa2299a7e32291d32/68747470733a2f2f63646e2e676c697463682e636f6d2f39303035373538332d326137392d343662372d623565662d36636566336265383764613625324653637265656e73686f7425323066726f6d253230323031392d30372d303725323031322d35322d35302e706e673f763d31353632353138353030313933" alt="screenshot of element and shadow dom in experimental browser build" data-canonical-src="https://cdn.glitch.com/90057583-2a79-46b7-b5ef-6cef3be87da6%2FScreenshot%20from%202019-07-07%2012-52-50.png?v=1562518500193" style="max-width:100%;"></a></p>
	<p>We think that these sorts of experiments are useful and informative and help us ask better questions about how we are fitting into the platform itself: Have we answered the necessary questions?  How does the introduction of a ShadowRoot impact rendering and namespacing, for example?  Could developers really 'plug in' to all the necessary bits?  Could they properly layer atop?  To test this, we also created elements that expand shorthands like TeX and ASCII Math.  In the end, can we ultimately resolve a great a stable core that allows us to move math forward using these things similar in ways similar to Knuth's TeX book/engine - but in a way that is properly "of the platform"?  We think the answer is yes.</p>

	<p>While we're not entirely sure where larger conversations about how HTML will move forward will go, and we aren't claiming that this implementation is anything more than a quick experiment for discussion and testing, the MathML community itself is very excited that such talks are even happening in HTML and <em>very</em> interested in being a part of that conversation, and sorting out how we can move forward together as One Platform™, with less 'specialness'.</p>
	</section>
	
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Interesting Custom Element Data Begins]]></title>
        <id>https://bkardell.com/blog/Fun-With-Custom-Element-Data.html</id>
        <link href="https://bkardell.com/blog/Fun-With-Custom-Element-Data.html">
        </link>
        <updated>2019-03-07T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[ 
        A while back I wrote a piece asking how we begin to think about using data to move forward with standardization, and called for ways to help get data. One thing I did was request a new query from the HTTPArchive including data on “dasherized elements”. Keep in mind that the
  while the top 1.2 million sites or so in this dataset a lot of data, it is still a small sampling and has its own biases. It reports mostly on a particular ‘kind’ of site which is not representative of the giant bottom of the iceberg that lives beneath
  the surface, inside of corporate intranets, behind logins and paywalls and so on. Ultimately, we need more - but you have to start somewhere.
    ]]></summary>
        <content type="html"><![CDATA[
    <h1 class="contextual-heading" style="font-size: NaNrem;">Interesting Custom Element Data Begins</h1>
    <p class="segue"> 
        A while back I <a href="https://bkardell.com/blog/Crisis.html">wrote a piece asking</a> how we begin to think about using data to move forward with standardization, and called for ways to help get data. One thing I did was request a new query from the HTTPArchive including data on “dasherized elements”. Keep in mind that the
  while the top 1.2 million sites or so in this dataset a lot of data, it is still a small sampling and has its own biases. It reports mostly on a particular ‘kind’ of site which is not representative of the giant bottom of the iceberg that lives beneath
  the surface, inside of corporate intranets, behind logins and paywalls and so on. Ultimately, we need more - but you have to start somewhere.
    </p>
    <p>Yesterday, Simon Pieters answered with <a href="https://twitter.com/zcorpan/status/1103444943853498368">this tweet</a> linking to an HTTPArchive post and yielding <a href="https://gist.github.com/zcorpan/56d1040e1afaa883b610c342c2e7a437">this dataset</a>  which is amazing.</p>
    <p>It’s still a little hard to track because we can’t tell whether that is one page that includes an element a bunch of times, or many pages that include them, but this is an awesome start!</p>
    <p>It’s a little hard to view that dataset and, while the attributes are awesome in also helping us know more about what that element is, but it also means some noise and that the counts are slightly confused, so I took that, ran it through some processing
      and created a few other views (linked where appropriate below)…</p>
    <p>Here’s some preliminary, interesting observations:</p>
    <p>Even from this small sample, the HTTPArchive query that reports on use of HTML elements searches for only 140 known specific elements that are in a standard, but this report shows over 24k <em>different</em> "dasherized tags that appear in the top
      1.2 million pages. Wow! What this tells me is that there are a <em>lot</em> of dasherized tags in use.</p>
    <p>It important to note that that doesn’t mean these are “custom elements” proper, but it also doesn’t really matter: What we care about really, is what you were trying to say there, semantically.</p>
    <p>Of these, there are 3,227 different unique prefixes. These may or may not indicate common authors, but they might at least be a helpful way to look for popular ‘sets’ of elements. For example, it’s unsuprising to see the <code>amp-</code> prefix in there
      given all of the boosts that it gets, and it’s nice to see them all linked in and counted there. I’ve organized <a href="https://gist.github.com/bkardell/efdebc65fc096e25916a8874ee0a4c33">a json output that looks like this</a></p>  
    <p>To break them down into some further semi-arbitrary groups for summary:</p>
    <ul>
      <li>~7.8k of these occur between 1 and 100 times.</li>
      <li>31 of these occur between 101-200 times</li>
      <li>14 occur between 200-500 times</li>
      <li>4 occur between 500-1000 times</li>
      <li>4 occur &gt; 500 times</li>
    </ul> 
    <p>One personal note: I’m kind of sad to see that the most popular one is <code>amp-auto-ads</code> occuring a whopping 3718 times and it’s not remotely the only thing that would appear to be about ads. In fact, <code>amp-ad</code> also occurs 395 times and there are many
      other non-amp elements that appear to be ad related. But... I guess the web has a lot of ads. Who knew.</p>
    <p>More importantly, it’s interesting to look at this file from the bottom up (or the grouped one) though and think about whether we can identify the possible sources of these, or ‘tag’ them according to common purposes somehow. I’d like to think about how we could get this into a format thatIf
      you feel like you’re potentially interested in digging in and helping think about this, identifying where some of those come from, what their purpose is, etc, getting that data into a a place where we can do that kind of stuff better – whatever, feel
      free to leave comments on any of these gists or cc me (<a href="https://twitter.com/briankardell">@briankardell</a>) on twitter.</p>
    
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Intuition Bikeshed and Standards Challenges]]></title>
        <id>https://bkardell.com/blog/StringyCSS.html</id>
        <link href="https://bkardell.com/blog/StringyCSS.html">
        </link>
        <updated>2019-03-01T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[One thing that's been on my mind quite a lot for the last few years is how we can better communicate both in and out of standards bodies. This past week some things happened which I think make for an interesting review and some thought about whether we did the right things, and how we can do better.  
	]]></summary>
        <content type="html"><![CDATA[ 
	<h1 class="contextual-heading" style="font-size: NaNrem;">Intuition Bikeshed and Standards Challenges</h1>
	<p class="segue">One thing that's been on my mind quite a lot for the last few years is how we can better communicate both in and out of standards bodies. This past week some things happened which I think make for an interesting review and some thought about whether we did the right things, and how we can do better.  
	</p>
	<script src="../prism.js"></script>
    <link rel="stylesheet" href="../prism.css">
   
	

	<p>
		This week, the CSS Working Group tweeted an informal Twitter poll that looked like this (below) - if you haven't voted or replied to it yet, I would ask that you read this before you do:
	</p>

	<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Poll about naming a new CSS function that coerces/concatenates strings:<br><br>.bar-graph {<br> --size: 50%;<br> height: var(--size);<br> content: NAME(var(--size));<br>}<br>.icon {<br> --icon-id: 23;<br> background: url(NAME("/assets/icon-", var(--icon-id), ".svg"));<br>}<br><br>NAME = ?</p>— 💖Taudry Hepburn💖 (@tabatkins) <a href="https://twitter.com/tabatkins/status/1100838423248551936?ref_src=twsrc%5Etfw">February 27, 2019</a></blockquote>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

	<p> 
		It includes two examples attempting to show a couple of hypothetical uses of a new function in CSS that coerces/concatenates strings and asks what authors what they expect it would be called, offering the following choices in the poll:
	</p>

	<ul>
		<li><code>text()</code></li>
		<li><code>concat()</code></li>
		<li><code>to-string()</code></li>
		<li><code>Other (respond in thread)</code></li>
	</ul>

	<p>
		A not insignificant number of folks, some friends and standards people themselves were kind of appalled that <code>string()</code> wasn't in the list.  I mean... Of course it should be <code>string()</code>, right?  Hurriedly, some of us tried to provide some context but I feel like it really deserves some more words and it has me thinking more about how we can do better (and what that would even mean). 
	</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Backstory</h2>
		<p>
			CSS doesn’t (currently) really "do" string concatenation "generally".  However, it now has constructs like CSS Custom Properties which seem to make this sort of thing very desirable. Based on some feedback and discussions <a href="https://github.com/w3c/csswg-drafts/issues/542">an issue was opened in late 2016 by Lea Verou</a> to consider how to make that work. 
		</p>

		<p class="note">
			Note: Yes, it is now 2019 and while this seems to many of us like a really long time for such a small, basic thing, in standards time, that is nothing.  The CSS Working Group has hundreds of issues of all shapes and sizes and doesn’t get to actually prioritize anyone’s actual time (some priorities are set by the company that employs you, and some of us do this in our "spare" time), and... sometimes there are non-immediately obvious complexities.  More on all that later.
		</p> 
		<p>
			 In it, she points out that <code>content:</code> currently does a fairly simple form of concatination.  If you are unfamilliar with this, allow me to use Lea's Prism to illustrate it with an example from MDN below:
		</p>

		<pre><code class="language-css">a::after {
  content: " (" attr(id) ")";
}
</code></pre>		

		<p>
			Great.  She suggests that perhaps for a few other "stringy" properties, we should just do that - just make it able to smash those things together into one string.  That would be "best" for authors - less "Lispy" and easier to read (the <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp family of languages</a> are somewhat famous for its use of lots of parenthesis and how it is read)
		</p>
		<p> 
			But... authors want this ability in a lot of contexts where it isn't so simple or obvious.  Having a general thing which gets authors more power, in more places, sooner, also seems good for authors.  So, let's start there - powers first, maybe sugar later.
		</p>

		<p>
			Without going any further, I'd like to point out that this is a decision - a weighing of values of outcomes.  It means that if/when these powers ship, they will be kinda "Lispy".  Some authors, lacking the context as to why might that decision was made, might just think that this was a bad decision.  Even <em>with</em> that context, some authors would disagree with the choice.
		</p>

		<p>
			Anywho.. Discussions progressed about which use cases and constraints there were around a way to say “smash these two things together” as strings and one of the early names proposed for this was “string()”.
		</p>

		<p>  
			Sure, makes sense to me. Don't all programmers know string?  Seems pretty universal.  What else would it be even?  <em>Obviously</em> it should be string.
		</p>
		<p>
			Well, here too, it seems that context matters a lot, in more ways than one.
		</p>

		<p>
			It turns out that another spec <a href="https://www.w3.org/TR/css-gcpm-3/#using-named-strings">CSS Generated Content for Paged Media Module (GCPM)</a> has already defined a function called <code>string()</code> and does... not this.
		</p>

		<p>
			Still, a lot of us (yes, me too) are sort of like "Yo wait... what?  what's that spec?  No browser seems to implement it -maybe we could just change that?  Surely this is a better use of string()?  Seems last updated in 2014, and if no one has implemented it, it's probably dead.  This is like... clearly a string, it feels bad that we can't use string for dumb reasons.""
		</p>

		<p>
			Yes, all of that is mostly true, and... these things are also true:
		</p>

		<p>
			The ideas and work of GCPM, like a lot in CSS, have a long  history.  Bert Bos (one of the creators of CSS) made the <a href="https://lists.w3.org/Archives/Public/www-style/2006Jun/0042.html">announcement on the mailing list</a> of its first working draft with that title in 2006.  In it, he said:

		</p><blockquote>It describes features typically only used when printing: running headers 
and footers, footnotes, references to page numbers, floats to the top 
and bottom of a page, etc.

Indeed, we may define explicitly that these features *don't* work in 
interactive media. (Although I already heard people ask for footnotes 
to work interactively as well, possibly as a light-weight form of 
hyperlink, opening a pop-up.)
		</blockquote>


		<p>
			In fact, in many ways the ideas of both markup documents and stylesheets originated with print, not screens and a lot of people continued to see that potential of stylesheets to be important way beyond Web browsers.  The editor of that spec was Håkon Wium Lie, the other creator of CSS.
		</p>

		<p>
			So, part of that is to point out that in the context of framing this, they wanted this concept of, well, kind of named strings and then a way to refer to and use those strings.  Strings, strings, strings, and so, well, <code>string()</code> seemed like a perfectly rational name.  I mean... Obviously it is a string.
		</p>

		<p>
			Then, as you might expect, people from those industries began implementing non-browser implementations.  Several supported string, some "forever" by the time this 2014 spec was published.
		</p>

		<p>
			But, Brian... This is all stuff doesn't work in <em>browsers</em>. It's for <em>print</em> and it seems almost like Bert was suggesting it might be kinda good to split them?  Let's just split them because this is <em>obviously</em> a string!
		</p>

		<p>
			Maybe... but there is also this:
		</p>

		<p>
			In between the birth of CSS and now, we've also increasingly popularized this "not print really" but also "not currently web browsers" uncanny valley that are things like PDFs or EBooks.
		</p>
		<p>
			These have to work on various... er... screens. With different sizes and orientations and now can even be interactive.  You know, kind of like a web browser.
		</p>
		<p>
			At the same time, Web browsers have evolved too: 
			Ideas like Web Packaging address, in a more general way, ideas in publishing around, for example, distributing an ebook.  Ideas like ServiceWorkers make it possible to now take that offline. You know, kind of like an ebook.
		</p>

		<p>  
			And so on.
		</p>
		<p>
			And so, as much as possible, to common ends, we are all try to work together within the W3C, and especially in CSS.
		</p>

		<p>  
			CSS has never (to the best of my knowledge) overloaded an existing function with a radically different signature/meaning depending on the media.  To do so would certainly mean just agreeing that we would never adopt this, which, meh, I don't know?  In any case, for at least <em>some</em> authors who have to deal with both it might be really confusing... None of that seems "great" if it is all easily avoided.
		</p>
		<p>
			Except, dammit, I am going to be honest: this really feels like a <code>string()</code> to me.  How can it not be?  That is definitely the best one.
		</p>
	</section>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Resolving and Bikesheds</h2>
		<p>
			And so, all that back story set: There were discussions on this in the face to face meaning.  In this context, it seemed we had pretty general agreement on the use cases and how it would work, but we didn't have a name.
		</p>
		<p>
			However, there were a few ‘finalist’ suggestions and cogent arguments about why some other names were actually <em>better</em> than <code>string()</code>.  Hmm... maybe?
		</p>
		<p>
		 	In the end, weighing all of the things, I think that we just decided it was probably best to just take <code>string()</code> off the table if there was something else that could work -- and people were even making compelling arguments that not only would they work - they were actually <em>better</em>.  Meh. I dunno. 
		</p>

		<p>
			It seemed that the really serious contenders were “concat()” and “text()” and at some point I think people were just trying to move on and it seemed to be settling around <code>text()</code>.  The chair asked “Any objections to <code>text()</code>?” 
		</p>

		<p>
			I squirmed. 
		</p>

		<p> 
			There I really don't want to be "keep the dumb bikeshed going guy" (if you are not familliar with the term, here's <a href="https://en.wikipedia.org/wiki/Law_of_triviality#Argument">an explanation of bikeshedding</a>).  I was at this point entirely willing to accept "not <code>string()</code>" but I just found text actually confusing and thought that most of the same problems of "looks good in this light... as well as many others" might apply here... But, you know... maybe that's just me?  Should I say something?
		</p>

		<p>
			So I finally chimed in and offered simply “I don’t have a better suggestion, but text() is not very clear to me… There are so many ways that I could interpret “text” in the context of CSS” and "sorry".  
		</p>

		<p>
			It wasn’t a formal objection, I just wanted to see if maybe others felt the similarly.  And, well... some did.  And... some didn't.
		</p>
		<p>
			 Everyone, including me, seemed pretty sure that other people would surely find a thing either more intuitive, or actively unintuitive and we didn't agree on what those were.
		</p>

		<p> 
			This is a hard problem, because I think we all sometimes think that other people will surely see it 'like us'.  It's very hard to do otherwise.  But, people are diverse. CSS is used by people from many backgrounds, with many perspectives, different primary languages, cultures and so on and, really, it's just very hard to know.
		</p>

		<p>
			There was some more discussion.  There were a few other suggestions made (some minuted, some not, some serious, some not).  One idea that seemed to be perhaps popular was something vaguely “like string, but not exactly string”.  Any of these felt kind of more intuitive to me - but again, that's <em>just</em> me.  I could imagine even that perhaps "more different" was actually potentially less confusing to potential future developers?  I don’t know, honestly.
		</p>
		<p>
		  	But, deep down, I just kind of secretly wish it could be <code>string()</code> because that's the one I just know everyone would get.  Dammit.
		</p>

		<p>
			All this said, I would like to put this in some actual perspective:  No one was remotely cross about any of this.  It was not a heated argument.  Everyone was perfectly aimiable and all of the rationales were, I believe, entirely 'teachable'.  I believe that all parties agreed that we would celebrate getting this power interoperably implemented regardless of which one it wound up being.  
		</p>
		<p>
			Unfortunately this meant that all we could agree to regarding the name was that we couldn't decide today.  Yeah, idk, maybe that's on me.  I'm honestly not sure how I feel about it.
		</p>
		<p>
			Regardless, because there were good points and different perspectives all around, and because developers have even broader perspectives than the folks in that room - we thought that perhaps <em>asking</em> developers for input would help us clarify our thoughts, so Tab put together a poll.
		</p>
	</section>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Optimization Problem Problems</h2>
		<p>
			The thing is, the most interesting thing in this poll to me is just how many actual users of CSS thought <code>concat()</code> was actually the best one, even without all of this context, and how few chose all of the others.
		</p>
		<p>  
			Realistically, text() is the only 100% clear, readable, requires no context alternative in that poll and yet, as it currently stands, a mere 1 in 5 people chose it. 
		</p>
		<p>
			Unfortunately <code>to-string()</code> was just one of several possible 'almost strings' and several people who chose other also said something string or string-like -- but... even still - it's not that many actually.  My manual efforts to tally them up as well as I can still seem to indicate that <code>concat()</code> has still way more support than all of the others combined.
		</p>

		<p>
			It honestly wouldn't have been my guess going into all this.   But... really, the more I look at it... maybe that <em>is</em> better, even without all the context.  That is exactly what this function does. 
		</p> 

		<p>
			Anyways.. I think that it is impossible to optimize something like “intuitiveness” without actual input from developers themselves and the really tough thing here is that there is that at best it is still merely optimization.  There is no clearly defined 'perfect' that will make everyone happy, especially without context or being heard.
		</p>

		<p>
			As I have argued before, I also believe that we really haven’t figured out how to do that well yet.
		</p>
		
		<p>
			In order to give good input, any of us require <em>at least</em> a good framing of context. That's hard because, often there is a lot and it's hard to know what matters and what doesn't.  The higher the "tax" of participating, the less likely it is that we will even get a good sampling of average users. Our time is just pulled in too many directions.  It takes 2 seconds to read the poll and vote, many minutes to read this post.
		</p>

		<p>
			Further, to give really quality feedback and input, probably you need the ability to ask some questions or something.  But, even then: even if you sink in time and ask questions, the truth is, it is impossibly difficult to really weigh vapor.</p>

		<p>That is, until we really sit down to use things, get some actual experience with it, try to apply it, stretch it, pull it, live with it a while and so on… it’s just… really hard to say.  This is part of why I have advocated for the Extensible Web and Houdini work, and, why I argue that it is important to:</p>
		<ul>
			<li><a href="https://extensiblewebmanifesto.org">Be able to fail, adapt and remix ideas along the way</a></li>
			<li><a href="https://medium.com/@briankardell/web-standards-we-want-part-i-chapters-ca71985bf914">Improve the economics</a> of this feedback loop and participation for developers so that there is more immediate value in their participation</li>
			<li><a href="https://bkardell.com/blog/Crisis.html">Figure out how to incorporate all of this into the standards process in a really healthy way.</a></li>
		</ul>

		<p>I feel like we’re making progress on all of these fronts, but I think we still have a very long way to go.  Things like Custom Functions, for example, might go a long way toward answering future questions of similar ilk.  It might be very plausible to get value quickly and have it compete and fail and adapt and grow and, maybe settle in in some ground we haven't quite defined yet that is "not part of CSS proper" but "widely used in publishing".  I don't know.
		</p>
		<p>
		I am very happy to say (and will probably write about) the fact that Houdini had some really good discussion in these meetings and, actually, I'm very pleasantly suprised by who I heard arguing what. 
		</p>

		<p>So... that's where we are, how we got there and some of the problems... How can we manage all of this better? Is there more we could do?</p>
	</section>
	<p class="thanksTo">Thanks to my friends Amelia Bellamy-Royds and Jon Neal for their talks and helpful comments in reviewing some iteration of this piece.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Harold Crick and the Web Platform]]></title>
        <id>https://bkardell.com/blog/Math.html</id>
        <link href="https://bkardell.com/blog/Math.html">
        </link>
        <updated>2019-01-09T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[
		In this piece I'll talk about MathML and why I think that it is especially unique, intersting, and stranger than fiction - as well as what we can/should do with it.  (note: Stranger than Fiction is a movie about a very competant and number-obsessed  accountant named Harold Crick who suddenly begins to hear his life being narrated, and learns that a seemingly innocuous event one Wednesday will ultimately change his life and lead to his demise, and what happens next).
	]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Harold Crick and the Web Platform</h1>
	<script src="../prism.js"></script>
    <link rel="stylesheet" href="../prism.css">
	
	<p class="segue">
		In this piece I'll talk about MathML and why I think that it is especially unique, intersting, and stranger than fiction - as well as what we can/should do with it.  (note: <a href="https://www.imdb.com/title/tt0420223/">Stranger than Fiction</a> is a movie about a very competant and number-obsessed  accountant named Harold Crick who suddenly begins to hear his life being narrated, and learns that a seemingly innocuous event one Wednesday will ultimately change his life and lead to his demise, and what happens next).
	</p>

	<blockquote>
		<em>Narrator:</em>  This is the story of <strike>Harold Crick</strike> MathML... 
	</blockquote>

	<p>
		When Tim Berners-Lee created HTML, he drew the original elements from the corpus of SGML documents on hand at CERN. Tim picked the most <em>common</em> ones that he found as the original set.  They are, effectively, semantics about text itself - and even in that, not necessarily especially good ones.
	</p>
	<p>
		Given this, it is perhaps not surprising that almost immediately after its creation, discussions began arguing about what <em>other</em> tags should become part of HTML.
	</p>
	<p> 
		Since the Web was originally pitched as an idea about sharing information among researchers, particularly at CERN, it is probably also not surprising that two gaps that came up very quickly were "graphics" and "math":  Researchers frequently need both.
	</p>

	<p>
		Within a very short window of time, Dave Ragget had assemebled a number of ideas for what he called "HTML+" which took (believe it or not) only a fraction of those ideas and <em>would have created roughly five times as many elements as Tim's original browser supported.</em>
	</p>

	<p>
		Notably among those, <a href="https://www.w3.org/MarkUp/HTMLPlus/htmlplus_45.html">Section 12 of HTML+  included a <code tag-esc="">math</code> element</a> and they had experimental browser support at CERN.
	</p>

	<div class="captioned-image">
		<img src="https://www.w3.org/MarkUp/htmlplus_paper/math2.gif" alt="">
		A screenshot of the experimental browser at CERN rendering the proposed <code tag-esc="">math</code> element in 1993.
	</div>
	<p>
		That proposal wasn't accepted.  But it wasn't the end of the conversation, or the need, either.
	</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">For many years</h2>

		<p>
		  And so, for many years, two communities continued to work on these problems outside of HTML itself: In the case of graphics this would become SVG, and in the case of formulae, MathML.  
		</p> 

		<blockquote>Narrator: <strike>Harold Crick was a man</strike> MathML was a markup of infinite numbers, endless calculations, and remarkably few words. </blockquote>

		<p>   
			Little by little, bit by bit, they made progress.  By the time the WHATWG/HTML5 era rolled along, there was some degree of maturity and the new standard would come to include at least some degree of answer for both of these asks by reference to the work that these communities did.  HTML's section on <a href="https://html.spec.whatwg.org/multipage/embedded-content-other.html">Other Embedded Content</a> mentions only two - these two, specifically.
		</p>

		<p>
			If you are unfamilliar with MathML, it looks something like this.
		</p>
		 <pre><code class="language-html">&lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"&gt;
  &lt;mi&gt;x&lt;/mi&gt; &lt;mo&gt;=&lt;/mo&gt;
  &lt;mrow&gt;
    &lt;mfrac&gt;
      &lt;mrow&gt;
        &lt;mo&gt;−&lt;/mo&gt;
        &lt;mi&gt;b&lt;/mi&gt;
        &lt;mo&gt;±&lt;/mo&gt;
        &lt;msqrt&gt;
          &lt;msup&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;
          &lt;mo&gt;−&lt;/mo&gt;
          &lt;mn&gt;4&lt;/mn&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;
        &lt;/msqrt&gt;
      &lt;/mrow&gt;
      &lt;mrow&gt; &lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;a&lt;/mi&gt; &lt;/mrow&gt;
    &lt;/mfrac&gt;
  &lt;/mrow&gt;
&lt;/math&gt;</code></pre>

		<p>Like HTML itself, its semantics are fairly weak - but also like HTML itself, it turns out that you can do quite a lot with that.  Given the markup above, your browser would render something like this:</p> 

		<figure class="captioned-image" style="margin-top:0">
			<img src="/media/math-out.png" alt="">
			<figcaption>Screenshot showing MathML visual rendering output</figcaption>
		</figure>

		<p>And so, it looked like we had an answer for this, at last.</p> 

		<blockquote>Narrator: That was, of course, before Wednesday.<br>
		(pause.)<br>
		On Wednesday, <strike>Harold's wristwatch</strike> Chrome changed everything.</blockquote>

		<p>
			Work continued and Firefox shipped some kind of MathML support as early as 2006 and, for a time just about every browser had <em>someone</em> either working on implmentations or already shipped.  IE was sort of the last major holdout.
		</p>

		<blockquote>Narrator: If one had asked Harold, he would have said that this Wednesday was exactly like all the Wednesdays prior.  And he began it the same way he--</blockquote>

		<p>
			By 2013, all in all, things were looking pretty good for the MathML community.  
		</p>


		<blockquote>Harold: Hello?... Hello? Is someone there?</blockquote>

		<p>
			Then, there was something of a shakeup in terms of browser engines: That February, Opera retired Presto and joined Google and Safari as "WebKit" browsers. Some worried about the loss of diversity in browser enginers.  Then, a few months later, Google announced that it would fork WebKit and create "Blink" and, very quickly, Opera announced it would use Blink too.
		</p>

		<blockquote>Narrator: Little did he know that this simple, seemingly innocuous act would result in his imminent death.<br>
 
		Harold Crick: What? What? Hey! HELLOOO! What? Why? Why MY death? HELLO? Excuse me? WHEN?</blockquote>
		

	</section>

			
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Little did he know</h2>		
		<p>
			In the process of forking, the Blink teams intent was to do a lot of refactoring and really focus on performance.  Along the way, they reviewed code and found that the newly landed contribution of MathML had a lot of complexity.  They found that it had several issues, including a security flaw.  It had no long-term owner on the team and would make refactoring a lot harder, so, they debated what to do with it.</p>


		<blockquote>Professor Hilbert: I've written papers on "Little did he know." I've taught classes on "Little did he know." I once gave an entire seminar based upon "Little did he know." Sonofabitch, Harold... "Little did he know." That means there's something he doesn't know, which means there's something you don't know... Did you know that?</blockquote>

		<p>
			 On Wednesday, October 30, 2013, Google announced their decision: They would remove support for it in Blink, for now at least, and instead recommend use of a polyfill of sorts called MathJax.  
		</p>
			
		<p>
			I think that it would be a mistake to read too much into this.  I don't think that Google was as much unified in a desire to kill <strike>Harold Crick</strike> MathML as they were in having to make a move and thinking that perhaps that was a reasonable choice at the time.   
		</p>

		<p>
			 Judgements about the quality of that choice aside,this meant that by 2013 estimates, the  projected native support of MathML was suddenly around <em>a billion users less than it had been just a day before.</em> 
		</p>

		<blockquote>
			Karen Eiffel: I went out... to buy cigarettes and I figured out how to kill Harold Crick.
		</blockquote>


<!--
		<div class="captioned-image">
			<img src="/media/fixed-it.gif" alt="">
		</div>
-->
		<p>
			This has had some pretty complex effects on the status of MathML: It is left as one of a very small group of things in the platform which are in a very strange place in history. This situation has even been the <a href="https://github.com/w3ctag/design-reviews/issues/313">topic of some discussion in the W3C Technical Architecture Group (TAG) recently</a> (and elsewhere).  Like Harold Crick, we're unsure quite which kind of story they are in.
		</p>  


		<blockquote>
		Professor Hilbert: ..The only way to find out what story you're in is to determine what stories you're not in. Odd as it may seem, I've just ruled out half of Greek literature, seven fairy tales, ten Chinese fables, and determined conclusively that you are not King Hamlet, Scout Finch, Miss Marple, Frankenstein's monster, or a golem. Hmm? Aren't you relieved to know you're not a golem?
		</blockquote>


	</section>


	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Aren't you relieved to know you're not a golem?</h2>
		<p>
			Along the way we began trying to collectively find new ways to think about how we go about evolving the whole <em>platform</em> in healtier ways than the past and explaining how we deal with where we are, and how we move forward - but this has actually not been great for MathML.
		</p>
		<p>
			While we generally accept the starting point of existing standards, because of the above, MathML doesn't fit neatly into this camp in the minds of some. 
		</p>

		<p>
			While we say that the potential path to standardization of <em>new</em> elements lies in experimentation and proving need and use via Custom Elements, MathML predates custom elements by a long time.
		</p>
		<p>
			Where does this leave MathML?  Asking that  community to be relieved that we now have custom elements seems a bit like asking them to be relieved that they aren't a golem.  
		</p>

		<blockquote>Harold: You have to understand that this isn't a philosophy or a literary theory or a story to me. It's my life.</blockquote>

		<p>
			So, now what?
		</p>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">Earned Credits</h3>
			<p>
				As I explained earlier, because of where it fit in history, I think MathML is an exceptional case.  I would argue that we should 'credit' MathML as if they'd used Custom Elements all along and just shortcut that whole aspect of the conversation.  But, then what?
			</p>

			<p>
				Thinking through this is part of what led me to write <a href="https://bkardell.com/blog/Crisis.html">Standards Crisis on Earth-1</a> and propose a thought excersize about experimentation and data and ask "then what"?  Because, in this light, I have to wonder what kind of message we are sending with how we choose to deal with it.
			</p>
		

		<p>Imagine another universe in which a community works for 30 years.  They experiment.  After a while, they come up with a solution.  It's imperfect, like all solutions, but they manage to build a base.  It is included in <a href="https://www.iso.org/standard/58439.html">ISO/IEC</a>, HTML, <a href="http://idpf.org/epub/30">ebook</a> and <a href="http://www.oasis-open.org/committees/download.php/12572/OpenDocument-v1.0-os.pdf">office</a> formats. They build an ecosystem around it.  They even manage to get major native implementations.  Despite lack of native support from two major vendors, or even a super clear way to go from 'here' to 'there', their base manages to expand to millions of documents.  
		</p>  
		
		<p>That is an <em>exceptionally</em> high bar, which I think we cannot expect of another community again, probably ever.  But imagine it did, because it's pretty close to reality here... Then what?  How do we standardize it, or why don't we?  Why?
		</p>
		
		<blockquote>
		Professor Hilbert: Harold, if you want to stay alive, you have to try something else.
		Harold: What?
		Professor Hilbert: Nothing.
		</blockquote>
	
	</section>



	<section class="sectioning">
		<h3 class="contextual-heading" style="font-size: NaNrem;">I Can't Kill Harold Crick</h3>
		<p>
			But, it's not just a general feeling of "we have a duty to any community who did that much to give them some answers" that is bothering me. It's  pressed further by who these groups are.  The groups who have invested in and continue to need MathML have names like the "<em>National Science Foundation</em>".  They serve altruitistic purposes like Higher Education and cancer research.  They aren't just important - they are literally among the very group of folks that the Web proposed to help from the very beginning.
			</p>
			<p>
				Given this, it feels almost fundamental to the spirit of the Web — and good for us all — that we make some extra effort to help close an important gap after nearly three decades.
			</p>
	</section>
	<section class="sectioning">
		<h3 class="contextual-heading" style="font-size: NaNrem;">Solutions</h3>
		<p>
			As for myself, I believe that any suggestion of 'starting over' here is problematic.  It's not that there might not be 'better', but we need a starting point and to not largely accept the one that has this much success and investment already seems really bad.  I believe we have to find a "standard way" to ship MathML in some way that is better than the situation today. The polyfills are better than nothing, but they introduce many new challenges from performance to accessibility which are unfortunate and non-trivial.
		</p>
		<p><em>Enter Igalia</em></p>
		<p> 
			I believe that the best hope is through current work being done by Igalia.
			If you aren't familliar with them, <a href="https://www.igalia.com/">Igalia</a> is  very interesting and unique.  Most organizations involved in standards fit neatly into are either "are a browser vendor", or "doesn't write browser implementations".  The latter are sometimes at something of a disadvantage for reasons more practical, and less political, than we often imagine them to be.  Each vendor already has their own priorities, budgets, challenges and so on.  But Igalia provides a bridge between these two worlds.  They don't make a browser themselves, but they do contribute code and work to browser codebases, and have developed and maintain good relationships and trust at both ends.
		</p>
		<p>
			When blink identified concerns with the implementation at the time of forking from webkit, Igalia worked with Apple to help right the situation and MathML continues to ship in Safari to this day.   
		</p>
		<p> 
			Current efforts to find a path in blink are being funded by communities who really need MathML and current proposals involve using some new underlying primitives (some through Houdini) to help not only get MathML implmented in blink, but also to do so in a way that introduces no or minimal "new magic", but rather is well explained by common foundations. This seems as good an outcome as I can imagine and I really hope that it succeeds.
		</p>
		<p>
			If you think think this is a valuable and worthwhile effort, be sure to speak up.  If you work for someone who might think that this is important, tell them about it.  <a href="https://mathml.igalia.com/">We can help fund these efforts too</a>. 
		</p>
	</section>

	<p class="thanksTo">Special thanks to many friends, Bruce Lawson, Michiel Bijil, Alice Boxhall, Daniel Ehrenberg and Lajja Shah for thoughtful discussions and insight on the topic along the way, or proofreading one of many developing evolutions of drafts of this piece.  Their name listed here is not intended as an endorsement of my thoughts, merely to express that I am ever greatful for their friendship and willingness to discuss these topics with me.</p>
</section>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[I Heart Glitch]]></title>
        <id>https://bkardell.com/blog/Glitch.html</id>
        <link href="https://bkardell.com/blog/Glitch.html">
        </link>
        <updated>2019-01-02T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[
		Today marks exactly one month since I started playing with Glitch, and I'd like to tell you about why I love it and can't stop playing with it.
	]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">I Heart Glitch</h1>
	<p class="segue">
		Today marks exactly one month since I started playing with Glitch, and I'd like to tell you about why I love it and can't stop playing with it.
	</p>

	<p>I want to say up front that this piece about <a href="https://bkardell.com/blog/The-Glory-Days-Of-The-Web.html" rel="nofollow">pining for glory days that I don't actally remember existing</a> when all you needed to know was HTML and CSS.  If that was all you needed then, it's all you need now too.  The truth though is that even in the early days of the Web, it often wasn't: We wanted to do things  with the Web that would have made hand-authoring pages an untenable solution.  In fact, the first real, practical use of HTML at CERN by Sir Tim-Berners Lee and team generated that HTML by way of C and database services.  Perhaps there has been a decrease in the number of sites that could even be realistically hand authored without more than that because of increased expectations or something, but by and large, it seems to me that complexity in delievering a website isn't so much "new" as it is "shifted".</p>

	<p>Along the way there were a ton of complex things, and each was rooted in whole different languages:  Java frameworks and .NET frameworks and PHP and so on.  Because of that, each of those had their own build systems (sometimes a few), application servers, package managers and so on.  So, the idea that we could do these things in the same language (JavaScript) and protocols seems like actually a really good thing to me.</p>

	<p>So... This isn't just "Things sure have gotten complicated.  Remember when they were simpler?  Pepperidge Farm Remembers."  What it is about may, at times, read a little like that, but the point I am trying to make is subtler - it is about how we <em>manage</em> that, and how it makes us feel.</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Time for play</h2>

		<p>I don't really know how to describe the period from about 1994-1998 other than to say that it kind of felt like play.  Occasionally frustrating and confusing play to be sure, but each challenge was semi-contained and full of exicting little rewards that drove you on.  It was like climbing a series of hills to find inceasingly beautiful views from the top of each one, pressing you on to tackle the next.  There was something so engaging about it that I, and many others, spent <em>way</em> too much time just playing with it.</p>

		<p>If there is a thing that I feel a loss of, it's kind of that.</p>

		<p>A lot of information flows past our eyeballs - far faster than we have time to actually learn about.  That's ok.  It's natural to have a spectrum of knowledge about things that can range from "I've kind of heard about it and sort of vaguely understand the concept", all the way to "I really understand this thing, very well, and can really use it".  The further you want to move something along that spectrum, the more time investment it takes.</p>

		<p>For me, often this means that allocating time to sit down and actually try to get to know something remotely significant in practice, needs to align with some a real-life need, at least vaguely.  However, sometimes, by the time you get there, you can find that there are a whole bunch of <em>dependent</em> things that you also haven't learned yet, in the way obscuring your ability to actually do so.</p>

		<p>I have occasionally spent hours shaving not one, but several yacks... with a spoon... only to eventually not get to spend much time with the thing I sat down to try in the first place. That can feel really bad and kind of overwhelming, and it really can kind of pile up on you.</p>

	</section>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Tools</h2>
		<p>Perhaps because of this, I love tools like CodePen for their simple ability to get out of my way and let me focus on something.  They are where I have 'played' the most for the last couple of years.  I don't generally make things there to show off, rather, they're where I think and explore. There, I can very easily use the most basic/common sorts of tools to focus on HTML, CSS and JavaScript - including preprocessors without worrying about all the rest of it.  You don't need to know how to setup Webpack or Babel, or organize your project, or setup a server or a bunch of other things to use tools like those, and that's all  great.</p>

		<p>On the other hand, looking back, I've probably occasionally used these great tools poorly, making <em>that</em> particular problem a little worse.  My 'playground' was pretty far removed from my 'real' space and managing both ends of that requires some careful planning and extra hoop jumping.  Eventually the time always comes when I need something those tools don't have, or have to take those nice little experiments from their playground and send them into the real world and figure all of that stuff out - and then, sometimes, the things I haven't learned are all piled up.  Again, that's not on the tools, that's on me.</p>
	</section>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Then, Glitch</h2>
		<p>When I first heard about Glitch, I kind of thought it was a REPL kind of tool, or something along the lines of a CodePen or many other things "in that vein".  I sort of chalked it up as "like other stuff I already am familliar with and probably not that exciting".  I poked the site briefly and, I'm sad to say, didn't "get it".  It didn't look as slick as some of the things I was already familliar with and, after just a few minutes, I just made a mental note to "maybe look at it again someday" and moved on to invest my time elsewhere.</p>

		<p>But then, suddenly, I expectedly had some free time to catch up and decided to go back and look again. One month later I can honestly say:</p>

		<p><em>I don't think that I have ever loved a bit of tech as much as this.</em></p>

		<p>For the first time in a long time, I feel like this is something really different and exciting.</p>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">So many things I love</h3>

			<p>I guess I can see how it is potentially easy to miss just how great it is the first time around.  Click the 'remix' button and think "well... I guess that's cool?" The editor doesn't look like much at first.  Is it kind of like CodePen, I guess?  But social somehow? Don't we already have tools and archetypes and templates and things that help you get started? </p>

			<p>If this is your initial take -- give it a minute:  It is full of so many nice surprises.  With Glitch, the more I use it, the more I dicover, and the more I discover, the more I love it.   Some of them are small and just 'pleasant' and others are shockingly great.  I'll start with the former...</p>

			<section class="sectioning">
				<h4 class="contextual-heading" style="font-size: NaNrem;">Small, but enjoyable surprises</h4>
			
				<p>First, the editor has more than you think at first glance. It's actually pretty nice.  You can move, copy and rename files pretty easily.  It has code collapsing and 'as you type' linting and inline error reporting, and it has a dark mode that is actually pretty easy on the eyes.  It's also 'type aware' and has diffrent integrations.  Images and media, for example have a little asset management thing and get hosted on a CDN without you having to deal with that - and your package.json, if that's your thing, has an NPM integration that let's you just search for packages and click 'add'.  So nice.</p>
			</section>
			<section class="sectioning">
				<h4 class="contextual-heading" style="font-size: NaNrem;">More importantly: It's all real.</h4>

				<p>Remixing is fun, and actualy surpsingly helpful as a way to learn and get started and begin to explore.  That is considerably more valuable than I realied and helps a ton with the problem I described above about there being so many things.  But it's also only part of the allure for me.  Another part is that it isn't <em>separate</em>, it's <em>real</em>, and there is so much <em>there</em>. Together, these feel like a powerful combination that re-ignites a spark for me.  It's been so delightful to increasingly realize.</p>

				<p> 
					Every time I think that's as far as this is going to go and I'm going to have to get into 'the real thing', it just keeps giving because it <em>is all real</em>.  It's not just 'here is a local server and project layout that you can start with in a semi-fake way', it's <em>real stuff</em>.  You can tackle real things, and just keep growing it.</p>

				<p>For example, that's not just some things that kind of look like files on the left - those are <em>actual files</em> that exist on an <em>actual</em> container - and you didn't have to learn how to use docker or something, it just is.</p>
				<p>You can access a terminal window by simply clicking a button.  You don't have to ssh into it or something, you just click.  It's almost just like it exists right there on your computer -- but it is real.  You can click the 'log' button and see the server logs.</p>
				<p>Your server will have HTTPS and be in a legit subdomain, right away, where you can get started with lots of powerful features.  Service Workers work here, right away, in exactly the way they will in real life.  Your site's local storage is your local storage, not everyone elses.  Your site's permissions are your permissions, not someone else's.  It's all 'real'.</p>
				<p>Further, it's yours - you can just say "give me the git" and you've got it. But you don't even have to in order to use some of the features you'd love.  There is a <em>rewind</em> button that you can use to undo time.  Wow.  So great!  You can also use a .gitignore to hide files from the editor, and store secrets with things like service account information in a place that only you can see.</p> 

				<p>You can <em>lock</em> your project and then it's kind of private, people won't stumble across it and be able to remix it....You can feel safe exploring all over the place - this is where I've spent most of my time - just having fun and growing ideas that I'm not sure I want to share yet...</p>
				<p>
				But you can also <em>invite</em> people, even to the locked projects.  You can create <em>teams</em> and even collaboratively edit as if it were Google docs or a shared etherpad or something.  So. Great.</p>

				<p>Oh hey, are you having a problem with your server - click 'debug' and you can connect a debugger right to it... Waaat?</p>
				<p>Need more help?  There is community support where people can help you get unstuck.</p>
				<p>Really, I started playing with some personal projects.mostly not public yet a month ago and just exploring.  I haven't been able to put it down since.  I just want to keep playing.  Really, it's the most fun I have had in so long, and because of that I have probably learned and accomplished more in that time than any time in recent memory.  Give it a try.  It's <em>so great.</em></p>
			</section>
		</section>
	</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Alice 2019]]></title>
        <id>https://bkardell.com/blog/Alice-2019.html</id>
        <link href="https://bkardell.com/blog/Alice-2019.html">
        </link>
        <updated>2018-12-23T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[I began blogging about W3C politics and elections in 2012.  If you've read my pieces before or are otherwise already familliar with the W3C Technical Architecture Group, you can skip ahead to "Alright, tell me about this election".  If, however, you find youself thinking "Elections in W3C? Politics?" then let me fill you in.]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Alice 2019</h1>
	<p class="segue">I began blogging about W3C politics and elections in 2012.  If you've read my pieces before or are otherwise already familliar with the W3C Technical Architecture Group, you can skip ahead to "<a href="#alright-tell-me-about-this-election">Alright, tell me about this election</a>".  If, however, you find youself thinking "Elections in W3C? Politics?" then let me fill you in.</p> 

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;"><span id="user-content-elections-w3c-politics">Elections? W3C Politics?</span></h2>

		<p>Yes.   I wrote a brief (~400 word) "<a href="https://bkardell.com/blog/W3CPrimer.html">Primer for Busy People</a>" on the general "parts" of the W3C and introducing the two elected bodies, and if you find any of these terms confusing, pop over and give that a read.</p>

		<p>While working groups (like the CSS Working Group, for example) are unbounded in size and composed through 'appointment', the Technical Architecture Group (TAG) is kind of different.  It is chaired by "The Director" (still currently Sir Tim Berners-Lee) and composed of a very small number of "seats", a little over half of those are filled through an election process.</p>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;"><span id="user-content-ok-but-what-does-the-tag-do">Ok, but what does the TAG <em>do</em>?</span>
			</h3>
			
			<p>While working groups are focused on solving particular problems, the TAG's job is to make sure it all makes sense together - to  be a kind of steering committee for the W3C/Web at large.  They are charged with the broad view and direction - asking questions about things that seem problematic or inconsistent and giving helpful feedback and advice to help pull it all together and guide everyone along.</p>

			<p>So, basically, if you have 'broader' concerns within the W3C, the TAG can help guide things along and maybe help give them a nudge.</p>

			<p><a href="https://www.smashingmagazine.com/2016/03/houdini-maybe-the-most-exciting-development-in-css-youve-never-heard-of/" rel="nofollow">Houdini</a>, for example, was a discussion that began in the W3C TAG and became a Task Force with members from all of the major browser vendors on it.   In merely a couple of years (that is light speed in Web standards), things that seemed highly implausible and maybe not worth the time now seem both reasonable and exciting to all the members I've talked to, not just those currently implementing.</p>


			<p>Even simple things like making sure in reviews that API signatures were similar and consistent across the platform are a huge win.</p>
		</section>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;"><span id="user-content-alright-tell-me-about-this-election">Alright, tell me about this election!</span></h3>

			<p>I think it's fairly important that we keep The W3C TAG staffed with the right mix of people for the right times and continue to improve how the W3C and standards work.  I think it is important that Web developers are kept in mind and have a voice, and so for the last few years I have blogged about who I thought should be elected, and why - and asked developers to lend their support asking W3C member companies to support this choice (or make their own).  This worked.  Candidates that we publicly supported were overwelmingly elected.</p>
		</section>

		<section class="sectioning">

			<h3 class="contextual-heading" style="font-size: NaNrem;"><span id="user-content-and-then">And then...</span>
			</h3>
			
			<p>A little over a year ago, the W3C changed the way that elections work.  Previously, people could cast 1 vote per open seat and the people with the most ballots filled the seats.  It was imperfect, but it was simple.  As a result of the change, however, <a href="https://bkardell.com/blog/W3CTAGElectionChange.html" rel="nofollow">things got more complicated</a>.  Now, members cast, effectively, a single vote.  It has lots of preferences, but only one is actually counted.  Arguing for a slate of people has no positive effect in this system, it's specifically designed with this as a feature.  Further, I can imagine negative ones.  Some people will debate the latter, I'm sure, but the net result has been that it's kept me from making a case for who I think the W3C should elect since and instead focused entirely on helping make sure there are good options in the first place.</p>

			<p>So, there's an election and with luck, we have <a href="https://www.w3.org/2018/12/03-tag-nominations" rel="nofollow">4 super great nominees</a>  for 3 open seats: Alice, Tess, Travis and Sangwhan (in alphabetical order).  Really, I love them all.  They are all super smart, I think they would all be great on TAG.  I wish we could just say "yes please" and seat them all.  Good luck to all of you friends.</p>
		</section>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;"><span id="user-content-excitement">Excitement</span>
			</h3>

			<p>Since I've already explained that I worry about making a case for a particular slate of people with these changes, and that I'll be satisfied with any outcome in this election, you might wonder why I am writing at all.</p>

			<p>The answer is pretty simple: <em>Because Alice Boxhall is running, and I'm pretty excited about it.</em></p>

			<p>I've hoped Alice would run for TAG for a while now, and now that she is I just want to say that I wholeheartedly support her.  If I had a ballot, I would enthusiastically place her name in my #1 spot because I think the TAG needs someone just like her.  As I say, <em>all of these candidates are great</em> and bring something positive - but Alice brings something that I don't think anyone else can.</p>

			<p>If you don't know Alice (<a href="https://twitter.com/sundress" rel="nofollow">@sundress</a> on Twitter), she is part of a (great) team whose wide ranging-responsibilities include just about everything you can imagine surrounding accessibility on nearly everything involving the words "Web" or "Chrome" in any way.</p>

			<p>Usually, when we're talking about people who work 'at browser vendor', it's normally not a person with accessibility attached to their name as a primary goal. And conversely, we have a lot of really great accessibility experts who just don't have the technical experience of actually working on a browser engine. But Alice combines the perspectives of implementer, developer advocate, and ally for people with disabilities.</p>

			<p>She's worked on excellent (and free) education about accessibility which is really understandable for developers. At the same time, she doesn't assume the problem is just that we're simply all too lazy to learn something - she empathizes with how overwhelming, or sometimes even convoluted things can feel and how hard it can be to get even simple things right and that this won't yield good results. So she also works on tools to make it easier. Have you ever used the little color contrast thing right in the Chrome DevTools style tab? That's Alice, for example.</p>

			<p>That's a lot, and already I think, more than enough reason to vote for her - but there's more: She doesn't just care about educating developers and making it easier for them to get right - she's also interested in improving the platform itself and including developers in that process. That's how I came to know her, in fact. She has written articles, helped incubate proposals, created polyfills, popularized them enough to let developers help iterate, test and prove we have a good answer that helps make it easier and more plausible to 'get it right'.</p>

			<p>I feel like <a href="https://www.w3.org/2018/12/03-tag-nominations#ab" rel="nofollow">she explains all of this better herself</a> in her statement, but, essentially:  It seems to me that Alice brings a rare and broad blend of skills, perspective and knowledge that I think would really benefit us all to have at to the TAG table, and that she is uniquely qualified to do so.  She's not just one thing - she's an 'all of the above' that is rare.</p>
			<p>So... I'm happy that Alice is runnning.  I'm excited.  I support her.  If what she writes resonates with you too, and you agree that she would be an important addition to TAG, let someone know.  If you know a W3C member, tell them.  If not, just share your support.  History seems to show that if enough people share it, it gets seen.  I hope lots of people place her in their #1 spot on the ballot before the polls close at 11:59pm on January 4th.</p>

			<figure class="captioned-image">
				<img src="https://bkardell.com/media/Vote_Alice.png">
				<figcaption>Vote for Alice</figcaption>
			</figure>
		</section>
	</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Standards Crisis on Earth-1]]></title>
        <id>https://bkardell.com/blog/Crisis.html</id>
        <link href="https://bkardell.com/blog/Crisis.html">
        </link>
        <updated>2018-12-03T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[
	This week, not for the first time, some folks (here's one link) suggested that our inability to standardize really common things has had some negative impacts - and discussion about how to fix that. I agree, but also have complex thoughts on this that have been brewing for some time in the form of half finished blog posts... So, I'll try to write those here and, hopefully, not make it too boring.
	]]></summary>
        <content type="html"><![CDATA[
	
	<div id="downloadsPrefs">
		<p style="font-size: 1.5rem">Note from the author...</p>
		<p>My posts frequently (like this one) have a 'theme' and tend to use a number of images for visual flourish. Personally, I like it that way, I find it more engaging and I prefer for people to read it that way.  However, for users on a metered or slow connection, downloading unnecessary images is, well, unnecessary, potentially costly and kind of rude.  Just to be polite to my users, I offer the ability for you to opt out of 'optional' images if the total size of viewing the page would exceed a budget I have currently defined as 200k...
		</p>
		<p><label>Show me all the images when I read <input type="checkbox" id="download-all-images-pref" checked=""></label></p>
		<p><label>Don't ask me again on this device <input type="checkbox" id="download-all-images-pref-save"></label></p>
		<p><button id="setDownloadPrefs">Dismiss</button></p>
	</div>
	
	<h1 class="contextual-heading" style="font-size: NaNrem;">Standards Crisis on Earth-1</h1>
    <script src="../prism.js"></script>
    <link rel="stylesheet" href="../prism.css">
	
	<p class="segue">
	This week, not for the first time, some folks (here's <a href="https://twitter.com/stubbornella/status/1067656535877152768">one link</a>) suggested that our inability to standardize really common things has had some negative impacts - and discussion about how to fix that. I agree, but also have complex thoughts on this that have been brewing for some time in the form of half finished blog posts... So, I'll try to write those here and, hopefully, not make it too boring.
	</p>
 
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Introduction: A thought experiment setup</h2>


		<div class="captioned-image optional">
			<img data-src="/media/flash-jay.jpeg" alt="mysterious stranger (it's the flash.. or.. a flash)" data-canonical-src="https://img.cinemablend.com/cb/a/5/d/8/b/6/a5d8b61ee1b3092916c2bd2842f052d550aafe6b545b985bb77a0b7ca72e89a3.jpg">
		</div>
		<p>Imagine that one day, during a small meeting of Web standards folks, a curiously dressed stranger arrives.  "This earth's Web standards are in danger," he says.  <em>This earth?</em></p>

		<p>Through him, we learn about the existence of a multiverse in which an infinite number of "earths" exist and play out differently.  If you're not familliar with this, here'a a clip from CW's show The Flash <a href="https://www.youtube.com/watch?v=hUhtLzw9Z68&amp;t=1m6s" rel="nofollow">briefly explaining the multiverse</a> (it should jump you right to the part 1:06 into it, but you'll have to stop it yourself).</p>


		<aside class="captioned-image optional">
			<img data-src="/media/wonder-womans-twin.jpeg" alt="">
			"Earth must have a twin world existing simultaneously alongside it! But developing differently! And everyone on it is a double of everyone on Earth!" - "Wonder Woman's Evil Twin" 1953
		</aside>

		<p>So, we can think about our own reality as "Earth-1" and his as "Earth-2".  As he explains, his earth's Web (Earth-2's, that is) has a different timeline than ours, and whiteboards a table for us roughly illustrating how they differ, with some vey key elements called out.</p>

		<table>
			<thead>
				<tr>
					<th>-</th>
					<th>Earth-1 (our reality)</th>
					<th>Earth-2</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>1991</td>
					<td><strong>TimBL creates "the Web" at CERN.  HTML has 13 elements.</strong></td>
					<td><strong>Harrison Wells creates the web at Star Labs. HTML has 80 elements (almost the identical set which will make up the Earth-1 HTML 4.01 specification).</strong></td>
				</tr>
				<tr>
					<td>1993</td>
					<td>"we should have way more tags" browsers support different subsets and supersets of Tim's originals.  HTML+?</td>
					<td>People are pretty happily using HTML</td>
				</tr>
				<tr>
					<td>1994 - 1996</td>
					<td>Netscape!  Ads!  Java and JavaScript - DOM0! HTML sent to IETF (RFC-1886) for standardization. HTML2? W3C!</td>
					<td>Netscape! Ads! Java and JavaScript - DOM0!  W3C!</td>
				</tr>
				<tr>
					<td>1996</td>
					<td>Whoa, IE supports a new "CSS" thing.  HTML 3!</td>
					<td>Whoa, IE supports a new "CSS" thing.</td>
				</tr>
				<tr>
					<td>1997</td>
					<td>Whoops no... HTML 3.2</td>
					<td>People happily make websites</td>
				</tr>
				<tr>
					<td>1998</td>
					<td>HTML 4, CSS 2...Whoops, no wait, 4.01.</td>
					<td>CSS 2</td>
				</tr>
					<tr>
					<td>2000 - 2008</td>
					<td>XML ALL THE THINGS! Further CSS/JS development</td>
					<td>XML ALL THE THINGS! further CSS/JS development</td>
				</tr>
				<tr>
					<td>2008 - 2010</td>
					<td><strong>WHATWG, "HTML5".  Does hard interop work.  Adds new input types.  Adds appcache and some other APIs.  Adds many new elements</strong></td>
					<td><strong>WHATWG, "HTML Living Standard".  Does hard interop work.  Adds new input types.  Defines principles of the Extensible Web Manifesto and explains the platform, creates missing primitves, pioneers things like custom elements. It is possible at the end of this to implment just about all HTML elements as custom elements with very good parity</strong></td>
				</tr>
				<tr>
					<td>2010 - 2014</td>
					<td>People are using parts of HTML5 with polyfills.</td>
					<td><strong>People are beginning to make custom elements.</strong></td>
				</tr>
				<tr>
					<td>2014</td>
					<td>Extensible Web Manifeto, Custom Elements "v0" work developing</td>
					<td><strong>People have, suprisingly, created <em>identical</em> custom element dopplegangers for every "Earth-1" HTML5 counterpart</strong></td>
				</tr>
				<tr>
					<td>2014-2018</td>
					<td>People are still just starting to scratch custom elements (v1) and things like shadow DOM which arent quite "there" yet, but get continually closer.</td>
					<td>The doppleganger custom element equivalents have <em>exact</em> usage parity with their native Earth-1 counterparts.  That is, every line of Earth-1 code that says <code tag-esc="">section</code> simply says <code tag-esc="">x-section</code> on Earth-2, and so on</td>
				</tr>
			</tbody>
		</table>

		<p>"A rift," he explains, "was opened between universes and I have been trapped here for 6 months learning the differences between our worlds.  They're actually very nearly identical in many ways, but I believe that my own earth provides some interesting lessons for yours."</p>

	</section>


	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Why?</h2>

		<p>For the last four or five years we've (in reality) made a lot of progress, on a lot of fronts with regard to reforming "standardization".  We widely agree on a lot of foundational "bits" even across numerous standards bodies.  But, there are still a lot of unanswered questions about how to make this really "click". While the basic challenges are largely similar across standards bodies, HTML is especially interesting because it adds additional complexities...</p>

		<p>We all agree that standardization should be based on "science" and that it should involve developers and experimentation "in the wild". "The path to standardization leads through custom elements" is the refrain in both universes.  The idea that <a href="https://bkardell.com/blog/Dropping-The-F-Bomb-On-Standards.html" rel="nofollow">standards bodies should work more like dictionary editors</a> is a pretty well accepted "concept" all around.</p>

		<p>But, "<em>how</em>, specifically, do we do those things?" is as yet unanswered and, it seems quite difficult to get people to discuss details in our own universe.  Why?  Because custom elements are young and it's very hard to speculate about hyptothetical elements and futures.  It very quickly gets into all kinds of weeds and sputters out.</p>

		<aside class="captioned-image optional">
			<img data-src="/media/batman-robin-science.jpeg" alt="Batman and Robin doing science">
		</aside>
 
		<p>So, that's the idea with the multiverse: Perhaps by imagining a universe in which all of the HTML-5 elements arose in this fashion is, in a way, easier.  We don't have to get people to accept that some kind of "section" element "might be useful" or "might get popular".  We can simply say "it did" in precise parallel with our universe.  It's easier to imagine.  It allows us to get to the "... then what?" and focus on the actual questions.</p>
		<p>Also, I think it is more fun.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">"Data" initial handwaving</h2>

		<p>So, we've said that data <em>exists</em> on Earth-2, but that doesn't mean we have it.  In fact, that's job #1:  Any kind of "science" is going to inevitably involve measuring.  But who measures? How? And what do we accept that those measurements actually mean? What do we do with that information?</p>

		<p>Who measures and how is a potentially more complex topic than it seems on its face, so I'd like to just handwave over for a moment and come back to it later. For now, let's imagine that that "something like" The HTTP Archive report on element use, will do for initial discussion.</p>

		<aside class="captioned-image optional">
			<img data-src="/media/felicity-headsup.jpeg" alt="Comic image of Arrow's Felicity Smoake hacking some data">
			<p>Let's just imagine, "I'm in".</p>
		</aside>

		<p>Ah ha... This is probably the first thing we can learn: That report is not currently capturing custom elements at all. In theory though, I think that is pretty easy to remedy, so let's just pretend that we can actuallly get an Earth-2 report identical to the one linked, except that all of the "HTML5 elements" in that table are custom element dopplegangers like x-section, x-aside or x-progress instead.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Usage and Languages</h2>
		<p>If we look at that information (measuring use on unique URLs to feather out some local biases in which a few authors use it really a lot) as a chart, it would look like this.
		</p>
		<aside class="captioned-image optional">
			<img data-src="https://camo.githubusercontent.com/6d67a581785415fec403ca0b58f80533849a82b8/68747470733a2f2f626b617264656c6c2e636f6d2f6d656469612f7468656f7265746963616c2d656c656d656e742d7573652e706e673f617364" alt="simply visualization of data from the linked HTTP Archive report illustrating a curve with a dramatically increasing drop off">
		</aside>

		<p>One thing that you'll notice is just how quickly usage "falls off". There are lots of ways to attempt to rationalize the falloff there, but the truth is that this seems to be true of all languages. Fascinatingly, it seems that no matter what dataset you look at, about 20% of words account for 80% of word occurances and you wind up with a similar kind of drop off and curve.</p>

		<p>80% of pages counted here contain the elements <code tag-esc="">html</code>, <code tag-esc="">head</code>, <code tag-esc="">body</code>, <code tag-esc="">meta</code>, <code tag-esc="">title</code>, <code tag-esc="">script</code>, <code tag-esc="">div</code>, <code tag-esc="">link</code>, <code tag-esc="">a</code>, <code tag-esc="">img</code>, <code tag-esc="">span</code>, <code tag-esc="">li</code>, <code tag-esc="">ul</code> and <code tag-esc="">p</code>, but then things begin to drop off and they seem to do so kind of precipitously. 
		</p>

		<p>But even simple, mature and common tags like <code tag-esc="">em</code>, <code tag-esc="">strong</code>, <code tag-esc="">u</code>, <code tag-esc="">b</code> and <code tag-esc="">i</code> which are easy to use regardless of how you even create your content are used far less. <code tag-esc="">i</code> has even been popularly overloaded for use as an icon (no comment), increasing its chances of use. But none of these, not a single one, is in the "Top 20". Even with all of those advantages, <code tag-esc="">i</code> appears on less than 40% of URLs and <code tag-esc="">em</code> on less than 14%.
		</p>

		<p>In fact, of this list of 135 elements that are actually part of some Earth-1 standard, almost 40% of them have less than 1% use. This is again, interesting as nearly half of all word use across any corpus is the same core 50-100 words, and nearly the other half will be words that appear in that same corpus only once. What's more, it's kind of hard to communicate using only those core words.
		</p>

		<p>So what's the point? Well, simply that we should probably expect elements to follow "similar rules" of distribution and occurence, and that this should probably inform what we accept these measures to mean. It might seem at first like 1% (or even 5%) is "basically useless compared to this other thing" but that's not actually at all the case.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">"Dictionary Research"</h2>

		<p>Ideally, someone (or something) would be "watching" data that probably looks a lot like the above and looking for slang that is getting popular enough to warrant further review. Ideally they would have some kind of rule.</p>

		<aside class="captioned-image optional">
			<img data-src="/media/Batcomputer_001.jpg">
			<em>In the Batcave Detective Comics #607 (Nov. 1989) By Norm Breyfogle</em>
		</aside>

		<p>Then, in terms of a language, like English, once some slang triggers the metaphorical batcomputer and "has their attention" research have to review really a lot of actual uses to see if there is an accepted definition of this word. It seems we would need that too. We need to know not just that those tags appear, but whether they mean the same thing, and are used consistently enough to draw a definition from. It may well be the case that a lot of people are simply using a common word for very different and totally incompatible purposes.
		</p>

		<p>What specific rule(s) would work to trigger such review is certainly debatable, but I think we can probably come up with at least initial ideas and even elimiate some as "probably unreasonable" by thinking through this exersize a little more.</p>

		<p>For example, practically speaking the more use it has, the harder this would be. I think that we can probably agree that reviewing uses of Earth-2's <code tag-esc="">x-section</code> would be pretty hard, because it's used on nearly 1/3 of all URLs in that report. Worse, as I will argue later, it's probably much worse than that.</p>

		<p>So, combined with what we know about languages and word occurence, this seems to argue that we need to a rule that catch more, earlier. Even a rule like "any element that appears in the Top 100 occurences of a report like that" will miss important things, and maybe be too late. Anything considerably more stringent than that seems (like, Top 40 or Top 50) is almost certainly not going to work. Or, perhaps it is a report that only shows the top N custom elements by occurence.</p>

		<p>But, I think that it's more than just 'when do we review' - I think in many cases we want to proactively work more closely with at least some developers, very early on. There are several attempts at this sort of thing, but currently at least, we've not figured our exactly how to do this or how it fits into standarization.</p>

		<p>In any case, we can safely imagine that <code tag-esc="">x-section</code> use grabs attention, and that after some herculean review we agree that there is a common use/definition... Now what?</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Dictionary, or Dictionaries?</h2>

		<p>Well, now it gets even a little fuzzier. The most straightforward way of understanding "standardization" here is that elements become part of HTML. I think that at a minimum, everyone in all universes would agree that HTML should contain the "core words", but what are those? "section" is almost certainly one, but it's unclear what the "core words" really should be. Further, even in spoken languages real communication usualy requires more than core words. It seems very likely to me that HTML should have (and arguably does on Earth-1 already) at least some "more specific" words too. But, I'm not sure where we draw the line, or that we're discussing what that even means.</p>

		<p>On Earth-1, for example, before "HTML5" one could definitely argue that HTML itself was about really general things whose semantics were about basic text. Earth-2's version of 'core words' still has that characteristic. But our HTML now includes elements like progress, which, in practice, does not really seem like that. Unless you really, really squint at it and imagine use cases that don't actually exist, progress really only has meaning with dynamic state - for something more "applicationy". It is undeniable that people build applications with the Web - but, the question of whether HTML itself should include tags about "application stuff" was very real: Many converations took place in the early-mid 2000s. We decided "yes" and put them into HTML5 - but if things developed the way described on Earth-2 where HTML didn't include that sort of thing natively... Would we, add it to HTML itself? I'm honestly not sure.</p>

		<p>What I do know is that we will have to draw lines: Not everything useful, even useful to significant numbers of people, can probably 'fit' in HTML. What do we do with those? Do we just pretend they don't exist? Are they simply relegated to life as custom elements and everything that currently entails?</p>

		<aside class="captioned-image optional">
			<img data-src="/media/dc-kids-dictionary.jpeg" alt="">
			<p>
				<a href="https://www.goodreads.com/book/show/3808531-the-super-dictionary">A DC dictionary for kids</a>.
			</p>
		</aside>

		<p>If so, this seems like kind of a pity for a lot of reasons. First, the "price" of doing otherwise expands as very popular ideas build on one another. Second, some kind of standardization is still probably helpful, even if that is outside of HTML itself, and it seems that encouraging and incentivizing that for things that can find an audience would be helpful. Is it possible that there is some kind of thing inbetween "It's part of HTML" and "It's just a custom element like any other" which has some advatages and incentives that help encourage good things to happen?</p>

		<p>Some idea around helping optimize or virtualy eliminate loading times, for example, would be a big deal. Perhaps if dictionary researchers idenitifed something like this we could provide a way to expose a 'universal cache' registry or something that effectively registered a hash with the browser itself that developers could lean on to avoid 99% of loading for that definition... or something? Perhaps those could also use WebAssembly to further reduce parse? I don't know, honestly, I'm just describing vague ideas about what be possible 'advantage' characterstics of an 'inbetween' soution.</p>

		<p>The closest thing I have seen to discussions like this are <a href="https://github.com/drufball/layered-apis">layered APIs</a> but I'm not quite sure that that's really the same thing, or is "it." I'd like us to think this through a lot more.</p> 

	</section>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Codifying vs Similar Solutioning</h2>

		<p>Another thing that I think plays into this thinking about the story of how we go from custom element to native HTML.</p>

		<p>Again, considering that Earth-2's data suggests unequivocably that there should be a standard "section"... What does that actually mean in it's final state, and, probably as importantly - how do we arrive there along the way?
		</p>
		<p>Let's imagine that, they decide to just make a native section tag now. As always happens, a browser or two actually does the work and starts shipping that. An Earth-2 developer starting a new a new project is faced with a 'new' kind of problem that I think we'e never faced before: They can choose between a popular custom element or it's native doppleganger, but they are written differently. Ideally, they would start using the "native" one and optionally load the custom element definition as a polyfill -- but how? As far as I have seen there is no staightforward path, advice or pattern here about how to span this gap.</p>
		<p>A developer could, perhaps skip loading the actual definition, but they have to keep using the custom element markup and registry... For example, perhaps they could write something like:</p>

		<pre><code class="language-javascript">if (customElements.get('x-section')) {
    customElements.define('x-section', HTMLSectionElement)
} else {
    // load polyfill
}</code></pre> 
		<p>But... If I think about it - that's kind of screwed up and makes it seem harder to "dig out of" that situation. Until all browsers ship it, people are extremely unlikely to use it because so many already have a custom element solution that works everywhere. Until people use it, browsers are unlikely to priotitize its shipping, even if we can agree it is good. Even once everyone has shipped, there is legacy - and the bigger that legacy gets, the harder this problem is. This approach seems like it would cause the 'legacy' to considerably expand rather than contract.</p>

		<p>That's kind of interesting because it's both a new problem for us (again, as far as I can see) and a problem that language dictionary editors don't have. They don't mint a similar solution and attempt to coin a new word that means the same thing as something in popular parlance.  They just say "yeah, that's officially a word".</p>

		<aside class="captioned-image optional">
			<img data-src="/media/similar-flashes.jpeg" alt="depiction of many 'similar' but not 'same' earth flashes in TV and comics. Only the concept of 'speedster flash' is standard.">
		</aside>

		<p>Perhaps instead an 'inbetween' solution could be helpful in many of these cases too. Allowing that x-foo could actually be a standard and making it easy to opt-into a more official and 'advantaged one' would actually be a lot closer to what language dictionary editor's do, and maybe that is important in maybe useful ways?</p>

		<p>Again, I don't know. These are things I would like to see more discussion on.</p>

	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;"><em>Actually</em> Measuring and Researching</h2>


		<p>Thusfar we have simply imagined that the data from the HTTP Archive is our data set. But, as I said, I think that getting the "real" data that we actually need is probably going to be trickier than that.</p>

		<p>To illustrate, let's turn back the <code tag-esc="">progress</code> (or <code tag-esc="">x-progress</code>) example. Is that really an accurate read on it's use? I would wager, very probably not. Why? Well, I think that it's because of what we're measing there, and how.</p>

		<p>While the HTTP Archive has a really a lot of data, it's actually not even the tip of the iceberg that is the real "Web" (ie, all the things you view in a Web browser). As great as it is, it is neither unbiased (not in an intentional or negative sense) nor complete.</p>

		<p><code tag-esc="">x-progress</code> is an example of something that I would fully expect to under-report on the HTTP Archive report. It is freqently only inserted into a document termporarily, and based upon some significant user interaction. It's considerably more likely to be used in things that are more "appy". These are kind of problems for the HTTP Archive to get it even if they are "public" but those sorts of things also are frequently "behind" something that makes it even harder -- requiring a login, or a coprporate intranet, for example. So, that really skews what is going to show up here and, if we are looking at occurences and ranks as our 'trigger' or how we go back and do the research - that's going to make whole classes of very useful elements substantially disavantaged and others subtantially overly advantaged in ways that might be worth considering.</p>

		<p>What's more, as I said, it includes a lot of sites, but it's still limited not only by the above, but also based on some measure of 'popularity'. Depending on what you are talking about this can have a really big impact and, I think, lead us astray. Eating food, for example, is critical - but I spend far more time doing all sorts of other innane things. It's less popular by that measure than, say, playing Playstation. But... idk... it feels important.</p>

		<p>Another, probably better, way to measure might be browser telemetry. But, afaik, browser telemetry doesn't give us back URLs or a good way to reach and research those things either.</p>

		<p>Further, we'd have to be careful to somehow collect and coalese this data seamlessly too to avoid other kinds of hiccups though. For example, there are sites/apps which are keenly important and widely used for specific purposes who, for various reasons, people avoid certain browsers. This is bad for the Web, but it isn't always for equally bad reasons: Telemetry data for Firefox, for example, would have for a long time seriously under-reported how important video was for me, saying it was near 0. That would have been entirely untrue though, I almost always have videos playing. Rather, most of us quickly learned that Firefox wouldn't play a lot of videos and consciously would view sites with videos in Chrome.</p>

		<p>Similarly, I have seen other very particular but not rare use cases in which specific browsers are recommended not to use for something kind of specific because of issues with thirdparty software. Businesses and developers frequently have to play a very delicate balancing act and, it would be terrible if, for example a browser were to claim that their own low use didn't need to be specially reconicled somehow with another browser's much higher numbers because that may well indicate such a gap.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">So....?</h2>
		<p>
			So, it seems like, somehow, we're going to start figuring out how we really science the shit out of this. How do we do it? How do we answer all of these questions and setup processes (and maybe new roles?) to make this really hum?
		</p>

		<aside class="captioned-image optional">
			<img data-src="/media/science-the-shit.jpeg">
		</aside>
		<p>
			We want developers to play a big role here, but without answers, developers speculate about the future.  I've seen this already and I worry that this could be disillusioning if that speculation winds up being far from reality.  I don't want people to feel misled or disullusioned.  If this goes badly, our hypothetical visitor from another earth might be right: Our standards might be in trouble.  In fact, I think that this might even already more relevant and pressing than we realize... but I'll save that argument for another post.
		</p>
		<p>
			It's entirely possible that there are some fairly complete and mature thought around some of these issues that I've just not yet heard articulated.   I'm fairly certain though that even if there are, there are still many additional discussions to be had, changes to try and so on before we've really figured it out - so I would love to have (or hear) more of those conversations.  It definitely seems to me like there is a lot of value in having some open conversations on these topics. 
		</p>
	</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Onward]]></title>
        <id>https://bkardell.com/blog/Onward.html</id>
        <link href="https://bkardell.com/blog/Onward.html">
        </link>
        <updated>2018-11-05T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[
		So, it's time for something new... 
	]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Onward</h1>
	<p class="segue">
		So, it's time for something new... 
	</p>  
	<p>
		13 years ago, while finishing up a short contract for JBoss, I interviewed with the Apollo Education Group.  I was interviewed by 5 people at the same time and... it was a surpisingly tough interview.  At the same time, I had no real pressure on me because I had another offer on the table already.  I wound up doing pretty well and, more importantly, actually asking a lot of questions myself.
	</p>

	<p>
		I'll never forget that interview, not because of how challenging it was but because I was able to just talk to them, and I immediately <em>liked</em> this team.  We had a connection.  They were smart, friendly, articulate and excited.  The work they were doing was interesting.  Further, the basic idea of expanding available higher ed and lifelong learning was a thing that I could feel good about in ways that I couldn't about a lot of other jobs I had interviewed for.  And so, when they made me an offer, despite the fact that it paid less than the one I already had in hand, I happily went off to work with them instead.
	</p>

	<p>
		Over the years, the precise aspects and focus of my job itself have evolved a number of times as things have shifted around but, it's almost always been around something "core" and generally closer to users than to say crunching numbers and processing data or machine learning.  Nearly all of my work has been in larger efforts, working on central projects.  Over the years, this has afforded me many unique challenges and the opportunity to work with a lot of teams and people on a lot of projects with very different needs, skills and legacy. As such, I feel like I was afforded the opportunity to see a lot that many never get to, and to try to help make things better.
	</p>
	<p>
	  This, in turn led me to actually get <em>involved</em> with Web standards instead of just following them and then to talk to even more people about the things that matter to us all and ultimately to try to improve how we approach standards themselves.  At this, I feel that I have been reasonably successful.  There are many and complex reasons why I stayed at the same place for so long, but no small part of that was I have always felt a real <em>connection</em> with a number of the people there.  The aims and visions expressed and established in that initial interview really stuck with me.
	</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">The End of an Era</h2>
		<p>

			But all of this is prologue.  A week ago, my (former) company had a Reduction in Force, (aka layoffs) and I was affected.  It happens.  So, it's with somewhat mixed emotions that I move on.  On the one hand, it will be hard to say goodbye to a lot of friends and let go.  On the other hand, moving on and finding new opportunities can also be good.  When word came to me, I was with a number of friends in the industry.  Each of them were kind and sympathetic and I'm extremely glad to have been in their company at the time.  Many offered to connect me with someone, but all had the same question:  
			"So, what are you looking for?  What do you <em>want</em> to do?"
		</p>
		<p>  
			The funny thing is that it forced me to realize rather suddenly that it's been a minute since anyone has really <em>asked</em> me this question.  As I look around the industry I see that many of my friends careers have gone down slightly different and interesting paths that sound very intersing to me and that I think I might be interested in.  It's kind of exciting to be able to consider something slightly different.  Advocacy and relations, for example, are pretty different from what my day job has been, but they are a thing that I do outside of work and the idea of being able to give that my focus is super interesting!  Or, there are a ton of ways to skin accessibility challenges that could be really interesting too.  Working on an accessibility product could be interesting, for example.  Or working with a CMS vendor to embrace modern standards and find ways to improve things like offline, performance or accessibility - those could be fun too.  But those are just some examples - I kind of feel like there are many things that I could do and manage to bring something interesting to the table, and to be happy... So, I'm thinking about it.
		</p>

		</section>

		<section class="sectioning">
			<h2 class="contextual-heading" style="font-size: NaNrem;">So... Now What?</h2>
		<p> 
			Well, I've begun making a list of things that are kind of important to me...
		</p>
		<ul>
			<li>Remain remote.  I have been a fully remote employee since 2009.</li>
			<li>Continue in standards work with some kind of support, even if very limited.  That is, at a minimum it can't be actively opposed to the idea and ideally would not require my only involvement to be through nights, weekends and vacations.</li> 
			<li>Interact with other developers.  One of my favorite things to do is talk with other developers.  I like to share and to have people share with me - to find what pain they experience or thoughts they have about something people are talking about.</li>
			<li>Do good.  This can take many forms, but ultimately it is what compells me to work on standards, it is what compells me to be interested in accessibility, and so on.  I'd like, at the end of the day, to feel like there is some value in what I do that goes beyond a simple bottom line.  I would love to be able to advocate.</li>
			<li>Be intellectually stimulated and work on interesting but not entirely foreign problems.  That is, I'd like to keep it about the Web, but the Web is a big topic with lots of interesting areas.  I'm interested in the possibility of perhaps working from perspectives that I haven't before.  </li>
		</ul>
		<p>
			So, that's it... Luckily I have a little breathing room to take a beat and hopefully find something I love.  I'd love to hear your thoughts if you have them:  If you know of some place that has a need that you feel like I might be good at, let me know.   If you hear of something you think I would particularly like, I'd love to hear about it. If you know of a company that ticks some of my boxes,  I'm all ears.  If you would like to connect, here's my <a href="https://www.linkedin.com/in/brian-kardell-08a4264">LinkedIn Profile</a>. If you're looking for a resume, I'll try to keep some links here updated and filling in.  For now, here's a (work in progress) <a href="https://bkardell.com/Resume.pdf">resume in .pdf form</a>.  
		</p>

</section>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[W3C Elections Just Got A Whole Lot Harder]]></title>
        <id>https://bkardell.com/blog/W3CTAGElectionChange.html</id>
        <link href="https://bkardell.com/blog/W3CTAGElectionChange.html">
        </link>
        <updated>2017-12-11T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[
        There's a new element to W3C politics and... it kind of worries me.  I'd like to make sure that people understand it and talk about what we can do about it.
    ]]></summary>
        <content type="html"><![CDATA[
    <h1 class="contextual-heading" style="font-size: NaNrem;">W3C Elections Just Got A Whole Lot Harder</h1>
    <p class="segue">
        There's a new element to W3C politics and... it kind of worries me.  I'd like to make sure that people understand it and talk about what we can do about it.
    </p>
    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: NaNrem;">Some basics...</h2>
        <p>
            So, let's just get the simple stuff out of the way:  There are 2 seats up for reelction in the W3C TAG.  If you're not familliar with how the W3C Works or what the TAG is or why it matters, fear not, there's a ~400 word <a href="https://bkardell.com/blog/W3CPrimer.html">Primer for Busy People</a>.  There are 4 nominations for these seats, 2 of them are incumbents.  You can read <a href="https://www.w3.org/2017/12/01-tag-nominations">their statements</a> for yourself if you like.
        </p>

        <p>
            In this election, I have a very strong preference for both Andrew and David.  If you asked me "how much do you support them in this particular election" the answer is "I support them both fully and enthusiastically".  I thought they were good candidates when they ran the first time, neither of been there particularly long and the record shows that they're both doing good work.
        </p>
        <p>
            Another candidate's (Reto) statement makes me actively worry that adding them to the TAG would potentially undo some of what I see as valuable progress.  I'm sure his work is excellent, but for this reason, if you asked how much I support him in this particular election, the answer is "I think that would the <em>least desirable</em> outcome" because actually, I think that the work we've seen TAG doing in the last few years is on a really <em>good</em> track.
        </p>
        <p>
            The fourth candidate (Lukasz) is somewhere in between those two postions:  While I would be sad to see either David or Andrew not be reelected, nothing in his statement leads me to believe he wants to change what the TAG has been doing and his experience is broader.  In truth, I just don't know a lot about Lukasz compared to current, sitting members.  They are "proven" and "known".  But there are things I like about this candidate's statement.  So in this particular election, all I can say really is I support them "considerably less than fully, but more than 0".
        </p>
    </section>

    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: NaNrem;">The Old Ways</h2>
        <p>
            Until recently, the W3C used a simple plurality voting system to elect for TAG and AB.  In the old model, each member could cast <em>one vote per available open seat</em>: They'd simply, for example, vote for Andrew and David.  When voting closed, they'd simply count up the votes for each candidate and the ones with the highest totals win the seats.  Simple enough.
        </p>

        <p>
            Plurality systems are not without well known flaws.  They aren't expressive.  Given an election with 3 candidates (A, B and C).  You might really, really like Candidate A, and might you really, really <em>dislike</em> the idea of Candidate C being elected, and your feelings about Candidate B could be anywhere in between the two extremes.  Plurality elections are, ultimately, won by the difference.  This means that in a 3 way race you have to guess whether your preferred candidate is actually "electable" becauseby not increasing the competitive count of Candidate B (as you would have if Candidate A weren't an option), Candidate C gains.  This is unfortunate.  It is, however, at least very easy to understand.
        </p>

        <p>
            One of the key problems with plurality voting is that it just isn't very expressive and also therefore encourages less than perfectly "honest" voting.  It doesn't capture the true intents of the voter.  Perhaps a lot of "spoilers" are actually far more widely acceptable than we think, for example, and if people could safely just express that then maybe we'd have outcomes that more people were more happy with.
        </p>

        <p>
            To this end, there are <em>lots</em> of other forms of voting that aim to do better and, recently, the W3C has switched the one they use.  <em>Who</em> to for vote for isn't the only question anymore - it's now also <em>how</em> to vote and <em>what does my vote mean?</em>  This is new and, I am worried likely to confuse.  In fact, I am not at all confident that W3C membership at large actually understood the implications when this was approved, so, let me explain the implications...
        </p>
    </section>
    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: NaNrem;">Implications</h2>
        <p>
            I want to state very clearly that I am generally supportive of a more expressive voting system that allows true intents to be recorded and considered more accurately.  What's important to realize, however, is that given the same pool of voters, the same information, and the same candidates - different systems will have different outcomes.  There is no inherently "right" answer, there are simply outcomes and the ability for us to judge collectively whether those are good or bad.  So, let's do that...
        </p>

        <p>
            Let's imagine, hypothetically, that 65% of people felt approximately the way that I do: The <em>least desirable outcome</em> is to give Reto one of the available seats.  All of those people agree that both seats should go to either David, Andrew or Lukasz.  What we disagree on, to lesser degrees is how strongly we feel about each one.  But 35% of people feel precisely the opposite: Reto is their first choice.  They think that the TAG has taken a wrong turn in recent years.  Perhaps they read his statement and they think he'll bring more semantic web stuff and more 'conceptual innovation' back to TAG.  The least desirable outcome to <em>them</em> is that both incumbents get relected.
        </p>

        <p>
            So, given this information: What should happen?  Well, here are my own feelings:
        </p>
            <ul>
                <li>Ideally the candidate who is least acceptable to 65% of people would not be elected, and it wouldn't require strategy to acheive that aim.</li>
                <li>Ideally, the 2 candidates with the widest support should get the seats.</li>
                <li>Ideally the system helps deal with the "but they probably can't win" bias by letting people accuratey express their honest preferences, thereby giving candidates with actual potential (instead of just perceived potential) a real shot.</li>
            </ul>
        <p></p>

        <p>
            However, given this hyptothetical scenario, this is not actually what happens with the system recently adopted.  What would happen in that system is that the candidate who is the least acceptable to 65% of people is interpreted as the best choice and is pretty much guaranteed a seat.
        </p>

        <p>
            To me, this feels like a bug - but it is actually a design <em>feature</em> of the system that's been chosen.  As I said, there isn't a right or wrong answer to "how should it work". There are only inputs and outputs that we can discuss and weigh.  There are reasons that it is designed this way and proponents view this as precisely what should happen.  But this particular implication seems less than ideal to me.
        </p>
    </section>
    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: NaNrem;">Wait... How can that be?</h2>

        <p>Well, this system is pretty complicated but below is a video summary of how it "works"...</p>


        <div class="captioned-image">
            <iframe width="560" height="315" src="https://www.youtube.com/embed/Ac9070OIMUg" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen=""></iframe>
        </div>

        <p>
            The key point to "realize" is that in the old, plurality model, you cast <em>one vote per seat</em> and each vote is counted.  Voters are expressing preferences for <em>both seats</em>.  In this new model you express a bunch of stuff but only <em>one of your votes is actually counted</em> regardless of the number of seats.  That's the 'feature' designed to increase kinds of representation.
        </p>

        <p>
            Concretely, this means that there's a calculated threshold and a particular means of counting in order to pass that threshold.  In this model, voters provide an order of support.  65% of voters will distribute their "first choice" vote among 3 candidates in our hypothetical <em>because they have to not because this accurately reflects what they would state is their preference in terms of all the seats</em>.  Alternatively, 35% will cast their first choice vote for the same person.  In a 2 seat race with 4 candidates, the threshold is 34%.  The only thing that is certain after the first round of counting is that the least desirable outcome for 65% of people has reached it and receives a seat.  There's no counting or transfer of second or third choices or surplus votes involved in that case:  All they had to do was turn out 34% for a single candidate people are passionate about.
        </p>

        <p>
            When you look at it in this light, the whole "electability" question isn't actually resolved either.  You're actually much more likely to prevent worse outcomes by ranking candidates that you think have a chance of passing the threshold but prefer to your least desired by ranking them artifically higher than your honest preference.  Why?  Because only one vote actually <em>counts</em> and it only counts in the sense of moving someone toward the threshold.  In the end, most of those "expressed preferences" don't actually wind up really mattering.
        </p>

    </section>
    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: NaNrem;">So what can we do?</h2>
        <p>
            Well, two things: First, help me make sure that W3C membership really understands this.  Ultimately, how the W3C works rests on their shoulders.  If they want to see that changed, that can happen.  Either way, understanding how your votes are interpreted really matters.
        </p>


        <p>
            I guess this is the part that actively worries me: While I understand the good intents, this actually seems like an awfully low bar to have outsized impact.  Perhaps I am simply overly sensitive to this based on events that I observe happening in the world around me, or biased based on the systems I am used to.  I'm willing to admit that that's a possibility.
        </p>

        <p>
            But, if you share my general opinion of least desirable outcome and also think that both of the 2 seats should really be filled by 2 of the other 3 candidates - what can you do?  Well, the  <em>most important</em> thing is to help turn out the vote.  Turnout is generally very low, and "out of the box" the default liklihood is that passionate supporters with 1 candidate are more likely to show up than people who see that 3 out of 4 candidates seem acceptable.  Thus, 34% is not a hard target.  But, the bigger the turnout, the more <em>actually reflective</em> a vote will be, and, I expect the harder it will be for a candidate with small, but strong support to reach the 34% threshold.  Even reducing this support by few percent has a radical impact on the results of the hypothetical above. This is entirely achievable.
        </p>

        <p>
            If you're an AC <em>vote</em>.  Whether or not you've voted in the past, please, please vote:  Every company's votes are counted equally - the 1 person shop that joined W3C gets the same voting power as Google, Microsoft, Intel, IBM and other really big companies.  Each of you gets 1 vote that will be counted.  Make it count.  If you do, be sure to use the "no other candidate" option rather than implying any degree of support for a least desirable outcome so that when votes transfer they don't poorly impact.  Even if this doesn't ultimately wind up impacting the results, it helps inform the AB and system whether this result is desirable.
        </p>

        <p>
            If you <em>know</em> an AC (even if you are one yourself), please share this with them.  Make sure they see it.
        </p>

        <p>
            If you are anyone else -- please share it on social media. Believe it or not, we're all wildly connected and you'd be suprised at how easy it is to bump into a connection who either is an AC or at least knows someone who knows one. Just, basically, help get the word out.  If you have an opinion, share it.  In the past few years, people with the power to vote have listened to what you've had to say and there's no reason to think we can't make them listen again.
        </p>
    </section>

    <p class="thanksTo">Special thanks to my friend, Chris Wilson for spending a <em>substantial</em> amount of time helping me understand the details of this voting system.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[A Brief W3C Primer for Busy People]]></title>
        <id>https://bkardell.com/blog/W3CPrimer.html</id>
        <link href="https://bkardell.com/blog/W3CPrimer.html">
        </link>
        <updated>2017-12-05T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[
        Every few months, I find it necessary for some reason, to describe something about how the various W3C roles/terms work together at a high level.  It takes about 400 words and, rather than continue to type them over and over, I thought I'd simply create a linkable thing that I can just point to instead. Hooray for links!
    ]]></summary>
        <content type="html"><![CDATA[
    <h1 class="contextual-heading" style="font-size: NaNrem;">A Brief W3C Primer for Busy People</h1>
    <p class="segue">
        Every few months, I find it necessary for some reason, to describe something about how the various W3C roles/terms work together at a high level.  It takes about 400 words and, rather than continue to type them over and over, I thought I'd simply create a linkable thing that I can just point to instead. Hooray for links!
    </p>

    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: NaNrem;">Work</h2>
        <p>
            The W3C itself is really designed to allow various interests to work together and have some kind of way to help reach large group concensus toward open standards.  Most of the work that happens in the W3C happens under the banners of in either <em>Community Groups</em> or <em>Working Groups</em>.  Both of these formats are, primarily, designed to facillitate discussion in a way less encumbered by potential intellecutual property and patent issues. The former is more wide open and the latter the more formal step on the way to standardization with more necessary rigor.
        </p>
    </section>
    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: NaNrem;">Advisory Committee</h2>
        <p>
            Fundamentally, the way this is accomplished and the way the consortuim is held together involves what is called the Advisory Committee (AC).  When an organization joins the W3C, they must name an AC representative.  The AC Representative then is in charge of, as the name suggests, representing their organization in helping 'run' the W3C.  What this means, in practice, is that AC Representatives are, for example, the ones who say "I release this person from my organization to particpate in such and such group, attend meetings, and work 'in the open' on standardizing what is in the charter". The AC Representatives also are in charge of ulitimately making decision about how the W3C itself works.
        </p>
    </section>
    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: NaNrem;">Elected Groups</h2>
        <p>
            Two groups within the W3C though are different: The Technical Architecture Group (TAG) and the Advisory Board (AB).  The TAG is in charge of looking across all the work and keeping the "vision" of all of the work being done at the W3C healthy, coherent and working synergistically to remain healhty in the very long term (think 50-100 years).  In some ways, you can kind of think of it as a steering committee for work and focus.  The Advisory Board (AB) is in charge of advising the Advisory Committee on any changes that have been suggested to the way the W3C operates, answer questions, etc - before it is ultimately voted on by the AC.
        </p>

        <p>
            Each of these groups are a very small number of people nominated and chosen by the AC members themselves to hold these roles by election to serve for two years.
        </p>
    </section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[i is="the walrus"]]></title>
        <id>https://bkardell.com/blog/TheWalrus.html</id>
        <link href="https://bkardell.com/blog/TheWalrus.html">
        </link>
        <updated>2017-11-23T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[
        It's become a fairly regular occurence for me to encounter someone on social media expressing some kind of frustration with Custom Elements.  As both an avid user of them myself and someone involved in many discussions during their creation and evolution, I really want them to be better too.  As I speak to the folks who are frustrated, however, I find that there is so much there that it's difficult to discuss.  So, I thought perhaps it would be worth sitting down and writing about it.  That, and walruses.
    ]]></summary>
        <content type="html"><![CDATA[
    
	<div id="downloadsPrefs">
		<p style="font-size: 1.5rem">Note from the author...</p>
		<p>My posts frequently (like this one) have a 'theme' and tend to use a number of images for visual flourish. Personally, I like it that way, I find it more engaging and I prefer for people to read it that way.  However, for users on a metered or slow connection, downloading unnecessary images is, well, unnecessary, potentially costly and kind of rude.  Just to be polite to my users, I offer the ability for you to opt out of 'optional' images if the total size of viewing the page would exceed a budget I have currently defined as 200k...
		</p>
		<p><label>Show me all the images when I read <input type="checkbox" id="download-all-images-pref" checked=""></label></p>
		<p><label>Don't ask me again on this device <input type="checkbox" id="download-all-images-pref-save"></label></p>
		<p><button id="setDownloadPrefs">Dismiss</button></p>
	</div>
	
    
    <script src="../prism.js"></script>
    <link rel="stylesheet" href="../prism.css">
    <h1 class="contextual-heading" style="font-size: NaNrem;"><code tag-esc="">i is="the walrus"</code></h1>
    <p class="segue">
        It's become a fairly regular occurence for me to encounter someone on social media expressing some kind of frustration with Custom Elements.  As both an avid user of them myself and someone involved in many discussions during their creation and evolution, I really want them to be better too.  As I speak to the folks who are frustrated, however, I find that there is so much there that it's difficult to discuss.  So, I thought perhaps it would be worth sitting down and writing about it.  That, and walruses.
    </p>


    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: NaNrem;">The time has come...</h2>
        <div class="captioned-image optional p-attached p-attached-right">
            <img data-src="http://www.jabberwocky.com/carroll/pics/glass21.gif" alt="">
                "The time has come," the Walrus said,<br>
                "To talk of many things:<br>
                Of shoes--and ships--and sealing-wax--<br>
                Of cabbages--and kings--<br>
                And why the sea is boiling hot--<br>
                And whether pigs have wings."
        </div>

        <p style="clear: none">
            Over the last few years, I've watched several observations and criticisms sprout up about Custom Elements.  It began (I think) with someone pointing out that there's an ability that is spec'ed today: The ability to extend native elements with the <code>is="…"</code> attribute.  Extension, as the argument goes, is desparately needed for accessibility sake.  Yet, for some reason, it remains unimplemented.  This has generated a lot of discussion, frequently about who was to blame for holding the Web back and making custom elements less valuable.  Given this core premise, further arguments have been made as to how this would be good for so many additional reasons: Given X, then Y. Given Y, then Z.  In concert, all of these simple observations and arguments really do appear to lead inexorably toward a very simple and well-justified "overall solution" that would be really grand...If browsers would just get their shit together and implment the thing in the spec.  It's pretty frustrating to a lot of people.  I can appreciate that.
        </p>

        <p style="clear: none">
            I'd like to take some time and unpack a lot of this though...
        </p>


        <section class="sectioning">
            <h3 class="contextual-heading" style="font-size: NaNrem;">Accessibility Magic</h3>
            <div class="captioned-image optional p-attached p-attached-left">
                <img data-src="/media/walricorn.jpg" alt="walricorn t-shirt">
                <p>You can, and probably should, buy this amazing walricorn t-shirt on Amazon.</p>
            </div>

            <p>
                Let's start here: The popular understanding that if we were to extend a built-in element it would be "automatically accessible" by the simple virtue of inheritance.  I think it's important to explan that this is very nearly entirely untrue.  Sadly, the magical walricorn won't actually magically bring all of the good little elements who used <code>is="…"</code> free accessibility on International Walrus Day (November 24th).
            </p>

            <p style="clear: none;">
                Here's why: <em>Currently, all that accessibility goodness that we desire is inextricably wound up in the native DOM</em>. Sadly, the vast majority of use cases for "improving" a native element is actually about improving the DOM itself, and this creates a substantial mismatch.  In reality (not an opinion), as soon as we create a new shadow root or hide the existing element or do just about anything really useful to the user experience, all of that accessibility goodness largely just vanishes.
            </p>

            <p style="clear: none">
                Note: I say <em>almost</em> entirely untrue because there, in fact, are some small set of problems that involve no new DOM at all.  However, in terms of accessibility, many of these  also have similarly trivial solutions already available today and/or there are other proposals under discussion that promise to help solve these problems better.
            </p>

            <p style="clear: none">
                So, any concept that <code>is="…"</code> will make all components more accessible is, sadly, just misleading. There's no magical affordance in extension that allows it to map "whatever random shit I just made up" to "the thing with all of the good accessibility characteristics".  You've still got to do a lot of work.
            </p>

            <p>
                What's more, this isn't really a controverial statement in standards land.  Hats off to Google for actually trying really hard to solve a lot of problems. For a brief instant, some people were very hopeful in the idea of <code>is="…"</code>.  Others saw too many problems and too little benefit.  That moment seems to have passed though and, realistically, no one seems to actively believe that  <code>is="…"</code> holds a lot of answers.  Since that time, counter-proposals have been fermentingand, currently, appear to have wider conceptual support (I'll mention some of that later).
            </p>

        </section>

        <section class="sectioning">
            <h3 class="contextual-heading" style="font-size: NaNrem;">Progressive Enhancement</h3>
            <div class="captioned-image optional p-attached p-attached-right">
                <img data-src="https://www.exploringnature.org/graphics/mammals/walrus_diagram.jpg" alt="an illustrated diagram of some walrus features">
                Walrus extends Animal.
            </div>
            <p>
            While accessibility is commonly cited, I think that really it is the Progressive Enhancement (PE) that appears to be afforded by <code>is="…"</code> that is probably the real lynchpin feature that really makes so many people latch on to this idea.  I can entirely appreciate this: It sounds so good.  Unfortunately, I think this is misleading as well.</p>

            <p style="clear: none">Here's something subtle to think about:  Is <code>is="…"</code> really PE in the traditional sense?  Well, no.  It can't be since the ability to extend has never existed before. PE has traditionally never been an <em>is-a</em> relationship.</p>

            <p style="clear: none; margin-top: inherit;">Consider a common example used to explain PE: Our designs include a button that say "click to print" which should call <code>window.print()</code> when clicked.  PE says start basic with something that works for everyone.  In this case, it might be a paragraph saying "Print this page for your records".  Every browser is capable of doing that. Users can then often figure out how to print in their particular environment.  Then, if a user's browsers meets the requesite criteria (it knows what a button is, it supports JavaScript and <code>window.print()</code> is defined), then it <em>enhances</em>.  Seems good.</p>

            <p>
                But now consider the details: It might become a paragraph <em>containing</em> a functional button, or it might actually <em>become instead</em> a functional print button. Is that the same thing?
            </p>

            <div style="margin-top: 0" class="captioned-image optional p-attached p-attached-left">
                <img style="width: 300px" data-src="https://vignette.wikia.nocookie.net/marveldatabase/images/d/db/Hubert_Carpenter_%28Earth-616%29.png/revision/latest?cb=20110609023559" alt="A photo of Marvel's Walrus Man villian">
                <code tag-esc="">man is="walrus"</code>
            </div>
            <p>
                Neither <em>turning one thing into something else</em>, nor <em>changing the composition of a thing</em> are really the same thing as <em>extension</em>. Traditionally, the "ness" of that element instance never changed.  In no case was the same thing both paragraph <em>and</em> button at the same time.  That's why you can't write <code tag-esc="">p is="button"</code> for example - it's nonsense.  However, the mere fact that this attribute would <em>allow</em> an author to express such a desire (meaning, someone can and will type that) means introducing a whole lot of new plumbing and complexity for new cases that have to be accounted for.
            </p>

            <p style="clear: none">
                However we spell it out, a paragraph and a button are two things that are just entirely different things in terms of heirarchy and that's the important thing, here's why...</p>
        </section>

        <section style="clear: both" class="sectioning">
            <h3 class="contextual-heading" style="font-size: NaNrem;">Metaphorical Walruses</h3>
            <p>
                While you may think that the above "paragraph that is a button" example above seems "really different from what you're asking for" and is merely my contrived example aimed to convince you of something irrelevant, it isn't.  I would suggest that <em>currently</em> this is actually <em>precisely</em> what we are frequently asking for without even realizing it.  Why?  Well, again, that's because what we want actually usually involves new DOM.  It's not, <em>in terms available to us today</em>, actually just a specialized version of something. Really often, what we're describing is a different, and more complex kind of relationship.  <em>is-a</em> is very specifically about <em>extension</em>, and extension is about describing a taxonomy, like, in the Linnean sense.
            </p>

            <p>
                Understanding the basic ideas of Linnean Taxonomy is <em>obviously</em> very important to understand if you want to get a job as say, a marine biologist or a paelentologist. But what most people don't realize is that unlike some of the other frivolus things they made you learn in school, like, for example, algebra - understanding <em>this</em> can also come in extremely handy in everyday adult life.  For example, if you needed to help my friend Sarah Drasner win a bar bet about whether people know what it is...
            </p>

            <center style="margin: 2rem 0"><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Alright, please help us nerds settle a drinking bet. Do you know what the Linnaean System of Classification is? (No googling)</p>— Sarah Drasner (@sarah_edo) <a href="https://twitter.com/sarah_edo/status/911462225491116032?ref_src=twsrc%5Etfw">September 23, 2017</a></blockquote>
        <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></center>

            <p>
                Or, maybe more practically, if you are doing software modeling, as we are here.  So, let's talk about that for a minute.
            </p>


            <p class="sidenote">
                A really significant amount of western thought has centered around trying to divide up the world like this into kind of fragile and abritrary taxonomies. Author David Weinberger has written a lot about this tendency/history, his <a href="https://www.youtube.com/watch?v=43DZEy_J694">Everything is Miscellaneous</a> is a really enjoyable and non-technical talk that is worth watching some time.
            </p>

            <div style="margin-top: 0rem" class="captioned-image optional p-attached p-attached-left">
                <img data-src="https://cdn.vox-cdn.com/thumbor/E9-lw3BD0Ama-3cUSOXA_J5l_d0=/0x0:404x303/1400x1050/cdn.vox-cdn.com/uploads/chorus_image/image/51386351/d200908311113466240.0.jpg" alt="Photo of Barbara Liskov">
            </div>

            <p>
                In 1987 Barbara Liskov presented a keynote address called "Data abstraction and hierarchy" which talks about how we model things and our desire to organize things into heirarchies that <em>extend</em> and <em>inherit</em>. Liskov goes on to illustrate how that tends to cause numerous sorts of problems.  More importantly, she begins to explain how we might avoid those problems and the basic concept she describes is sometimes known as the "Liskov substitution principle" or "LSP" or even just "substitutionality".  In 2008 she won the Turing Award for her work.
            </p>

            <p>
                In a way, what she's saying is: Metaphor makes for shitty modeling.  Our <em>minds</em> are actually perfectly fine handling all sorts of wild linkages, comparisons and semantics that are more metaphorical than literal - in fact, they're kind of built to find patterns and relationships even when they don't exit.
            </p>

            <div style="margin-top: 0rem" class="captioned-image optional">
                <img data-src="/media/walrus_cloud.jpg" alt="Clouds that kinda sorta look like a walrus">
                Photo credit to <a href="https://www.flickr.com/photos/lostmycat/" target="_blank">Janie</a>.
            </div>

            <p>
                Programming languages, on the other hand, tend to take things pretty literally.  Because of this, our minds can trip us up and make us model something poorly.  Extension is good and useful, don't misunderstand what I am saying.  But if we use it poorly then rather than being a really helpful abstraction, we'll find that the system will begin to fight us instead.
            </p><p>

            </p><p>
                Once again, that's just what happens here: <em>Currently</em> all that "good stuff" that we want is bound up pretty tightly in DOM and therefore a lot of times when we're thinking "is-a" it's unfortunately more metaphaorical than literal.  <em>In terms currently available to us today</em>, it just isn't - and so we wind up modeling poorly.
            </p>

            <p>
                Being able to extend input "like HTML did" is one of the most cited use case examples that I hear for extension.  However, even in the platform itself, where extension was technically possible, there is no extension at play here today. There is only input.  It's worth noting that most of how <code tag-esc="">input</code> was done is largely seen as <em>considerably problematic</em> by implementers today.  Why?  Well, the easiest way to begin to understand, I think, is by listening to <a href="https://vimeo.com/176453149" target="_blank">this talk by Monica Dinculescu</a>.  In short though, it's really created by the model mismatch we've been discussing here.  Instead of being really helpful, the model begins to fight us.  We begin to see the cracks in our modeling of metaphor and that actually, it <em>isn't-really-that</em>.
            </p>

            <p>
                This mismatch is increasingly widely recogonized as a real problem that needs solving.  In the <a href="https://extensiblewebmanifesto.org">Extensible Web</a> sense, there's a lot more magic currently woven into today's DOM that needs explaining.  In order for us to actually accomplish many of the sorts of things people are actually trying to describe, we need to decouple the powers and be able to explain the existing platform, and new things, in those terms.  There are a number of discussions underway that are aimed at helping us do precisely that, and none of them are simply inheritance or <code>is="…"</code> as currently specified.  I'll write about those in another piece, but this leaves us with a very real problem:  Until then, where does that leave us?
            </p>

            <p>
                Well, interestingly, in the meantime, 'is-a' isn't the only kind of relationship we have identified for modeling problems.  The often cited Gang of Four <em>Design Patterns</em> provides the simple observation "composition over inheritance" based on Liskov's work.  That is: Composing features through a <em>has-a</em> relationship is often a better way to go in the long run anyway.
            </p>

            <section class="sectioning">
                <h4 class="contextual-heading" style="font-size: NaNrem;">We <em>has-a</em> way...</h4>
                <p>
                    The really interesting part is that absolutely nothing new is required in order for us to both follow the self-same progressive enhancement patterns that we've been using all along and gain pretty much all ofthe same values we would with <code>is="…"</code> without adding any new complexity to the platform itself... How?  Through composition rather than inheritance. In concrete terms:
                </p>

                <pre><code class="language-html">&lt;!-- instead of writing this --&gt;
&lt;input type="radio" is="x-radio"&gt;

&lt;!-- you write this --&gt;
&lt;x-radio&gt;
    &lt;input type="radio"&gt;
&lt;/x-radio&gt;</code></pre>

                <div class="captioned-image optional p-attached p-attached-left">
                <img data-src="/media/sax-walrus.jpg" alt="a cool looking walrus playing the saxophone">
                Hat tip to my pal Bruce Lawson for this, you can also <a href="https://youtu.be/0tmHaR0rCJ4" target="_blank">watch the video of this actual event involving a groovy walrus playing a saxophone</a>
                </div>

                <p>
                    Yes, it's not perfect.  Yes, it's not exact pairty.  There are some cases where you have to progressively enhance a parent element in order to affect a child, for example.  However, if you take some time and consider this carefully, you'll find that in fact, their effects are functionally equivalent in just about every useful way: Form serialization, validation, etc.  Both are declarative and have about the same fault tolerance built into their pattern.  And, importantly: As a creator of a component using this pattern, you'll have to change and proxy precisely as much <em>in either model for the sake of accessibility, depending on just what DOM what you change</em>.  Because of this "very close resemblance" if you find any of these aspects very frustrating, it's worth noting that <code tag-esc="">is="…"</code> (as specified today) would likely create <em>many</em> of the same frustrations.  I realize that this can seem a little unintuitive, so I'll likely talk about the sorts of objections I've heard to these observations in another post.
                </p>

                <p>
                    So, to sum up: We <em>has-a</em> way forward for now through composition.  It's not a bad way at all.  It's actually quite powerful and good.  It isn't perfect.  It isn't complete.  But we <em>can</em> do a lot of useful things and that's a Really Good Thing™.  The fact that we've largely stopped chasing <em>is="…"</em> isn't due to simple stone-walling by any vendor and it isn't a net loss.  Ideas need to be able to spread and percolate with lots of minds.  The original ideas also need to be able to fail if they aren't fit so that ideas can mix and mutate and ultimately better ones can arise.  That's just what I see happening here.  In near future pieces I'll write about what sorts of ideas <em>are</em> actively being chased down to help us better solve these problems instead.
                </p>

            </section>
    </section>

    <div class="captioned-image optional"><img data-src="/media/john-beatle.jpg" alt="photo of John Lennon">
    goo goo g'joob...</div>

    <p class="thanksTo">
        Special thanks to my friends, Alex Russell and Peter Rushforth for proofing/commenting on early drafts of this piece and helping them be shorter and less confusing.
    </p>
</section>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Thoughts on Voice Recognition: Web Speech APIs Part IV]]></title>
        <id>https://bkardell.com/blog/Voice-Recognition-Thoughts.html</id>
        <link href="https://bkardell.com/blog/Voice-Recognition-Thoughts.html">
        </link>
        <updated>2017-09-17T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[This is part of a series about making the browser speak and listen to speech. In my last post You Don't Say: Web Speech APIs Part III, I talked about the recognition interfaces: listening or speech-to-text.]]></summary>
        <content type="html"><![CDATA[
  <h1 class="contextual-heading" style="font-size: NaNrem;">Thoughts on Voice Recognition: Web Speech APIs Part IV</h1>
  <p class="segue">This is part of a series about making the browser speak and listen to speech. In my last post <a href="https://bkardell.com/blog/Listen-Up.html">You Don't Say: Web Speech APIs Part III</a>, I talked about the recognition interfaces: <em>listening</em> or <em>speech-to-text</em>.</p>

  <script src="../prism.js"></script>
  <script src="../test/listening/basic-voice-listener.js"></script>
  <script src="../test/listening/pausable-voice-listener.js"></script>
  <script src="../test/listening/VoiceInputElement.js"></script>
  <link rel="stylesheet" href="../prism.css">
  
  

  <p>To sum up the state of things with recognition:</p>

  <ol>
    <li>It's <em>much</em> less widely implemented and deployed than Text-To-Speech (TTS).</li>
    <li>Like TTS, it is not an 'official' standard. Browsers are working on it, but not much work seems to be happening 'together' on this anymore.</li>
    <li>It requires special privileges</li>
    <li>Its API is kind of confusing</li>
  </ol>

  <section class="sectioning">
    <h2 class="contextual-heading" style="font-size: NaNrem;">What's wrong with the current APIs</h2>
    <p class="note">These are just my personal opinions after using it a lot for the past couple of months.
    Sometimes eating the dogfood gives you new perspectives and nothing in this should be taken as a
    criticism of the brave souls that worked hard to bring us what we have.  It's easy to forget that we're standing on their shoulders. Hats off to them.</p>

    <p>Let's assume that the API worked consistently, as advertised by the existing draft, across browsers and on all devices. The trouble with is that I see is mostly just that it doesn't "fit" in the Web platform today.  It's not really a high level API, nor is it quite the low level we probably need.
    </p>

    <section class="sectioning">
      <h3 class="contextual-heading" style="font-size: NaNrem;">Imagine...</h3>
      <p>When I hear "voice recognition" or "speech to text", this implies to me that I can take a sound,
          analyze it and turn it into a transcipt of text.  When I watch a demo and I see someone speak into the mic and words come out on the screen, I have the same impression.  I get excited and begin thinking of the possibilities. Yes, I want that.  Think of all the things I could do with the ability to turn sounds of spoken word into text - I begin to imagine...
          </p>

          <ul>
            <li>I turn the directory of podcasts I've downloaded into text. I could do lots of interesting things with that, skim them for example to see if I want to listen.  Better still, I can index them and hyperlink them.. I can make a word cloud... I can search for things that were discussed without trying to remember what was said about Web Components in .. hmm some a podcast? or was it a talk? It was Jeremy Keith... I think? Last year maybe? In fact, I don't even have to have watched it to know that.</li>

            <li>Speaking of podcasts, I've been thinking of doing one.  Imagine I'm in a studio with 4 other people all with their own mics.  It'd be super neat to identify them by name and capture their transcribed text in a simple transcript.  Hey, that's kind of like meetings.  I attend a lot of meetings that aren't minuted.  We could fix that.</li>

            <li>I have a thing that lets me upload a video to a website I maintain... I know that for accessibility sake I need captions of this video and that has to be in Timed Text Markup Language (TTML).  Wow, that's a pain in the ass to write from scratch.  I could write a thing to take the audio track, turns chunks of it into text, inserts that into TTML and uploads me a draft in my workflow that I can then simply proof, correct,  approve and publish.  We can't do that with this API either.</li>

            <li>I also had an idea for simplistic, hands-free conversational assistant for while I am driving - kind of my own simplified Jarvis.</li>
          </ul>

          <p>But there's the rub, none of these are actually easily accomplishable with the current API for various reasons, and mostly simply because it is kind of hard-wired toward that sound coming from the mic without really exposing that.</p>

          <p>This is a shame because since <a href="https://extensiblewebmanifesto.org">The Extensible Web Manifesto</a> (EWM), we've worked very hard to help "explain the magic" already burried in features of the platform and focus our initial efforts on the powers that are fundamentally new. As far as I can tell, really the only thing in these APIs that is fundamentally new is the idea of an interface for transcibing audio of speech into text.  Things like promises, web audio, media devices, fetch and streams are all things we've worked on and that can potentially be used to help explain just about everything else in this API.  As the speech draft predates all this, it's no suprise that none of that is taken into account, but it's not too late.</p>

          <p class="note">In fact, the authors of the spec did recognize some of this and there are notes in the spec and errata that link to, for example <a href="https://lists.w3.org/Archives/Public/public-speech-api/2012Sep/0072.html">this observation</a> with the thought that perhaps it was too late for this draft, as it is actually a 'final report' and not an official spec.  I hope we have room to revisit this.</p>

          <p>Let's use this as an exersize to start low and build up the concepts we want, as each level affords new opportunities for people to dream up things we weren't even considering.
          I've <a href="http://bkardell.com/blog/Prognostication-And-The-Failure-Of-The-Web.html">written about this before</a>, but it's astonishing how many creations that are fundamental things today turned out to <em>not</em> be what their inventors even thought they would be. Houses were originally wired for artifical lighting  - there were no plugs, because there was nothing to plug in.  While we were busy standardizing bulbs, an astonishing flourishing of inventions and whole new industries were created by the simple fact that we gave people electricity.
          </p>
      </section>


      <section class="sectioning">
        <h3 class="contextual-heading" style="font-size: NaNrem;">A 'low-level' transcription interface</h3>
        <p>Let's imagine that we started simply with the idea of an API that gave us just the fundamentally new part: Something that takes some audio and gives you back the transcribed text.  Accessing your filesystem or your mic are things that require permission, but what we're talking about here doesn't itself do that, so that's not even something we need to worry about.  Actually, asking for analysis of something could be modeled after the HTTP request/response model, and that seems kind of fitting because there's potentially some variance in the response.  For example, different implementations can definitely have different interpretations of the same sounds.  So, let's start with the common model of being simple async and transactional, pass/fail things that we deal with via promises and resolve some kind of response...something like:</p>

        <pre><code class="language-javascript">// let's save bikeshedding a name for another day...
let transcriber = new FictionalTranscriber()

transcriber.transcribe(someAudioStream).then((response) =&gt; {
  // we'll talk more about this
})</code></pre>

        <p>That's pretty straightfoward I think. A transcriber has a <code>response</code> and an error is handled with the promise's <code>.catch</code> method.</p>

        <section class="sectioning">
          <h4 class="contextual-heading" style="font-size: NaNrem;">Results</h4>
          <p>While the current interface you get these wonky array-likes which default to having exactly one
          item in them, but let's kind of work backwards and see if we can avoid this.. Imagine that the response itself simply contains the properties <code>.transcript</code> and <code>.confidence</code> (from the existing APIs).  Then the default 'just give me your best guess' case is as simple as:</p>

          <pre><code class="language-javascript">let service = new FictionalTranscriber()

transcriber.transcribe(someAudioStream).then((response) =&gt; {
  console.log(`
    I am ${response.confidence}% confident
    that I heard "${response.transcript}".
  `)
})</code></pre>

          <p>The existing APIs also contain a separate event called <code>onnomatch</code> that is
          different from <code>onerror</code> in that it's more about it receiving
          something and processing it but not being able to confidently enough
          deterimine what was said. It seems that what we mean to say is "we recognized nothing" or
          "we heard something but what it was is undefined".  In both cases these have
          programming concepts for these: The null string ("") or, in JavaScript we also have <code>undefined</code>.  In JavaScript are falsey - so I think we can get rid of that extra event
          entirely with something as simple as saying that that is a possiblility...</p>


        <pre><code class="language-javascript">let transcriber = new FictionalTranscriber()

transcriber.transcribe(someAudioStream).then((response) =&gt; {
  // if we didn't match anything sufficiently
  if (!response.transcript) {
     console.log(`Sorry, I didn't catch that`)
  } else {
    console.log(`
      I am ${response.confidence}% confident
      that I heard "${response.transcript}".
    `)
  }

})</code></pre>


          <section class="sectioning">
            <h5 class="contextual-heading" style="font-size: NaNrem;">Alternatives</h5>
            <p>"Ah," you're thinking, "but those arrays are meaningful... One of them contains N possible 'alternatives'".   True, but alternative to what even?  This seems like a strange use of the word anyway.  Conversely, our model could also allow our response to contain an <code>.alternatives</code> array beyond our best guess transcript.  By default, it would be empty because there are no alternatives. This seems to actually match the meaning of the word "alternative" better anyway. Asking, for them seems like it could simply be an optional configuration...</p>

          <pre><code class="language-javascript">let transcriber = new FictionalTranscriber({maxAlternatives: 10})

transcriber.transcribe(someAudioStream).then((response) =&gt; {
  console.log(`
    I am ${response.confidence}% confident
    that I heard "${response.transcript}".
  `)

  if (response.alternatives) {
    console.log(`But here are ${evt.alternatives} alternatives... `)
    response.alternatives.forEach((alternative) =&gt; {
      console.log(`
        I am ${alternative.confidence}% sure it could
        have been "${alternative.transcript}"
      `)
    })
  }

})</code></pre>
          </section>

          <section class="sectioning">
            <h5 class="contextual-heading" style="font-size: NaNrem;">Implementation Flexibility and Black Boxing</h5>
            <p>The existing API designs seem to want to allow you to specify a serviceURI and that sort of thing,
            but it seems unimplemented and there seems to be some kind of hand-waving on just how that would work, because there are competing ideas.</p>

            <p>One of the extra handy things about this kind of design, I think, is that it also neatly sidesteps a number of problems that are impossibly difficult to resolve at this stage by boxing those problems at an appropriate place where there is easier to reach value and yet room for experimentation.  Let me explain...</p>

            <p>What we are providing what is, effectively, a service interface.  We're not saying how the actual
            transciption should be done.  There are an astounding amount of challenges there.  There are lots of different existing remote services with lots of different qualities, lots of different APIs and lot of different sorts of inputs. A want to figure all of this out will stall a process for a very long time and be, ultimately, as much about politics and sway as actual merit.</p>

            <p>On the other hand, if we simply say "Here's what it has to look like on the client, and the client should include a default implementation" we have to agree to very little.  While this seems like it isn't giving you 'much', the adoption of this simple pattern would provide the standard we most desparately need:  All we have to agree on at this stage is what the client interface looks like.</p>

            <p>There are some other practical upshots to this too.  The first is that we can also make that extensible by defining basic API lifecycle methods and allow competition and variance to play itself out very easily and employ lines of thinking we can't easily consider in a standards body.  Imagine, for example, that Google's cloud platform could release a subclass:</p>

            <pre><code class="language-javascript">export default class FictionalGoogleCloudTranscriber
  extends FictionalTranscriber {
    // override
    request: (audio) =&gt; {
      // return some promise that meets the expected API
      return fetch(....).then(...)
    }
}</code></pre>

          <p>The only thing that changes is which one you instantiate - they all work, at the API level, the same way.  This means that these adapters are then as easily distributable as jQuery plugins and Amazon can compete with Google and Microsoft and Mozilla and... well... anyone while we figure out </p>

          <p>This also fits very nicely with allowing us to experiment with the remaining (seemingly unimplemented) ideas in the APIs (like <em>grammars</em>) and provides room for us to work things out.  Eventually, perhaps we can derive a higher level protocol allowing us to express things as simply as:</p>

          <pre><code class="language-javascript">let transcriber = new FictionalTranscriber({
  serviceURI: 'blah',
  grammars: whateverThisIs
})

transcriber.transcribe(someAudioStream).then((response) =&gt; {
  console.log(`
    I am ${response.confidence}% confident
    that I heard "${response.transcript}".
  `)
})</code></pre>

            <p>Importantly though, this means we don't have to wait for that day and we can be part of the solution in figuring out what it should be.</p>

            <p>Interestingly, there was <a href="https://docs.google.com/document/d/1QRajFwBdV82aTnPCQNKOfL2ZGkyfG9X9ZfCYgK2xstk/edit" target="_blank">another proposal</a>, also from someone at Google
        more recently that is considerably closer to this idea.  However, that idea
        seems to have not gone far.</p>
          </section>
        </section>
        </section>
      </section>


        <section class="sectioning">
          <h2 class="contextual-heading" style="font-size: NaNrem;">Low Level <em>First</em>, Not Exclusively</h2>
          <p>The idea isn't ever to stop at the low level APIs.  It's not even that we
          absolutely positively have to have the low level APIs entirely in place.
          As I explain in <a href="https://bkardell.com/blog/Tao-Of-The-Extensible-Web.html">What Would Bruce Lee Do? The Tao of the Extensible Web</a>, in some cases we can come back and expose details of a carefully designed black box after the fact.  At a minimum, describing the API in common platform terms and the thought exercise of what a suitable low level API would look like allows us to design the boxes and
          layers carefully.</p>

          <p>For example, given such an API as described above, it <em>would</em> make sense to add a
          higher level API which made use of it and exposed it... A pattern which explained
          the common lifecycle of grabbing a device, getting permission, listening to a channel, chunking that input, sending it to the transcriber and ultimately pumping out transcripts.  Perhaps something like..
          </p>

          <pre><code class="language-javascript">// Here we create an object not entirely unlike what
// the API already had - it defaults to being initialized
// with the audio context/primary mic, sends a chunk
// of sound to our transcriber and relays the promise
// results or errors to events
let speechRecognizer = new FictionalSpeechRecognizer()


// event based methods relay promise results
speechRecognizer.onresult = (evt) =&gt; { /* evt.response.transcript */ }
speechRecognizer.onerror = (evt) =&gt; { /* evt.error */ }

// the audioContext is exposed: You can control it
speechRecognizer.audioContext.start()
speechRecognizer.audioContext.stop()</code></pre>

        <p>The general idea being that we can answer the questions "what's under there?"
        by saying "it has an audio context and a transcriber" and we can expose those
        for extensibility... For example, we could allow you to swap out the transcriber
        implementation without forcing you to reimagine any other part in the system..</p>

         <pre><code class="language-javascript">let speechRecognizer = new FictionalSpeechRecognizer({
  transcriber: new FictionalGoogleCloudTranscriber()
})</code></pre>

        <p>Or if you can get an audio context another way (say, one of N line inputs, or from a file),
        you can swap that out easily without forcing you to reimagine anything else either..</p>

        <pre><code class="language-javascript">let speechRecognizer = new FictionalSpeechRecognizer({
  audioContext: someAudioContext
})</code></pre>

        <p>Given such an explanation, we could easily experiment with further layers, floating ideas as
        custom elements.  For example: An <code tag-esc="">input</code> decorator that could progressively
        enhance an textual form controls to allow you to populate them with speech.  All you'd need
        to say is 'they have one of those speech recognizer things and provide a toggle that pipes
        voice to it and the output back into the field'.. Something like this.. </p>

        <pre><code class="language-html">
&lt;x-voice-listener&gt;
  &lt;input name="input"&gt;
&lt;/x-voice-listener&gt;
        </code></pre>
        <x-voice-listener>
            <input placeholder="How can I help?">
        </x-voice-listener>

        <p>That's kind of interesting because there were <a href="https://web.archive.org/web/20090308033937/http://www.voicexml.org/specs/multimodal/x+v/12/spec.html">specs trying to do something like that
          back to the early 2000's</a> and it seems to be where Google restarted the converstaion in 2012 as well.  We could figure that out, and do it with real world experimentation and testing! As you can
          see from this super rough demo, there's a lot to think about.. Should there be an attribute to
          autostart? Should it automatically stop?  Should other attributes be present? <code>paused</code>, for example? I don't know, but we could try a lot of things and see what works.
        </p>
        </section>
      


      <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: NaNrem;">So now what?</h2>
        <p>Since there's something implemented on Chrome and Android, you have a lot of
        0's in the number of machines that actually support the existing API.  As with
        a lot of 'new' features on the Web, you'll probably want think about how you can use
        progressive enhancement for a lot of use cases... In some cases, the API is
        good enough that you can paper over its kinks and that might be 'good enough'.</p>

        <p>Unfortunately, the low-level API sketched out in this document isn't possible
        to achieve <em>using the existing Speech APIs</em> because they don't provide adequate explanations
        or hooks. Fortunately, however, it is entirely plausbile to make this API real
        today using a remote service that conforms to a design like this.  Such services that transcribe
        sounds of speech to text are plentiful - Google's Cloud Platform and Amazon both
        provide APIs capable of achieving this for limited purposes would be free enough
        to experiment with and prove out, and fairly low cost beyond that.</p>

        <p>I have a kind of rough POC that I'll be building out, for purposes of demonstrating ideas to limited groups, but wide publicly sharable demonstration is potentially cost prohibitive (unless some vendor
        wants to donate free time).  However, if you have a business use for this,
        perhaps it's worthwhile.  If you're interested in helping out with that,
        or hearing more, let me know.</p>
      </section>

  

  <p class="thanksTo">Special thanks to my friend, the great Chris Wilson for proofing/commenting on pieces in this series.</p>

]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Listen up: Web Speech APIs Part III]]></title>
        <id>https://bkardell.com/blog/Listen-Up.html</id>
        <link href="https://bkardell.com/blog/Listen-Up.html">
        </link>
        <updated>2017-08-25T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[This is part of a series about making the browser speak and listen to speech. In my last post You Don't Say: Web Speech APIs Part II, I talked about how I'm personally papering over what
    we "have" today with regard to making the browser "talk" and why. In this post I'll talk about the other end of that: listening or speech-to-text.]]></summary>
        <content type="html"><![CDATA[
  <h1 class="contextual-heading" style="font-size: NaNrem;">Listen up: Web Speech APIs Part III</h1>
  <p class="segue">This is part of a series about making the browser speak and listen to speech. In my last post <a href="https://bkardell.com/blog/Basic-Voice-Speaker.html">You Don't Say: Web Speech APIs Part II</a>, I talked about how I'm personally papering over what
    we "have" today with regard to making the browser "talk" and why. In this post I'll talk about the other end of that: <em>listening</em> or <em>speech-to-text</em>.</p>

  <script src="../prism.js"></script>
  <link rel="stylesheet" href="../prism.css">
  <script src="../test/speaking/basic-voice-speaker-ii.js"></script>
  
  

  <p>So far we've been talking about the unoffical Web Speech APIs in terms of speech as <em>output</em>, or text-to-speech. As I've said, this is actually supported to some degree in all modern browsers. But now we're going to talk about the other end of
    things: Speech as input or "voice recognition" or, if you prefer "speech-to-text". This is currently <em>not</em> widely supported - in fact, only Chrome has a "working" implementation popularly deployed, but it is available in FirefoxOS and available
    behind a flag while they work out some permissions issues and reportedly under development in Edge as well. It's a much harder problem in general, and there are a lot of gotchas here too. In this piece, I'll cover a lot of them.</p>


  <section class="sectioning">
    <h2 class="contextual-heading" style="font-size: NaNrem;">Let's get started</h2>
    <p>Ok, so first things first: <code>webkitSpeechRecognition</code>. This is the thing that makes recognition possible. There are a number of really good articles that will tell you that you should have a line that looks something like this:
    </p>

    <pre><code class="language-javascript">
const SpeechRecognition = window.SpeechRecognition || window.mozSpeechRecognition || window.msSpeechRecognition || window.webkitSpeechRecognition;
const recognition = new SpeechRecognition();
            </code></pre>

    <p>I'm going to recommend, however, that you don't and here's why: Because we're just not far enough along to pretend we know what a compatible and standard <code>SpeechRecognition</code> will look like or that there ever will be any of those others.
      This is an approach that used to common, but that has changed and at one point we thought it was a really keen idea. Unfortunately, this interface arrived in Chrome just about the time that we began to admit to ourselves what a problem this creates.
      You'll note that nobody likes to ship vendor prefixed stuff anymore in the release channel, and here's part of the reason why: When everyone writes code like the example, it assumes that they aren't experiments or that they must be identical. Purposely,
      the original idea was that you could have a <code>webkitThingy</code> and a
      <code>msThingy</code> and a <code>mozThingy</code> and those were <em>experimental</em>. That is they might be totally different, competing experiments or simply be used to write tests and practice in order to inform what the real standard would
      be. However, in practice, the use of such patterns as the above tended to actually cause that to not be the case at all. There were 'first mover' advantages and 'market share' problems. Once we get even a couple reasonably popular uses of this API,
      the experiment now wags the standards dog because there's lots of code depending on it matching things it wasn't intended to. Both ECMA and W3C TAG have had much discussion on this problem.</p>

    <p>So, let's just be honest with ourselves and err on the side of caution and say: It's the <code>webkitSpeechRecognition</code> API at this point, and that's all we can say with absolute certainty. If we get truly interoperable implementations, how
      hard will it then be to go back and change that one line? Pretty easy, I expect.</p>

    <p>Ok so, with this in mind, we could re-write the above as:</p>

    <pre><code class="language-javascript">
const recognition = new webkitSpeechRecognition();
            </code></pre>
    <p>
      But this is just creating an interface for you, it's not <em>actually doing</em> anything yet.

      </p><section class="sectioning">
        <h3 class="contextual-heading" style="font-size: NaNrem;">Events</h3>
        <p>In order to actually do anything with it, we're going to want to tell this recognizer what we actually want from it via attaching some listeners to it. There are a lot of events that we can plug into, as you will see below but in practice I haven't
          personally required many of them.</p>

        <ul>
          <li><code>audiostart</code> "Fired when the user agent has started to capture audio."</li>
          <li><code>soundstart</code> "Fired when some sound, possibly speech, has been detected."</li>
          <li><code>speechstart</code> "Fired when the speech that will be used for speech recognition has started."</li>
          <li><code>speechend</code> "Fired when the speech that will be used for speech recognition has ended."</li>
          <li><code>soundend</code> "Fired when some sound is no longer detected."</li>
          <li><code>audioend</code> "Fired when the user agent has finished capturing audio."</li>
          <li><code>result</code> "Fired when the speech recognizer returns a result." </li>
          <li><code>nomatch</code> Don't worry about this one for now, we'll come back to it.</li>
          <li><code>error</code> "Fired when a speech recognition error occurs."</li>
          <li><code>start</code> "Fired when the recognition service has begun to listen to the audio with the intention of recognizing"</li>
          <li><code>end</code> "Fired when the service has disconnected"</li>
        </ul>

        <p>A few of these are self explanatory in terms of their lifecycle: Starts have to occur before their corresponding ends. However, one could be forgiven for wondering, for example, "which happens first according to these descriptions? audio start
          or sound start?" To answer your question, let me just quote the spec:

          <span class="spec-quote">Unless specified below, the ordering of the different events is undefined. For example, some implementations may fire audioend before speechstart or speechend if the audio detector is client-side and the speech detector is server-side.</span>
        </p>

        <p class="note">If you're thinking to yourself: "Wow, that seems potentially really confusing and hard to work with," same.</p>
      </section>


      <section class="sectioning">
        <h3 class="contextual-heading" style="font-size: NaNrem;">Methods</h3>
        <p>
          The recognition object also has 3 methods in charge of whether it is actively listening and feeding things to the above events:
        </p>

        <ul>
          <li><code>start</code></li>
          <li><code>stop</code></li>
          <li><code>abort</code></li>
        </ul>

        <p>
          If you're wondering what the difference between <em>stop</em> and <em>abort</em> is, it's actually pretty simple.: Stop means stop listening, but not stop processing and feeding any pending events to its listeners. Abort is a hard disconnect
          of all the things.
        </p>
      </section>

      <p>So, at it's most basic: You create a recognizer, add some listeners and call <code>.start()</code> and you should get some results until they are again disconnected (we'll come back to that in a moment)</p>

      <section class="sectioning">
        <h3 class="contextual-heading" style="font-size: NaNrem;">Starting up</h3>
        <p>Before we set up an example, it's worth explaining that this feature is "different". <em>Playing</em> some media is something that has been a part of the Web for a really long time, it's not something that requires a special permission. But
          <em>listening to your microphone</em> is different, as it should be. That's something that the user has to explicitly give permission for and be made aware when it's happening. As such, when you call <code>.start()</code> Chrome will ask the
          user if it's ok for this website to use the mic. Keep in mind, they could well say "no" so you'll want to prepare for that eventuality - it will call the error handler with the <code>event.error</code> property of <code>not-allowed</code>.</p>

        <p>Even this, however, is incomplete. "Ok to access the mic" is a pretty 'simple' answer, but it's far reaching. If I want to be able to click a field and speak into it (like Google search on Android), does that mean I am also giving permission to
          listen to the conversations in the room at all other times as long as there's a tab open? That sounds terrible in most use cases, but there are use cases that are kind of almost that. This is tricky to manage, as you can imagine, so the draft
          and implementation say that the UA (browser) has to indicate to the user when it is and isn't actually listening and it has to stop when the tab is no longer active. This can take a few different forms, and we'll come back to that - but generally
          speaking, Chrome on the desktop will (currently) give a user two indicators that distinguish the difference between these two things.</p>

        <div class="captioned-image" style="background-color: inherit;">
          <img src="../media/mic-permission-granted.png" alt=""> Once the user has given permission, in the right of the address bar, it will say it is accessing the mic. That doesn't mean actively listening for speech.<p></p>
    </div>

    <div class="captioned-image" style="background-color: inherit;">
      <img src="../media/actively-listening-to-mic.png" alt=""> Once we actively start listening, in the tab itself, it will show a red "recording" dot. This dot will disappear when we stop.<p></p>
    </div>

    <p class="note">I personally have trouble believing that the average user will really understand the difference without some training which could happen the first time the mic permission is granted or something, but I've never seen. I'm also not entirely sure how
      this translates for someone who can't actually see the screen, for example. This is interesting, because that is actually the default assumption on mobile so, on Android it will play audible listening/done listening tones. I'll come back to why
      this too is currently imperfect, but let's move one.</p>
    </section>

    <section class="sectioning">
      <h3 class="contextual-heading" style="font-size: NaNrem;">The most basic example</h3>
      <p>Alright, so now you know what to expect, as a user and we know basically what the API looks like, let's talk about code.</p>

      <pre><code class="language-javascript">
const recognition = new webkitSpeechRecognition(),
      basicExampleOut = document.querySelector('#basicExampleOut')

recognition.onerror = (evt) =&gt; {
    if (evt.error == 'not-allowed') {
        basicExampleOut.innerText =
            `I can't listen if you don't grant me permission :(`
    } else {
        basicExampleOut.innerText =
            `Whoops I got an ${evt.error} error`
    }
}

recognition.onresult = (evt) =&gt; {
    // What is this crazy thing?! Don't worry, we'll get to it.
    let whatIHeard = evt.results[0][0].transcript
    basicExampleOut.innerText = whatIHeard
}

recognition.start()
                </code></pre>
      <template>
                    <script>
                    (function () {
                        const recognition = new webkitSpeechRecognition(),
                              basicExampleOut = document.querySelector('#basicExampleOut')

                        recognition.onerror = (evt) => {
                            if (evt.error == 'not-allowed') {
                                basicExampleOut.innerText =
                                    `I can't listen if you don't grant me permission :(`
                            } else {
                                basicExampleOut.innerText =
                                    `Whoops I got an ${evt.error} error`
                            }
                        }

                        recognition.onresult = (evt) => {
                            // What is this crazy thing?! Don't worry, we'll get to it.
                            let whatIHeard = evt.results[0][0].transcript
                            basicExampleOut.innerText = whatIHeard
                        }

                        recognition.start()
                    }())
                    </script>
                </template>
      <button class="run">Run this and say something</button><span class="output" id="basicExampleOut">Some output will come here</span>

      <p>Note that once you got a result, it stopped listening for more results automatically. By default, this is how it works. Now let's talk about that crazy <code>evt.results[0][0].transcript</code> thing.</p>

      <section class="sectioning">
        <h4 class="contextual-heading" style="font-size: NaNrem;"><code>evt.results</code></h4>
        <p><code>evt.results</code> is, as you might have guessed a collection. Unfortunately, it is not a true <code>Array</code> (very sadly since other things in the TTS portions covered in previous articles are) but another weird array-like thing called
          a <code>SpeechRecognitionResults</code>. By default, it will have exactly one item. It contains, in turn, individial <code>SpeechRecognitionResult</code> objects.</p>


        <p>So just what is a <code>SpeechRecognitionResult</code>? <em>By default, its basically also an array-like with just one item</em> called a <code>SpeechRecognitionAlternative</code>. Wait what? I know, it seems weird, but stick with me...</p>

        <p><code>SpeechRecognitionAlternative</code> is really the 'thing' that you want and <code>.transcript</code> is the text it transcribed from what it heard on the mic. This object also has property called <code>confidence</code> which is a numeric
          value between 0 and 1 representing how confident the recogntion system is that it got that right.</p>

            <pre><code class="language-javascript">
recognition.onresult = (evt) =&gt; {
        // evt.results is an array-like collection of
        // SpeechRecognitionResult objects
    let speecRecognitionResults = evt.results,

        // it's a collection of exactly one by default (see below),
        // but that is also array-like
        speechReognitionAlternatives = speechRecognitionResults[0]

        // but that also contains by default exactly one
        alternative = speechRecognitionAlternatives[0]

        // and _that_ thing has all the properties
        console.log(alternative.transcript)

}
                            </code></pre>

        <p>You are undoubtedly thinking "Wow, why all the complexity?!" To understand this, you need to note that several times above I said "by default". That's because the draft also provides for other use cases and we really need go no further than this
          next property/example to see why..</p>

        <section class="sectioning">
            <h5 class="contextual-heading" style="font-size: NaNrem;">Max Alternatives</h5>

            <p>The recognizer we set up has a property called <code>maxAlternatives</code> which is a numeric value indicating how many alternatives we're willing to receive. Let's take the following example:</p>

            <pre><code class="language-javascript">
var recog = new webkitSpeechRecognition()
recog.maxAlternatives = 10
recog.onerror = (evt) =&gt; {
   debugger
}
recog.onresult = (evt) =&gt; {
   let alternatives = Array.from(evt.results[0])
   alternatives.forEach((result) =&gt; {
      console.log(
        `
        confidence: ${result.confidence}
        transcript: "${result.transcript}"
        `)
   })
}
recog.start()
            </code></pre>

            <p>If I run this in Chrome, on my desktop mac, and then say "Tutu" it will log something <em>like</em> this:</p>
            <pre><code class="output">confidence: 0.7706348896026611
transcript: "tutu"

confidence: 0.9056409001350403
transcript: "two two"

confidence: 0.9139654040336609
transcript: "to to"

confidence: 0.9311671257019043
transcript: "2 2"

confidence: 0.933784008026123
transcript: "- 2"

confidence: 0.9352703094482422
transcript: "too too"

confidence: 0.9483599662780762
transcript: "22"

confidence: 0.9183915853500366
transcript: "TuTiTu"

confidence: 0.9120156168937683
transcript: "to 2"

confidence: 0.9352703094482422
transcript: "tu tu"</code></pre>

                <p>If, however, I run the same code and say "Desmond Tutu", I get only a single result:</p>
                <pre><code class="output">confidence: 0.9614496827125549
        transcript: "Desmond Tutu"</code></pre>
                <p>So, as you can see, speech can be ambiguous and depending on the quality of the implementation of the thing transcribing speech and the amount of context you hand them, the quality of the mic and the voice/pronounciation/accent of the speaker, they may be able to, or want to give you alternatives if they can't be very sure.  And - well - if you're into that sort of thing and prepared to deal with that yourself, that's pretty cool.</p>

                <p>Ok, but what about that <code>SpeechRecognitionResults</code> thing... Why is <em>that</em> an array-like??  Why do we still grab the first one in that last example?  Hang in there...</p>
            </section>

            <section class="sectioning">
                <h5 class="contextual-heading" style="font-size: NaNrem;"><code>.continuous</code></h5>
                <p>The recognizer you create also has a <code>.continuous</code> property which, by default is false.  The idea is that there are use cases (like dictation) in which once the user has indicated that they want the program to start listening, we do not actually want it to stop (or miss anything) until it's told to. That's "continuous mode".</p>

                <p>If the "continuous mode" flag is set then <code>evt.results</code> will have one more item each time and you'll want the <code>evt.results[evt.results.length-1]</code> to get 'this one'.</p>

                <p class="note">Chrome on the desktop's implementation is buggy and shows it still
                recording after page refresh despite the fact that you have no way to now tell it to stop
                or to get the results it's grabbing anymore.  Basically, you have to kill the tab to
                get it to stop as far as I can tell, which seems awful.</p>


                <p class="note">Firefox doesn't support this.  They say you can have the handling of one
                result just start listening again.  That is indeed much simpler, probably much easier on
                the memory and very nearly approximate - except on mobile where start/stop listening
                is accompanied by audible tones.</p>

            </section>
        </section>


        <section class="sectioning">
            <h4 class="contextual-heading" style="font-size: NaNrem;">"Other" bits</h4>
            <p><code>SpeechRecognition</code> (the recognizer object you create) has some 'other bits' too...</p>


            <p>There's a <code>.lang</code> property.  Like speech, it defaults to the document language and can be a string representing a <a href="http://www.rfc-editor.org/rfc/bcp/bcp47.txt">BCP 47 language tag</a> (like en-US) which changes the dictionaries it's recognizing against.  So, setting it to <code>it</code>, will make it recognize Italian, but not English or Japanese.</p>

            <p class="note">As it was with utterances, setting this to something invalid, like for example,
            "Pittsburghese" will simply cause it to use the default.</p>

            <p>There's a <code>.serviceURI</code> property which is supposed to let you
            choose which recognition service to use if not the default one.
            In theory, being a <code>URI</code> it can be either a
            local service or a remote URL. </p>

            <p class="note"> In theory, it would also "work" - but it seems to be ignored
            entirely in Chrome and so I see little point in saying much more about it here.</p>

            <p>There's a <code>.grammars</code> property which is another array-like called a <code>SpeechGrammarList</code> with two methods for modifying it: <code>.addFromURI(in DOMString src,
                        optional float weight)</code> and <code>.addFromString(in DOMString string,
                        optional float weight)</code>.  The idea here is to allow you to express
                        domain specific grammars as a kind of weighted rule-set.</p>
            <p class="note">As near as I can tell, here's what the draft as to say about what grammars are supported: <code style="font-style: normal" aria-hidden="true">¯\_(ツ)_/¯</code><span class="sr-only">shrug</span>.
            You'll see some examples (for example on MDN) that show these using, for example, JSGF (Java Speech Grammar Format).  Note, that's not really a 'standard' as far as I can tell either, there's a W3C note about it. In any case, it's unspecified currently how it will work <em>without</em> a grammar or entirely how those should work and <em>in practice</em> in Chrome I was unable to find any difference at all whether you set it or not, so again, little point in saying more about it here and now beyond that.</p>

        </section>

    </section>

    <section class="sectioning">
      <h3 class="contextual-heading" style="font-size: NaNrem;">Wrapping up</h3>
      <p>So, it's interesting.  It works experimentally, if you can use only the parts that work.  It isn't nearly as far along 'in practice' as the text-to-speech APIs and even the limited implementations we have have some wonky bits... In my next post, I'll talk about how I am dealing with the wonky bits of this,
      and putting together some interesting things you can do with it.
      </p>
    </section>

  </section>
  <p class="thanksTo">Special thanks to my friend, the great Chris Wilson for proofing/commenting on pieces in this series.</p>

]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[You Don't Say: Web Speech APIs Part II]]></title>
        <id>https://bkardell.com/blog/Basic-Voice-Speaker.html</id>
        <link href="https://bkardell.com/blog/Basic-Voice-Speaker.html">
        </link>
        <updated>2017-08-24T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[This is part of a series about making the browser speak and listen to speech.  In my last post Greetings, Professor Falken: Web Speech APIs Part I, I talked about the existing APIs we "have" for speaking (as well as why the air quotes) and all the many ways that they are wonky today.  In this post I'll share some of my own opinions on that API, as well as how I'm dealing with the speaking part IRL.]]></summary>
        <content type="html"><![CDATA[
    <h1 class="contextual-heading" style="font-size: NaNrem;">You Don't Say: Web Speech APIs Part II</h1>
    <p class="segue">This is part of a series about making the browser speak and listen to speech.  In my last post <a href="https://bkardell.com/blog/Greetings-Professor-Falken.html">Greetings, Professor Falken: Web Speech APIs Part I</a>, I talked about the existing APIs we "have" for speaking (as well as why the air quotes) and all the many ways that they are wonky today.  In this post I'll share some of my own opinions on that API, as well as how I'm dealing with the <em>speaking</em> part IRL.</p>

    <script src="../prism.js"></script>
    <link rel="stylesheet" href="../prism.css">
    <script src="../test/speaking/basic-voice-speaker-ii.js"></script>
    
    

    <p>So, we have these wonky APIs implemented inconsistently in a lot of browsers.  We know how to deal with that, we've done it before.  I'd like to review our options to explain how I think it makes sense to approach this:</p>

    <ul id="options">
        <li>We could just monkeypatch something which makes these precise APIs (or at least some subset) actually work consistently in all browsers.  It's way too early to consider doing this in my opinion and probably does more harm than good as we begin to eliminate options for real implementations/standards.  Let's not do that.</li>
        <li>We could develop an alternately named polyfill which does just that - instead of dealing with <code>speechSynthesis</code> for example, you'd deal with <code>_speechSynthesis</code>.  That could be interesting, but I'm not sure the API is actually that great to begin with as I'll explain below, so maybe that's not a great option at this stage either.</li>
        <li>We could develop a new proposal with its own "speculative polyfill" or "prollyfill" following <a href="https://www.w3.org/2001/tag/doc/polyfills/#advice-for-polyfill-authors">excellent advice by the W3C TAG</a> in how we do that and <a href="https://extensiblewebmanifesto.org">#extendthewebforward</a>. This seems very plausible, but I think we're getting kind of ahead of ourselves even there.</li>
        <li>We could make some libraries following the same advice that hope to become proposals after initiating a lot of discussion and showing that they are, in fact, pretty well thought out and handy.  This is where I think we are.</li>
    </ul>

    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: NaNrem;">What's wrong with the current API?</h2>
        <p><em>Note: These are just my personal opinions after using it a lot for the past couple of months.</em></p>
        <p>Let's assume that the API worked consistently, as advertised by the existing draft, across browsers and devices.  Would it be what we really want or need.  I think that, actually, the answer is no.  </p>

        <section class="sectioning">
            <h3 class="contextual-heading" style="font-size: NaNrem;">How low can you go?</h3>
            <p>On the one hand, it's intending to be a low level API, but here I feel like it still falls a little short.  Speech is sound, and yet it's not clear to me how this really fits into the audio architecture.  There was very brief disussion of this, but to not seems like a failure to me.  For example, here's a nifty demo from MDN that allows you to <a href="https://mdn.github.io/voice-change-o-matic/">add effects to your voice with input from the mic</a> by connecting it to an audio stream which gets processed to add things like reverb.  However, the draft nor implementation seem to have no way to intercept the audio stream generated by <code>speechSynthesis</code>.  This seems like a shame because the set of things that you could do there is nearly unbounded, whereas the set of things you can do with the existing levers is exceptionally finite.  In my own use cases, I really wanted those abilitites.  Similarly, the most handy of them (pitch, rate, volume) overlap.  Surely there is something 'down there' that deserves explanation.  If these were done 'in post' there's no reason that any voice shouldn't support those.  So, I think we need more there.</p>

            <p>It seems to me there could easily be an 'audiocreated' callback or something which gave you a chance to deal with the audio itself instead of just piping it to the speakers.</p>
        </section>

        <section class="sectioning">
            <h3 class="contextual-heading" style="font-size: NaNrem;">Off to the races</h3>
            <p>Ok, so it's not the low-level API I'd like it to be, but there's a lot of room for improvement at higher levels too...</p>
            <p>As I explained, <code>.getVoices</code> is weird.  It's kind of typical Web weird in that listeners for events like <code>DOMContentLoaded</code> are also historically racey.  The rationale, I believe, is that remote voices may or may not be available and that can actually change through the duration of your program.  If you've ever used Google Maps Navigation you might have heard the speech change - I beleive that's what's going on there.  But it feels like we should be past this as we have had <code>Promises</code> for some time and the two can co-exist.  Most of the time what we really want to know is "have some voices loaded or not" and managing and guarding against that seems unnecessarily complicated.  You can't put something into the queue with <code>speechSynthesis.speak()</code> until you have an utterance.  You can't create an utterance until you have voices.  You can't simply grab voices because they might not be loaded yet, you can't listen for voices to change if they <em>are</em> already loaded and, in theory, even once something is queued you could lose it before it is actually processed.</p>
            <p>This is a lot to ask the average author to understand how to get right in my opinion.</p>
            <p>It seems to me that since we can't 'speak' without a voice, whatever logic you are going to use to choose a voice from the available set should be available to the queue itself so that it can choose at the moment just before creating the audio.  This would solve a whole lot.  It also seems to me that <code>speechSynthesis.speak()</code> should return a promise representing completion or failure of the whole transaction (basically, end or error).  For many common cases, this is all we really care about and is kind of analogus to the fact that XHR contains many 'shades of gray' status changes, but the most successful AJAX abstractions had a simpler pass/fail promise on the entire transaction.</p>
        </section>

        <section class="sectioning">
            <h3 class="contextual-heading" style="font-size: NaNrem;">Immutable?</h3>
            <p>The fact that you create an instance of an utterance and then set properties seems to lead to a lot of confusion, it's kind of hard to read too.  It definitely seems to me that it would be very handy for it to take an options/config object like <code>MutationObserver</code> and then be immutable properties. Generally speaking, I'm not sure what you would hope to 'do' with an utterance once it has been created except put it in the queue or take it out of the queue and having it present you with an API that throws at some times and not others seems to be begging for classes of problems we don't really neeed.</p>
        </section>

        <section class="sectioning">
            <h3 class="contextual-heading" style="font-size: NaNrem;">Reuse</h3>
            <p>Think for a moment of the choice of voice, the pitch, rate and volume as a "speaker".  In my own
            uses I found that I wanted to reuse these - either to have a single speaker I used all the time, or
            a few speakers that I wanted to variously "say" things. In the current incarnation, this was kind of more painful than I would like because I had to build up things aware of all the quirks above.</p>
        </section>

        <section class="sectioning">
            <h3 class="contextual-heading" style="font-size: NaNrem;">What I did</h3>
            <p>So, for me, I ended up building something very close to the above that allows me to do simple things simply... Here are some examples.
            </p>

            <section class="sectioning">
                <h4 class="contextual-heading" style="font-size: NaNrem;">Look, just say something...</h4>
                <p>The simplest case is that you just want to say something and you don't care about anything else.  To be honest, that was pretty simple before too, unless you wanted to say something long, because there were problems with that, or you cared that it might be defaulting you to some voice that wasn't even in the right language.. but here's what it looks like for me, and it works with long text by chopping it up at hopefully sensible points and chaining them together, selecting
                a voice by default that is at least in the same major language as the document.</p>
                <pre><code class="language-javascript">
new BasicVoiceSpeaker().say(`
    To be, or not to be, that is the question:
    Whether 'tis nobler in the mind to suffer
    The slings and arrows of outrageous fortune,
    Or to take Arms against a Sea of troubles,
    And by opposing end them: to die, to sleep
    No more; and by a sleep, to say we end
    the heart-ache, and the thousand natural shocks
    that Flesh is heir to? 'Tis a consummation
    devoutly to be wished. To die, to sleep,
    To sleep, perchance to Dream; aye, there's the rub.
`)
                </code></pre>
                <template>
                    <script>new BasicVoiceSpeaker().say(`
    To be, or not to be, that is the question:
    Whether 'tis nobler in the mind to suffer
    The slings and arrows of outrageous fortune,
    Or to take Arms against a Sea of troubles,
    And by opposing end them: to die, to sleep
    No more; and by a sleep, to say we end
    the heart-ache, and the thousand natural shocks
    that Flesh is heir to? 'Tis a consummation
    devoutly to be wished. To die, to sleep,
    To sleep, perchance to Dream; aye, there's the rub.
`)</script>
                </template>
                <button class="run">Run this</button>
            </section>

            <section class="sectioning">
                <h4 class="contextual-heading" style="font-size: NaNrem;">Can you take me higher?</h4>
                <p>But I can configure my speaker as described above, and reuse it.  They queue in order.</p>
                <pre><code class="language-javascript">
let speaker = new BasicVoiceSpeaker({
    rate: 0.8,
    pitch: 1.2
})
speaker.say(`Greetings, Professor Faulken.`)
speaker.say(`Would you like to play a game?`)
                </code></pre>
                <template>
                    <script>let speaker = new BasicVoiceSpeaker({
    rate: 0.8,
    pitch: 1.2
})
speaker.say(`Greetings, Professor Faulken.`)
speaker.say(`Would you like to play a game?`)
</script>
                </template>
                <button class="run">Run this</button>
            </section>
        </section>

        <section class="sectioning">
            <h3 class="contextual-heading" style="font-size: NaNrem;">Voices</h3>
            <p>Of course, all the crap with loading the voices/finding one
            are what you really want to be easier, so there is a <code>.filter</code>
            property that passes you the voices at the right time and lets you
            use whatever means you like to find one and return the one you want.
            If it doesn't return anything, it'll just use the first voice in voices that
            matches the preferred language of the document. If it can't find even that,
            It'll just pick the first voice.</p>
            <pre><code class="language-javascript">let joshua = new BasicVoiceSpeaker({
    rate: 0.8,
    pitch: 1.2,
    filter: (voices) =&gt; {
        // keeping this overly simple for the example
        return voices.find((v) =&gt; { return /vox/.test(v.name) })
    }
})
joshua.say('A strange game.')
joshua.say('The only winning move is not to play...')
joshua.say('How about a nice game of chess?')
</code></pre>
            <template>
                <script>(function () {
                    let joshua = new BasicVoiceSpeaker({
                        rate: 0.8,
                        pitch: 1.2,
                        filter: (voices) => {
                            // In here you can do whatever complex stuff you like
                            // to find the voice you're going to use... I'm
                            // keeping it simple here for the example.  If this
                            // voice isn't found, it will just use the first voice
                            // in voices
                            return voices.find((v) => { return /vox/.test(v.name) })
                        }
                    })
                    joshua.say('A strange game.')
                    joshua.say('The only winning move is not to play...')
                    joshua.say('How about a nice game of chess?')

                    }())</script>
            </template>
            <button class="run">Run this</button>


            <p>For what it's worth though, I found that most of the time what I really want
                 to do is test against a number of regexps in preferential order searching
                 for something and it's verbose and redundant... To be honest, I'm not
                 really sure what else you <em>could do</em>.  Because of this, I added some
                 sugar where you can pass an array of objects with critera about
                 which property (name or lang) you want to check and a regular expressions.
                 It uses these to search, in order and just avoids all that redundant/potentially
                 complicated/verbose function writing. What I'd really
                 write, most of the time, is something more like this..</p>
                 <pre><code class="language-javascript">
let speaker = new BasicVoiceSpeaker({
    // Here are several options, in order
    filter: [{name: /vox/}, {name: /noids/}, {name: /en-us/i}],
    pitch: 1.2
})
speaker.say(`D.O.D. pension files indicate current mailing as:`)
speaker.say(`Dr. Robert Hume, a.k.a. Stephen W. Falken, 5 Tall Cedar Road, Goose Island, Oregon 97`)
                </code></pre>
                <template>
                    <script>(function () {
let speaker = new BasicVoiceSpeaker({
    // Here are several options, in order
    filter: [{name: /vox/}, {name: /noids/}, {name: /en-us/i}],
    pitch: 1.2
})
speaker.say(`D.O.D. pension files indicate current mailing as:`)
speaker.say(`Dr. Robert Hume, a.k.a. Stephen W. Falken, 5 Tall Cedar Road, Goose Island, Oregon 97`)
}())
                   </script>
                </template>
                <button class="run">Run this</button>

        </section>

        <section class="sectioning">
            <h3 class="contextual-heading" style="font-size: NaNrem;">Queing and Promises</h3>
            <p>Each call to <code>.say(..)</code> also returns a promise, which is
            resolved when the entire text is spoken (even if it had to be chopped up),
            so you can kind of mostly have a synchronous looking block of calls that
            do what you expect them to do, but do it async, and you can still
            then do whatever larger coordination with those promises too...</p>

              <pre><code class="language-javascript">
// Just a simple conversation back and forth between
// two actors: An en-US person and one I've given
// several acceptable voices to search for, in order

let englishSpeaker = new BasicVoiceSpeaker({
    filter: [{ lang: /en-US/ })
})

let italianSpeaker = new BasicVoiceSpeaker({
    filter: [
        {lang: /it/},
        {name: /victoria/},
        {name: /vicki/},
        {name: /female/}
    ]
})

Promise.all([
    englishSpeaker.say(`How do you say "Good evening" in Italian?`),
    italianSpeaker.say(`We say "Buonasera"`),
    englishSpeaker.say(`Baynostera?`),
    italianSpeaker.say(`No, "Buonasera", try again.`),
    englishSpeaker.say(`Bwohnah sehrah?`),
    italianSpeaker.say(`si!! Molto bene!! Very good!!`)
]).then(() =&gt; {
    document.querySelector('#convo-sample-out').innerText = 'All done speaking'
})
              </code></pre>
              <template><script>
                (function () {
                    let englishSpeaker = new BasicVoiceSpeaker({
                        filter: (voices) => {
                            // this one just has to be en-US
                            return voices.find((v) => { return /en-US/.test(v.lang) })
                        }
                    })
                    let italianSpeaker = new BasicVoiceSpeaker({
                        filter: (voices) => {
                            // Mostly, I just want an italian voice
                            let italianVoice = voices.find((v) => {
                                return /it/.test(v.lang)
                            })
                            // If I can't have that, here are some fallbacks..
                            if (!italianVoice) {
                                italianVoice = voices.find((v) => {
                                    return /vicki|victoria|female/i.test(v.name)
                                })
                            }
                            return italianVoice
                        }
                    })
                    Promise.all([
                        englishSpeaker.say(`How do you say "Good evening" in Italian?`),
                        italianSpeaker.say(`We say "Buonasera"`),
                        englishSpeaker.say(`Baynostera?`),
                        italianSpeaker.say(`No, "Buonasera", try again.`),
                        englishSpeaker.say(`Bwohnah sehrah?`),
                        italianSpeaker.say(`si!! Molto bene!! Very good!!`)
                    ]).then(() => {
                        document.querySelector('#convo-sample-out').innerText = 'All done speaking'
                    })

                }())
              </script></template>
              <button class="run">Run this</button><span class="output" id="convo-sample-out">Some output should show here</span>

        </section>

        <section class="sectioning">
            <h3 class="contextual-heading" style="font-size: NaNrem;">Wrapping up</h3>
            <p>So, this is 'at the bottom' of what I'm using and why.
            It still doesn't even attempt to deal with the
            whole audio stream thing. I'm not sure how to deal with that, but one thing I considered
            through all this is that you could probably record from the mic and then also offer the
            ability to capture that as bits you could then write out and save and then reload
            as simple sound.  This might have uses if you have a tight script and really want to
            guarantee the voices are what you want them to be and even have the ability to
            mix or post process them, but... meh.</p>

            <p>The <a href="https://gist.github.com/bkardell/abd9edf8ae80ec06eef13ee2d63b3b61">code</a> is still early, it's not a 'finished piece'.  It's still rough around the edges and evolving, but that's ok because I'm really just trying to start a conversation and get people thinking and
            talking about speech again.  In my <a href="https://bkardell.com/blog/Listen-Up.html">next post</a> I'll start dissussing the more complex
            end of all this, <em>listening</em> and how that actually also potentially complicates this
            problem in intersting way.</p>


        </section>

    </section>
    <p class="thanksTo">Special thanks to my friend, the great Chris Wilson for proofing/commenting on pieces in this series.</p>

]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Greetings, Professor Falken: Web Speech APIs Part I]]></title>
        <id>https://bkardell.com/blog/Greetings-Professor-Falken.html</id>
        <link href="https://bkardell.com/blog/Greetings-Professor-Falken.html">
        </link>
        <updated>2017-08-23T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[There's a long, rich history of humans figuring out how to make machines talk and listen, and nearly as long as there has been a W3C there have been efforts to get these features into the browser.  It's too complicated to recount here, that's a whole post of it's own.  Suffice it to say that it's been fits and starts, steps forward and back and where we are right now is... muddy, but it works... sort of.  In this series of posts, I'll tell you all about it...]]></summary>
        <content type="html"><![CDATA[
    <h1 class="contextual-heading" style="font-size: NaNrem;">Greetings, Professor Falken: Web Speech APIs Part I</h1>
    <p class="segue">There's a long, rich history of humans figuring out how to make machines talk and listen, and nearly as long as there has been a W3C there have been efforts to get these features into the browser.  It's too complicated to recount here, that's <a href="http://bkardell.com/blog/The-History-Of-Speech.html">a whole post of it's own</a>.  Suffice it to say that it's been fits and starts, steps forward and back and where we are right now is... muddy, but it works... sort of.  In this series of posts, I'll tell you all about it...</p>
    <script src="../prism.js"></script>
    <link rel="stylesheet" href="../prism.css">
    
    
    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: NaNrem;">The Current State of things</h2>
        <p>The bad news first:  There <em>have</em> been several "official standards" that aren't ultimately giving us speech in browsers.  There is no Speech API for the browser currently on any standards track.</p>

        <p>The good news: There have been unofficial proposals and experiments that give us some (not insignifiant) degree of speech in all modern browsers and <em>together, we can change the 'unofficial' part if we want that</em>. </p>

        <p>In 2012, Google shipped an implementation of an <a href="https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html">unofficial API proposal</a> developed in a community group.  Other vendors have since shipped parts of mostly the same API despite it not being on a formal standards track.</p>

        <p>The draft contains a number of errata and the implementations don't all agree entirely.  Since it's unofficial and a Note, they aren't really updating the draft and making it better isn't exactly the highest priority.</p>

        <p>There's some more good news in that this is a fairly low-level interface, allowing us to experiment atop it and inform standards, <a href="https://extensiblewebmanifesto.org/">The Extensible Web Manifesto</a> style.  If we can renew interest, perhaps we can get it on a legitimate a standards track and work out the kinks.</p>
    </section>

    <section class="sectioning">
        <h2 class="contextual-heading" style="font-size: NaNrem;">Utterly Basic</h2>
        <p>Probably the simplest thing you might want to do is have your page say something.  You do this by creating a <code>SpeechSynthesisUtterance</code> for those words and handing that to the <code>speechSynthesis.speak(...)</code> method.</p>

        <pre><code class="language-javascript">// I'll explain later why I'm misspelling Falken
speechSynthesis.speak(
  new SpeechSynthesisUtterance(
    'Greetings, Professor Faulken'
  )
)</code></pre>
        <template><script>
            (function () {
                speechSynthesis.speak(
                  new SpeechSynthesisUtterance(
                    'Greetings, Professor Faulken'
                  )
                )
            }())
        </script></template>
        <button class="run">Run this</button>

        <p>On this, everyone agrees and yay that is pretty easy! Congraulations, we have easily achieved 1983 <em>War Games</em> speech technology!</p>

        <p class="note">From here on, I'll just refer to <code>SpeechSynthesisUtterance</code> as an 'utterance', because that is a lot easier on the eyeballs.</p>

        <p>Once you have constructed an utterance, you can mess with several properties before passing it off to be spoken.  What we've seen here is just using defaults, and the defaults will vary from machine to machine.  All you can <em>really</em> say for sure is that that will be said (well... almost for sure, but we'll come back to that).</p>

        <section class="sectioning">
            <h3 class="contextual-heading" style="font-size: NaNrem;">Pitch, rate and volume</h3>
            <p>The most basic properties are:</p>
                <ul>
                    <li><code>.pitch</code> (a float from 0 to 2, defaults to 1)</li>
                    <li><code>.rate</code>  (a float from 0.1 to 10, defaults to 1)</li>
                    <li><code>.volume</code> (a float from 0 to 1, defaults to 1).</li>
                </ul>

            <p class="note">If these ranges seem unnecessarily arbitrary and confusing to you, all I can say is: same.</p>

            <p>Let's try varying it a little and pay tribute to Freddie Mercury...</p>

            <pre><code class="language-javascript">let one = new SpeechSynthesisUtterance(
    `My money, that's all you wanna talk about.`
)
one.pitch = 2
speechSynthesis.speak(one)

let two = new SpeechSynthesisUtterance(`
    But I'm no fool`
)
two.pitch = 1.5
speechSynthesis.speak(two)


let three = new SpeechSynthesisUtterance(
    `It's in the lap of the Gods`
)
three.pitch = 0.25
three.rate = 0.5
speechSynthesis.speak(three)
            </code></pre>
            <template>
                <script>
                    (function () {
                        let one = new SpeechSynthesisUtterance(
                            `My money, that's all you wanna talk about.`
                        )
                        one.pitch = 2
                        speechSynthesis.speak(one)

                        let two = new SpeechSynthesisUtterance(`
                            But I'm no fool`
                        )
                        two.pitch = 1.5
                        speechSynthesis.speak(two)


                        let three = new SpeechSynthesisUtterance(
                            `It's in the lap of the Gods`
                        )
                        three.pitch = 0.25
                        three.rate = 0.5
                        speechSynthesis.speak(three)
                    }())
                </script>
            </template>
            <button class="run">Run this</button>

        <section class="sectioning">
            <h4 class="contextual-heading" style="font-size: NaNrem;">Queueing</h4>

            The <code>speak(...)</code> method is asynchronous.  It returns immediately and <code>speechSynthesis</code> manages a queue of utterances that are intended to be spoken.<p></p>


        <p><code>speechSynthesis</code> is responsible for the queue and exposes some queue related methods (like <code>.pause()</code> <code>.resume()</code> and <code>.cancel()</code> (which clears the queue), all of which are async.  Now, this can get a little confusing if you don't understand what's happening, especially since it's a little buggy (a lot in some cases).</p>

        <p>According to the draft:

        <span class="spec-quote">
            [on .speak()'ing an utterance] The SpeechSynthesis object takes exclusive ownership of the SpeechSynthesisUtterance object. Passing it as a speak() argument to another SpeechSynthesis object should throw an exception.
        </span>

         In practice though, no one seems to have implemented this, and it doesn't throw.  What this means is that at until <em>some point</em>  you can still modify (certain) properties of the utterance in the queue as long as you have a reference to it, but what happens depends on whether it's been processed at all yet.
        </p>

        <p>Let's look at at a kind of circuitous example with some Neil Young lyrics that illustrates how this can get confusing...</p>

        <pre><code class="language-javascript">
let utteranceOne = new SpeechSynthesisUtterance(
      `My My, Hey Hey`
    ),
    utteranceTwo = new SpeechSynthesisUtterance(
      `Rock and Roll is here to stay`
    ),
    utteranceThree = new SpeechSynthesisUtterance(
      `It's better to burn out`
    ),
    utteranceFour = new SpeechSynthesisUtterance(
      `Than to fade away`
    )

speechSynthesis.speak(utteranceOne)

/* Changing what we've asked to be
  spoken after queueing.. It should
  throw, but it doesn't.  Will
  it be higher pitched? */
utteranceOne.pitch = 2

speechSynthesis.speak(utteranceTwo)

/* Changing this one too, will it? */
utteranceTwo.pitch = 2

speechSynthesis.speak(utteranceThree)
speechSynthesis.speak(utteranceFour)

console.log(
  `this will log immediately
   before anything is spoken
   because it's async`)

/* pause will actually happen before
  anything can be spoken */
speechSynthesis.pause()

setTimeout(() =&gt; {
    // this will begin processing again
    // in ~ 2 secons..
    // but what will the rate of each be?
    console.log(`resuming...`)
    speechSynthesis.resume()
}, 2000)
        </code></pre>
        <template>
            <script>(function () {
                let utteranceOne = new SpeechSynthesisUtterance(
                      `My My, Hey Hey`
                    ),
                    utteranceTwo = new SpeechSynthesisUtterance(
                      `Rock and Roll is here to stay`
                    ),
                    utteranceThree = new SpeechSynthesisUtterance(
                      `It's better to burn out`
                    ),
                    utteranceFour = new SpeechSynthesisUtterance(
                      `Than to fade away`
                    )

                speechSynthesis.speak(utteranceOne)

                /* Changing what we've asked to be
                  spoken after queueing.. It should
                  throw, but it doesn't.  Will
                  it be higher pitched? */
                utteranceOne.pitch = 2

                speechSynthesis.speak(utteranceTwo)

                /* Changing this one too, will it? */
                utteranceTwo.pitch = 2

                speechSynthesis.speak(utteranceThree)
                speechSynthesis.speak(utteranceFour)

                console.log(
                  `this will log immediately
                   before anything is spoken
                   because it's async`)

                /* pause will actually happen before
                  anything can be spoken */
                speechSynthesis.pause()

                setTimeout(() => {
                    // this will begin processing again
                    // in ~ 2 secons..
                    // but what will the rate of each be?
                    console.log(`resuming...`)
                    speechSynthesis.resume()
                }, 2000)
            }())</script>
        </template>
        <button class="run">Run this (it will take time to speak)</button>
        <p>Did it work? Hard to say, see the notes below. Don't let any of this confuse you into trying to change an utterance once you've sent it to speak, just consider it immutable from your perspective and your life will be a lot happier.</p>

        <p class="note">In Chrome (desktop, mac) at the time of this writing the <code>speechSynthesis</code> queue appears to be effectively shared at a very low level, meaning that it translates between requests and across domains.  If anyone has called <code>speechSynthesis.pause()</code>, whatever you add to the queue won't get spoken until it is unpaused, and then it is subject to coming after whatever is already in the queue, no matter where it came from. I'm not going to demo this as it's likely to only cause confusion, but if something suddenly isn't working and your browser supports speech, try running <code>speechSynthesis.resume()</code> in the console and see what happens.</p>

        <p class="note" id="pause-on-android">If you're on Chrome on Android, this probably didn't work, worse - if you go back, run the first example, it won't work either.  <code>.resume()</code> doesn't actually seem to work.  Don't panic, just click this button to <button class="cancel">restore normalcy</button>.  How did I do this?  <code>speechSynthesis.cancel()</code> to clear the queue.  Unfortunately, I swear I have seen cancel actually resume and speak out stuff that was queued, but I can't find a case that illustrates it.</p>

        <section class="sectioning">
            <h5 class="contextual-heading" style="font-size: NaNrem;">Utterance Events</h5>
            <p>
                Because everything is async, if you wanted to do something like sync up some UI
                with spoken text, you'll need to know when things happen by watching for events
                on the utterance.  Utterances have several events: The ones you probably most care
                about are:
                </p><ul>
                    <li><code>onstart</code> "Fired when this utterance has begun to be spoken"</li>
                    <li><code>onend</code> "Fired when this utterance has completed being spoken.  If this event fires, the error event must not be fired for this utterance."</li>
                    <li><code>onerror</code> "Fired if there was an error that prevented successful speaking of this utterance. If this event fires, the end event must not be fired for this utterance" We'll come back to this one...</li>
                </ul>
            <p></p>

            <p>Let's try it out...</p>
            <pre><code class="language-javascript">
let utteranceOne = new SpeechSynthesisUtterance(
      `We come from the land of the ice and snow`
  ),
  utteranceTwo = new SpeechSynthesisUtterance(
      `From the midnight sun where the hot springs flow`
  ),
  syncUIHandler = (event) =&gt; {
    // There is an event.utterance in chrome,
    // but that seems to be non-standard,
    // you want event.target which is the
    // utterance object (though it should be read-only)
    document.querySelector('#zepplin-out').innerText = event.target.text
  }

  utteranceOne.onstart = syncUIHandler
  utteranceTwo.onstart = syncUIHandler

  utteranceTwo.onend = () =&gt; {
    console.log('done')
  }

speechSynthesis.speak(utteranceOne)
speechSynthesis.speak(utteranceTwo)
        </code></pre>
        <template><script>
            (function () {
                let utteranceOne = new SpeechSynthesisUtterance(
                      `We come from the land of the ice and snow`
                  ),
                  utteranceTwo = new SpeechSynthesisUtterance(
                      `From the midnight sun where the hot springs flow`
                  ),
                  syncUIHandler = (event) => {
                    // event.utterance in chrome, event.target
                    document.querySelector('#zepplin-out').innerText = event.target.text
                  }

                  utteranceOne.onstart = syncUIHandler
                  utteranceTwo.onstart = syncUIHandler

                  utteranceTwo.onend = () => {
                    console.log('done')
                  }

                speechSynthesis.speak(utteranceOne)
                speechSynthesis.speak(utteranceTwo)
            }())
        </script></template>
        <button class="run">Run this</button><span class="output" id="zepplin-out">You'll see some output here</span>

        <p>Assuming that that worked for you:  Yay!  Couldn't be simpler, right?  Got your head well around that?  Good... Ok, now let me explain why you probably don't.</p>

        <p>I think that most people would associate the words "when this utterance has begun to be spoken" with "some kind of sound has begun to flow out of the speakers" but this isn't the case.  If we added a <code>speechSynthesis.pause()</code> to the end of that code sample, the first utterance's <code>.onstart</code> would be called, and the words would appear on the screen, but no sound would play.  This is universal in all the browsers.  Luckily, there ares are also <code>.onpause</code> and <code>.onresume</code> events (but recall, if <code>pause</code> didn't work for you above, this one won't either).  Let's see...</p>

        <pre><code class="language-javascript">
let utteranceOne = new SpeechSynthesisUtterance(
      `Maybe it's not too late`
  ),
  utteranceTwo = new SpeechSynthesisUtterance(
      `To learn how to love, and forget how to hate`
  ),
  syncUIHandler = (event) =&gt; {
    let el = document.querySelector('#ozzy-out')

    if (event.type == 'pause') {
      el.innerText = 'Paused'
    } else {
      // Chrome has an event.utterance object,
      // but other browsers don't
      el.innerText = event.target.text
    }
  }

  utteranceOne.onpause = syncUIHandler
  utteranceOne.onstart = syncUIHandler
  utteranceOne.onresume = syncUIHandler
  utteranceTwo.onstart = syncUIHandler
  utteranceTwo.onpause = syncUIHandler
  utteranceTwo.onresume = syncUIHandler

speechSynthesis.speak(utteranceOne)
speechSynthesis.speak(utteranceTwo)
speechSynthesis.pause()

setTimeout(() =&gt; {
    speechSynthesis.resume()
}, 2000)
        </code></pre>
        <template><script>
            (function () {
                let utteranceOne = new SpeechSynthesisUtterance(
                          `Maybe it's not too late`
                      ),
                      utteranceTwo = new SpeechSynthesisUtterance(
                          `To learn how to love, and forget how to hate`
                      ),
                      syncUIHandler = (event) => {
                        let el = document.querySelector('#ozzy-out')
                        if (event.type == 'pause') {
                            el.innerText = 'Paused'
                        } else {
                            // Chrome has an event.utterance object,
                            // but other browsers don't
                            el.innerText = event.target.text
                        }
                      }

                      utteranceOne.onpause = syncUIHandler
                      utteranceOne.onstart = syncUIHandler
                      utteranceOne.onresume = syncUIHandler
                      utteranceTwo.onstart = syncUIHandler
                      utteranceTwo.onpause = syncUIHandler
                      utteranceTwo.onresume = syncUIHandler

                    speechSynthesis.speak(utteranceOne)
                    speechSynthesis.speak(utteranceTwo)
                    speechSynthesis.pause()

                    setTimeout(() => {
                        speechSynthesis.resume()
                    }, 2000)
                }())
        </script></template>
        <button class="run">Run this (it will take time to speak, if it does)</button><span class="output" id="ozzy-out">You'll see some output here</span>
        <p>Did it work?  Here's some bad news... there are a lot of notes here:</p>
        <p class="note">If you're on Android and nothing is happening, you might have missed <a href="#pause-on-android">the note about <code>.pause</code> not working right there.</a> and you should click this button to clear the queue and <button class="cancel">restore normalcy</button> (don't you wish that button worked on the whole world).</p>
        <p class="note">At least in Chrome (that's just the one I use most) it appears to be very easy to create situations where callbacks are not called, despite it being blatantly obvious that they happened. There have been a couple of bugs opened about this.  In my experience, this seems to be closely related to either the 'shared queue' note above or garbage collection causing utterance objects to be cleaned up before they are really fired because of longer text, so you've got to deal with all that yourself.</p>
        <p class="note">One more thing... If <code>.onError</code> is called, the event it raises will have an <code>.error</code> attribute (or, it's supposed to) which should be an error code indicating why.  The draft lists <a href="https://dvcs.w3.org/hg/speech-api/raw-file/tip/webspeechapi.html#speechsynthesiserrorevent">11 'kinds' of problems</a> and they are both informatice to the kinds of things you should be thinking about, but some of these don't seem to happen IRL and leave undefined spec behavior gaps.</p>
        </section>


        <section class="sectioning">
            <h5 class="contextual-heading" style="font-size: NaNrem;">Expressiveness</h5>
            <p>Speech is complicated if you want it to seem natural. In my <a href="https://bkardell.com/blog/The-History-Of-Speech.html">History of Speech</a> I link to a recording of Bell Lab's Voder in the 1940s demonstrating the many ways one might intone the phrase "she saw me".  Similarly, since we're just using strings of text, we're theoretically subject to all of the sorts of potential problems about ambigious strings. For example given the string "12/4 = 3" we'd probably like that to be pronounced "twelve divided by four equals three" whereas we might like "12/12/2012" to be pronounced like "December twelfth, twenty twelve".</p>

            <p>The first bit of good news is that all of the speech synthesis implementations I've tried actually do a <em>pretty good job</em> using punctuation to inflect and pause and frequently can deal with a lot of those problems automatically... For example, all of the below pronouce sensibly for me without further effort:

                        </p><pre><code class="language-javascript">speechSynthesis.speak(
  new SpeechSynthesisUtterance(`
    1. Pi is about 3.14
    2. We loaded the 4x4
    3. Please meet me at 3.14pm EST
    4. My birthday is 2/17/1974
  `)
)
            </code></pre>
            <template><script>
                (function () {
                    speechSynthesis.speak(
                      new SpeechSynthesisUtterance(`
                        1. Pi is about 3.14
                        2. We loaded the 4x4
                        3. Please meet me at 3.14pm EST
                        4. My birthday is 2/17/1974
                      `)
                    )
                }())
            </script></template>
            <button class="run">Run this</button>

            <p>But it's not bullet proof and it's automatic, not consistent.  To some, this is unacceptable.  The first example in this document purposely misspelled the name of Professor <em>Falken</em> from <em>War Games</em> because the best guess sounds like an expletive.  To wit, in my history article I also point to several "official" standards that were developed in the W3C to deal with just these sorts of problems.  I'm mentioning this here because the Speech API says that the text provided to an utterance can be one of these: A well-formed <a href="https://www.w3.org/TR/speech-synthesis/">SSML (Speech Synthesis Markup Language) document</a>.  SSML lets you express all kinds of stuff.  This would allow you to create a single utterance which varied all sorts of things throughout and let you express how you wanted each bit to be said.  The spec gives implementations a way out saying that if the implementation doesn't support SSML, they have to just take the text content.  That's a pretty elegant, progressive compromise I suppose.  <em>Well done standards!</em></p>

            <p>It also completely doesn't work that way.  All the implementations I've looked at will actually try to pronounce all the markup.  That's bad.  I suggest you just avoid that.</p>

            <p>The really good news though is that you can actually achieve a lot of the same amount of control by doing your own processing/creation of utterances.</p>
        </section>

        <section class="sectioning">
            <h5 class="contextual-heading" style="font-size: NaNrem;">Language</h5>
            <p>Utterances also have a <code>.lang</code> property which you can set.  It has to be a string representing a <a href="http://www.rfc-editor.org/rfc/bcp/bcp47.txt">BCP 47 language tag</a> (like en-US). If you don't set it, it will by default be the language of the document.  This can give hints to pronounciation. Let's try an example from <em>The Godfather</em>:</p>
            <pre><code class="language-javascript">let apollonia = new SpeechSynthesisUtterance(
   `io so l'inglese:
      Monday Tuesday Thursday Wednesday
      Friday Sunday Saturday
    `
  )
apollonia.pitch = 1.1
apollonia.lang = 'it-US'
speechSynthesis.speak(apollonia)</code></pre>
            <template id="apollonia"><script>
                (function () {
                    let apollonia = new SpeechSynthesisUtterance(
                          `io so l'inglese:
                          Monday Tuesday Thursday
                          Wednesday Friday Sunday Saturday`
                      )
                    apollonia.pitch = 1.1
                    apollonia.lang = 'it-US'
                    speechSynthesis.speak(apollonia)
                }())
            </script></template>
            <button class="run">Run this</button>
            <p class="note">If you set the <code>.lang</code> to an invalid language, say, for example "Hobbit"
            or "Vulcan" it will simply use the default. I couldn't find that in the spec somewhere, but that seems to be the behavior in Chrome.</p>
        </section>

        <section class="sectioning">
            <h5 class="contextual-heading" style="font-size: NaNrem;">A million voices cried out</h5>
            <p>Let's talk about the most painful part of this: voices. You might have noticed that the example above from <em>The Godfather</em> sounded quite a lot different - it was using a different <code>SpeechSynthesisVoice</code>, automatically.</p>
            <p class="note">From here out, I'm going to refer to <code>SpeechSynthesisVoice</code> as simply "voice" because, well, that's a mouthful.</p>
            <p>You can also set the voice yourself, but there are a number of gotchas here...</p>
            <section class="sectioning">
                <h6 class="contextual-heading" style="font-size: NaNrem;">.getVoices(...)</h6>
                <p>You have to get the list of voices supported by your particular
                <code>speechSyntheis</code> by calling <code>speechSynthesis.getVoices()</code>.  The bad news is that as this page was loaded I detected the length of the array returned from <code>speechSynthesis.getVoices()</code> and placed it here -&gt; <span id="immediate-voices" style="border: 1px dotted gray;"></span>.</p>


                

                <p>Odds are that you see a <span style="border: 1px dotted gray;">0</span> above.  That's because it's populated asynchronously and you have to wait for the <code>voiceschanged</code> event to ask for the list of voices.  Here's a contrived example that <em>should</em> set the content of an element next to the Run button below to the name of each voice (the result you'd see would be the last one in the <code>Array</code>.</p>

                <pre><code class="language-javascript">
(function () {
    speechSynthesis.onvoiceschanged = function () {
       let el = document.querySelector('#voices-changed-1')
       // Hey, at least it's a real Array! (despite the spec)
       speechSynthesis.getVoices().forEach((voice) =&gt; {
          el.innerHTML = voice.name
       })
    }
}())
                </code></pre>
                <template>
                    <script>
                        (function () {
                            speechSynthesis.onvoiceschanged = function () {
                               let el = document.querySelector('#voices-changed-1')
                               // Hey, at least it's a real Array! (despite the spec)
                               speechSynthesis.getVoices().forEach((voice) => {
                                  el.innerHTML = voice.name
                               })
                            }
                        }())
                    </script>
                </template>
                <button class="run">Run me, I'll wait...</button><span class="output" id="voices-changed-1">Output will come here if that method is called</span>

                <p>Very, very likely nothing is happening for you no matter how many times you click that.  Why? Because it's a race, as near as I can tell: The voices are already loaded by the time you ran that, so you missed the event - so it's up to you to manage that.</p>
            </section>
            <section class="sectioning">
                <h6 class="contextual-heading" style="font-size: NaNrem;"><code>SpeechSynthesisVoice</code> objects</h6>
                <p>Assuming that you manage to get the array of voice objects, each has several properties:</p>
                <ul>
                    <li><code>.default</code> (a boolean indicating if this is the default voice currently being used)</li>
                    <li><code>.localService </code> (a boolean indicating basically whether this uses the network to produce speech or works locally)</li>
                    <li><code>.name</code> (a humanly readable string name identifier)</li>
                    <li><code>.voiceURI</code> (a URI reference string)</li>
                </ul>
                <p>According to the draft, you can set the <code>.voice</code> attribute of an utterance to any of these voices and that should cause the utterance to be spoken in that voice.  The idea is that you could find a voice in the set and use it to make it sound nifty.. Let's look at an example using a voice called "Bubbles" to speak the lyrics of a song by Jack Johnson:</p>

                <pre><code class="language-javascript">
let voice = speechSynthesis.getVoices().find((voice) =&gt; {
    return voice.name == 'Bubbles'
  }),
  lyrics = new SpeechSynthesisUtterance(
      `It's as simple as something that nobody knows
       That her eyes are as big as her bubbly toes`
  )
  lyrics.voice = voice
  speechSynthesis.speak(lyrics)
                </code></pre>
                <template><script>
let voice = speechSynthesis.getVoices().find((voice) => {
    return voice.name == 'Bubbles'
  }),
  lyrics = new SpeechSynthesisUtterance(
      `It's as simple as something that nobody knows
       That her eyes are as big as her bubbly toes`
  )
  lyrics.voice = voice
  speechSynthesis.speak(lyrics)
                </script></template>
                <button class="run">Run this</button>

                <p>Did it work for you?  Hard to know because, here's the bad news: The list of voices you get back will vary depending on the browser and OS pretty wildly.  On my mac I get a list of 60 voices in Safari v7 (don't ask), 43 voices in Chrome v60, and 24 voices in my Firefox Developer Edition.  This voice doesn't exist on my current Chrome on Android.</p>

                <p class="note"><em>Worse still though</em> the shared <code>speechSynthesis</code> on Android means that
                it's going to speak in whatever voice was last chosen - pretty much anywhere.  If you ran <em>The Godfather</em> example just before this on Android, it probably just spoke those lyrics in an Italian accent.  Sweet.  Just kidding, this is terrible and caused me many many problems.</p>

                <p class="note">Setting the <code>.voice</code> attribute on the utterance might be what's documented, and it might even be what we just (probably?) successfully ran, but what you've got to set if you want it to work in Android  is the <code>voiceURI</code> attribute on the utterance, which isn't even listed in the list of attributes in the draft or most documentation I've read.  Sadly, neither seems to work for me univerally, so set both if you're choosing a voice... And... good luck finding a way to select a good voice. Finally, not all voices support modification of things like rate and pitch.
                </p>

                <p class="note">Another quick note about the <code>.voiceURI</code>: "Bob" is a valid <code>URI</code> reference. So is the empty string.  A <code>URL</code> is a kind of <code>URI</code>.  So, basically what I am saying is: It could be pretty wildly variant, and it is, even for voices with the same name.</p>

            </section>
        </section>
    </section>
    <section class="sectioning">
        <h4 class="contextual-heading" style="font-size: NaNrem;">Wrapping up</h4>
        <p>So... It's pretty cool stuff, but it's a little like writing anything during the browser wars.  You'll want abstractions to paper over the warts and help you deal with all the quirks, and probably just to make it not hellish to write with.  There's a bunch of stuff I didn't cover, for example, there are 'boundary' callbacks and a few other things, but I think this gives you a lot.  In <a href="https://bkardell.com/blog/Basic-Voice-Speaker.html">my next piece</a> I'll talk a little about papering over some of the warts, and then we will get into <em>listening</em> to speech.</p>
    </section>
    <p class="thanksTo">Special thanks to my friend, the great Chris Wilson for proofing/commenting on pieces in this series.</p>
</section></section>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[The History and State of Speech]]></title>
        <id>https://bkardell.com/blog/The-History-Of-Speech.html</id>
        <link href="https://bkardell.com/blog/The-History-Of-Speech.html">
        </link>
        <updated>2017-08-18T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[One apocryphal legend says that when the great sculptor Michelangelo carved his statue of Moses, it was so life-like that as he struck his final blow to the left knee he demanded "Now, speak".  Sadly, it wasn't that easy.  But we've been working hard to figure it out pretty much ever since and, ultimately bring speech to the Web.  As often happens, I find myself so interested in understanding how we got here and where we are that it winds up being a whole piece on it's own.  So, in this piece I'll tell you about the history and at a high level current state of affairs of Speech on the Web, subsequent posts in this series will be more technical...]]></summary>
        <content type="html"><![CDATA[
	
	<div id="downloadsPrefs">
		<p style="font-size: 1.5rem">Note from the author...</p>
		<p>My posts frequently (like this one) have a 'theme' and tend to use a number of images for visual flourish. Personally, I like it that way, I find it more engaging and I prefer for people to read it that way.  However, for users on a metered or slow connection, downloading unnecessary images is, well, unnecessary, potentially costly and kind of rude.  Just to be polite to my users, I offer the ability for you to opt out of 'optional' images if the total size of viewing the page would exceed a budget I have currently defined as 200k...
		</p>
		<p><label>Show me all the images when I read <input type="checkbox" id="download-all-images-pref" checked=""></label></p>
		<p><label>Don't ask me again on this device <input type="checkbox" id="download-all-images-pref-save"></label></p>
		<p><button id="setDownloadPrefs">Dismiss</button></p>
	</div>
	
	<h1 class="contextual-heading" style="font-size: NaNrem;">The History and State of Speech</h1>
	<p class="segue">One apocryphal legend says that when the great sculptor Michelangelo carved his statue of Moses, it was so life-like that as he struck his final blow to the left knee he demanded "Now, speak".  Sadly, it wasn't that easy.  But we've been working hard to figure it out pretty much ever since and, ultimately bring speech to the Web.  As often happens, I find myself so interested in understanding how we got here and where we are that it winds up being a whole piece on it's own.  So, in this piece I'll tell you about the history and at a high level current state of affairs of Speech on the Web, subsequent posts in this series will be more technical...</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">The History of Speech Machines</h2>
		<div class="captioned-image optional share-image p-attached p-attached-right" style="margin-top:0">
			<img data-src="https://bkardell.com/media/VODER.jpg">
			The Voder machine at the 1939 Worlds fair.
		</div>

		<p>At the 1939 World's Fair in New York Bell Labs presented "The Voder" developed by an accoustics engineer named Homer Dudley.  It allowed a (very skilled) operator to create human-like voice with inflection. It was pretty impressive and demonstrated that we'd gotten our heads around a lot about generating human voice-like sounds with electronics.  <a href="https://youtu.be/0rAyrmm7vv0?t=26s" target="_blank">It sounded like this</a></p>

		<p style="clear:none">This work continued to evolve  and by the early 1960s, Bell Labs was synthesizing speech on an IBM 704 and were able to demo it singing the song <a href="https://youtu.be/41U78QP8nBk?t=1m4s" target="_blank">Daisy Bell</a>, which inspired Arthur C Clarke's HAL in <em>2001 A Space Odyssey</em>.</p>

		<p>But, like a lot of things at Bell Labs, this was just way way ahead of it's time.  The rest of the world just needed to really catch up.</p>


		<p>When I was born, to most people, computers were mostly the realm of seemingly far-future science fiction movies.  Actual life was pretty analog.</p>

		<div class="captioned-image" style="margin-top:0; clear: both;">
			<img data-src="http://www.boxcarcabin.com/rca-xl100-console-tv.jpg">
			Here's what my television looked like when I was 4
		</div>

		<p>Back then, you had to get up and walk across the room to change the channel, and you'd do it by physically turning a dial or two and maybe manually moving around an antenna. The year I was born they started selling consoles like Atari Pong. But those were still weird clunky things that you controlled with dials and analog buttons, just like the television.</p>

		<div class="captioned-image optional p-attached p-attached-right" style="margin-top:0">
			<img data-src="../media/TeleGames-Atari-Pong.jpg">
		</div>

		<p>By the time I was old enough to remember anything, a number of 'toys' were beginning to put together some really interesting things: Texas Instruments had the <a href="https://www.youtube.com/watch?v=GvPAS6W3q78">Speak And Spell</a> released in 1978.  The same year, Mego Toy Corp released the <a href="https://www.youtube.com/watch?v=icqHuRDjGRU">2-XL</a>.</p>

		<p style="clear:none">Note all the differences in those two.  The 2-XL sounded human, because it was. The Speak and Spell sounded digitized, because it was.  Lots of ideas were developing and merging and crashing into one another.</p>

		<p style="clear:none">The movie "War Games" introduced me to modems, AI and Text-to-Speech. <a href="https://www.youtube.com/watch?v=D-9l5jSDL50&amp;feature=youtu.be&amp;t=19s" target="blank">YEs, <em>his computer... spoke</em></a>.  The idea of networked computers which could actually sort of 'converse' made my head swim.  It's probably what ultimately drove me to ask for a computer.  Sadly, it didn't talk.</p>

		<p>What did get better and better at talking though was games.  I won't go through them all, but in 1991 two things occurred. Sega introduced <a href="https://www.youtube.com/watch?v=nnvs5B_8ISo">Joe Montana Sports Talk Football</a> which spoke full sentences and announced the game as played.  Wow.  Also, the Web was born, without much fanfare as a very simple, linkable text thing (and I mean very simple - no styles, no images, forms or buttons, no scripting, no tables even).</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Since the Web...</h2>
		<p style="clear: none;">As time went by and computers and software got more and more powerful we continued to chase the dream of making them speak and able to be spoken to.</p>


		<p>Dragon Naturally speaking let you 'talk to your computer' in the form of dictation.  I was excited enough about this possibility to spend a signifcant fraction of my money buy it in the mid/late 1990s. My limited experience with it went something like this:</p>

		<div style="white-space: pre; margin: 1rem 20%; width: 55%">
me
(speaking)
It was the best of times, it was the worst of times.

dragon
(types on the screen)
It was abreast of time. Bratwursts in time.

me
Hmmm, no.

dragon
(types on the screen)
Hymnal.

me
(getting frustrated)
Ugh..No, how do I delete that?

dragon
(types on the screen)
Bug. No, how do I eat fat?

me
(speaking slowly, clearly, enunciating as best I can
No, delete that.

dragon
(deletes everything typed so far)

me
(blinking at a white screen)

random co-worker
(walking into the room)
Hey did you get those TPS reports done?

dragon
(types on screen)
Hay true bet EMS ports fun.

me
(gesturing, pointing at mic and screen)
shhhhh

dragon
(types on screen)
Fish.

me
Oh, fuck you.

dragon
(types on screen)
No, Fuck you.


		</div>

		<p>This is, of course, a dramatization but it was hillariously short of my dreams - so much so that I pretty much just forgot about speech recognition for a long time after that and threw myself in the Web.</p>


		<p>The Web was really taking off and around the time the W3C was formed, plugins like Flash were born and serious standards work began on things like <em>Synchronized Multimedia Integration Language</em> (SMIL) and <em>Virtual Reality Modeling Language</em>.</p>

		<p>In 1997, Microsoft introduced Microsoft Agent which would 'read' to you via Text-To-Speech.  They even <em>exposed it in their web browser via embeddable objects that you could control with vbScript</em> (as long as you used Microsoft).</p>

		<p>With Microsoft having demonstrated it, it seemed very plausbile we might get speech in the browser 'for real' very soon.</p>

		<p>In 1998 <em>CSS 2</em> included Aural Stylesheets. Ever heard of them?  They don't work.</p>


		<p>In March 1999 AT&amp;T, IBM, Lucent, and Motorola formed the VoiceXML Forum to create a kind of 'HTML, but for speech'.  One year later they took VoiceXML to the W3C and a whole bunch of other organizations got involved.  Most of them did not make a Web browser.</p>

		<div class="captioned-image" style="margin-top:0">
			<img data-src="https://www.w3.org/TR/voice-intro/voice-intro-fig1.gif" alt="">
		</div>

		<p>What resulted was not just a codified VoiceXML, but the W3C Speech Interface Framework composed of: Voice XML 2.0, Natural Language Semantics Markup Language, Speech Synthesis Markup Language, Speech Recognition Grammar Markup Language, and N-gram Grammar Markup Language.  Ever heard of any of them?</p>

		<p><em>I will pause here while you continue blinking at the screen for a moment</em>.</p>

	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">"The Modern Era"</h2>
		<div class="captioned-image optional p-attached p-attached-left">
			<img data-src="https://upload.wikimedia.org/wikipedia/en/d/dc/Applessiri.jpg" alt="">
		</div>
		<p>So, we still didn't have a way in the browser to do this.  Then, one day in 2010, a W3C Community Group called the "Speech XG Incubator Group" was started with a developer from Google saying "some of us at google have been working on extending HTML elements for speech".  It was right around this time that Siri was introduced to the wider world and a new era of digital assistants began to flourish and evolve. </p>

		<p>But, what followed was... mostly boring.  It was requirements gathering.  Lots of people saying "I think it should X" or "It has to Y" and "No, I disagree because Z".  That's... unfortunately how standards in committees work.  ,</p>

		<p>But quickly, and I mean <em>very</em> quickly Google submitted a <a href="https://lists.w3.org/Archives/Public/public-xg-htmlspeech/2011Feb/att-0020/api-draft.html">proposed draft</a>.  Through all of the discussion, they also got <a href="https://lists.w3.org/Archives/Public/public-xg-htmlspeech/2011Feb/att-0023/speechrequest.xml.html">a proposal from Mozilla</a>, <a href="https://lists.w3.org/Archives/Public/public-xg-htmlspeech/2011Mar/att-0003/htmlspeech_tropo.html">another from a company called Voxeo</a> and, finally <a href="https://lists.w3.org/Archives/Public/www-archive/2011Mar/att-0001/microsoft-api-draft-final.html">one from Microsoft</a>.  It's worth noting that none of these is 'an official proposal' by W3C terms.  But, in the end, the result of this Community Group was a <a href="https://www.w3.org/2005/Incubator/htmlspeech/live/NOTE-htmlspeech.html#proposals">Note</a>, effectively, "Here's what we found and what we recommend developing".</p>

		<p>The final step here involved <a href="https://lists.w3.org/Archives/Public/public-xg-htmlspeech/2012Apr/0010.html ">whether this work should move now into a real Working Group</a>.  But that didn't happen.</p>

		<p>What did happen, was the creation of another Community Group led by Google and the statement on April 3, 2012, "<a href="http://www.w3.org/community/groups/proposed/#speech-api">Google plans to supply an implementation</a>" of a limited subset of the recommendations of the first group.  You see, the requirements and proposals were, like other standards predecessors, very involved and complicated.</p>

		<p>Google <em>did</em>, in fact, supply an implementation and wrote an article talking about "HTML5 Speech APIs".  This raised some ire because, in fact, it is not part of HTML5, nor was it even on a standards track, it was technically still "just some stuff people were discussing very seriously" in the Community Group.</p>

		<p>There were people from smaller orgs, and just general folk -  at least one or two people from Microsoft and Mozilla, but the conversation on the mailing-list was really mostly dominated by people working at Google.</p>

		<p>In the end though, the product was a <a href="https://dvcs.w3.org/hg/speech-api/raw-file/9a0075d25326/speechapi.html">Final Report which laid out another API, which is, again not on any standards track.</a></p>
		<p>One might think that the rise in popularity and utility of digital assistants would really spurn the interest in standards bodies to move this forward, but instead it seems to have largely "stalled", which is kind of a shame because the web <em>kind of is</em> the ultimate digital assistant in many respects already... We just have to get it there.</p>

	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">What even is a standard?</h2>

		<p>Now, when I said it stalled - that doesn't mean nothing has happened.  Despite all this history, there are nevertheless, bits of implementation of the unofficial proposal in <em>every modern browser</em> and much of it isn't even behind a flag or prefix!!  In fairness, none of them follow it exactly, and to an extent it's hard to say what "it" even is since the spec, out of band errata and implementation shipped by Google don't entirely match.  Further, it's kind of wonky even across different OSes for the same browser and whether you're connected to the interwebs or not.  It's very much like DOM/CSS support in 1998 or 1999.  But, because it's unofficial, addressing issues is typically pretty low priority.</p>

		<p>In some sense though, which is the more valuable 'standard' - the unofficial stuff everyone has implemented or the official ones written down that aren't?</p>

		<p>I'll explain a lot more details, including gotchas and bits I find problematic in the <a href="https://bkardell.com/blog/bkardell.com/blog/Greetings-Professor-Falken.html">pieces I set out to write initially</a>.  I feel like it is very much in the interest of the Web to work together to drive "this" forward, and by "this" I mean simply let's experiment and figure out what's missing and work get speech into the Web "offically".</p>
	</section>

	<p class="thanksTo">Special thanks to my friend, the great Chris Wilson for proofing/commenting on pieces in this series.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Contact Your W3C Congress Person]]></title>
        <id>https://bkardell.com/blog/W3C-Congress.html</id>
        <link href="https://bkardell.com/blog/W3C-Congress.html">
        </link>
        <updated>2017-05-15T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[The W3C is one of the primary standards bodies that works on Web standards.  Founded in 1994 along with the inventor of the Web Sir Tim Berners-Lee, it is a member based consortium originally modeled after the X-Consortium, with the stated aim of helping to "lead the Web to its full potential".  Its 465 "member orgs" are various types of organizations, foundations[1], academia and companies.   In late 2011 a movement in Web Standards began to take shape - seeking to help reform the things that many of us thought were broken.  This meant creating a common/shared vision across several standards bodies, changing ideas about where successful and lasting standards come from and how they are made and really stressing the importance of Web developers (who weren't themselves members) to that equation.  Lots and lots of positive change has happened at many levels, and lots more progress toward change has been set into motion but isn't yet complete and - if you'd like to see it continue, we could use your help.]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Contact Your W3C Congress Person</h1>
	<p class="segue">The W3C is one of the primary standards bodies that works on Web standards.  Founded in 1994 along with the inventor of the Web Sir Tim Berners-Lee, it is a member based consortium originally modeled after the X-Consortium, with the stated aim of helping to "lead the Web to its full potential".  Its 465 "member orgs" are various types of organizations, foundations<a href="#footnote1"><sup>[1]</sup></a>, academia and companies.   In late 2011 a movement in Web Standards began to take shape - seeking to help reform the things that many of us thought were broken.  This meant creating a common/shared vision across <em>several standards</em> bodies, changing ideas about where successful and lasting standards come from and how they are made and really stressing the importance of Web developers (who weren't themselves members) to that equation.  Lots and lots of positive change has happened at many levels, and lots more progress <em>toward</em> change has been set into motion but isn't yet complete and - if you'd like to see it continue, we could use your help.</p>

	<p>Everything about how it works is based on a series of rules codified in a thing called "The Process Document."  You can sort of think about them as "the laws" that govern the W3C.  It's boring, I know, but it's crucially important if you want to really affect change to how the W3C works.</p>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">I'm Just a Bill: An analogy</h2>
		<p>In the US, if you want to change or pass a law, it begins with a Bill.  A bill is effectively, the text of the proposed change.  If it can get a number of individuals in Congress to support it, it can eventually go to the Congress for a simple "yes" or "no" vote.  Most countries (even localities and the United Nations) have similar concepts, but they use different terminology.  So, incase the analogy/terminology is a little too culturally biased, here's a fun primer that a lot of US children saw when I was growing up that explains the ones I'm using:</p>

		<div class="captioned-image optional" id="s" aria-hidden="true">
			<a href="https://www.youtube.com/watch?v=tyeJ55o3El0" target="_blank" rel="”noreferrer" noopener”=""><img src="/media/justabill.jpg" alt="">Click for video of Schoolhouse Rock's "I'm just a Bill".</a>

		</div>

		<p>In many ways, the W3C doesn't work dissimilarly: If you want to change the the way that the W3C really "works" you ultimately need to change the "laws" (the Process Document itself).  Assembling a proposed "bill" begins with drafting a legitimate proposed change and building a number of co-supporters and taking it to the "congress" for consideration and a vote.  In W3C terms, the "congress" are called the "Advisory Committee" - more specifically, the "Advisory Committee Representatives" - one per member organization.  A large number of these members are assembled once per year at the W3C Technical Plenary And Committees meeting (TPAC).</p>

		<p>An Advisory Committee Representative's job is to officially liason between W3C and individual member organizations.  They are the one person empowered to "represent" their organization in an official capacity, including delegation to name people to working groups, sign off on IP policies, and... to cast their vote on things like a proposed change. </p>

	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Meta-Election</h2>
		<p>Within the W3C, the job of managing all of this - getting a "bill" together with a number of co-sponsors, building some support, bringing it to the "floor" at TPAC answering questions and so on so that it can come to a vote is placed upon a group called the "Advisory Board" (or AB). The AB also plays an important advisory role to  the W3C staff itself on strategic issues.</p>

		<p>In deep, and deeply nerdy ways, the AB is important if you want to affect fundamental changes.</p>

		<p>The AB is itself is a (mostly) elected group of nine people. So, if you want to affect real, substantial and lasting "process" changes at the W3C, the first stop is the AB.</p>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">Battles Won</h3>
			<p>For most of the history of the W3C, all of this was "inside stuff" - that is, outside of the W3C, it was unknown.  But then, around 2012, we began appealing to Web developers to help make our desires known under the pretense that, like Congress, membership to some extent must represent you.  Without your support and adoption, they have very little - and it's worked.   In nearly every election, "reform" has progressed and the opposition has slowly diminished. Groups like the AB have increasingly come to better represent us - they've also gotten more diverse and slowly, but surely things we have made substantial progress.  The W3C is more interested in developers, in outreach, in how to include our voices.  Incubation of ideas that includes developers is one thing that our AB have successfully advocated.  Because of our efforts, even the quality of candidates who run has improved.  But we're not there yet.  As you can imagine, getting substantial change through is a long, dull and arduous process.</p>

			<p>Currently, there is an election underway for the Advisory Board.  4 of the 9 seats are up for grabs and it once again falls to developers to show up and advocate if we want things to continue.</p>
		</section>

	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Here's Who I Support, and why..</h2>
		<p>Each of the seats that are up for election have incumbent candidates, but we have 7 candidates for only 4 seats. You can have a look at all 7 <a href="https://www.w3.org/2017/05/02-ab-nominations#nr">official candidate statements</a> made to the ACs asking for their votes.</p>

		<p>For the most part, I believe that most of the new candidates will be less successful toward the aims we've been supporting - worse: Progress is much more easily lost than gained.</p>

		<p>Except for one: Natasha Rooney.  Natasha has been involved in numerous standards bodies and for quite a while she has stood out to me as someone who would be a great asset to the AB.  I've personally encouraged her to run in the past, but the timing just wasn't right.  But now, she is.  To the best of my knowledge, she was the first (and I believe currently still the only) new candidate to <a href="https://medium.com/@thisNatasha/running-for-the-w3c-advisory-board-b2eaf918445">publicly post a statement</a> which I believe speaks for itself.</p>

		<p>That's why I believe that the strongest slate of 4 is both largely stable and includes Natasha.  After a lot of consideration, I most strongly support these folks for AB:</p>

		<ul>
			<li>Mike Champion</li>
			<li>Chris Wilson</li>
			<li>Natasha Rooney</li>
			<li>Judy Zhu</li>
		</ul>

		<p>
		It may surprise some that this list doesn't include Charles McCathie Nevile as I have actively campaigned for him in the past.  I'm thankful for his contributions and efforts and I'd actually largely happy for all of them to be re-elected.  He's a good friend and I greatly respect all that he does.  I'm not specifically opposing him, but the reality is that there are only 4 seats and, as he says in his statement:  He's been there longer than anyone else and he does a crazy lot of other important stuff for the W3C.  Given all this, this might be a great time to introduce some new energy and give him some space to focus on those other roles for a time.  At least, that's what I think would be the best receipe for most success right now.  This W3C election will also include a form of preferential voting, which is an effort he championed for a long time and is now in place, so ACs can be quite expressive with their own votes.</p>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">So what do I do?</h3>
			<p>It's this simple:  Share your support of whomever on social media.  If you know anyone who works for any of the <a href="https://www.w3.org/Consortium/Member/List">465 W3C Member orgianizations</a> and want to reach out to them directly, that'd be helpful too - especially if you know an AC rep (the list of AC reps is private, but some list it in their profiles).  Share your thoughts, be part of the conversation.  If Web developers speak up, history shows that people will hear you.</p>
		</section>
	</section>

	<div class="footnote" id="footnote1">
		<sup>1</sup> Full disclosure, I am a member representing the JS Foundation on some working groups, but the words and thoughts expressed here are my own and should not be taken to represent anyone else's stated positions.
	</div>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Reflecting on Roles]]></title>
        <id>https://bkardell.com/blog/Reflecting-On-Roles.html</id>
        <link href="https://bkardell.com/blog/Reflecting-On-Roles.html">
        </link>
        <updated>2017-04-25T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[Just a silly little experiment based on an observation...]]></summary>
        <content type="html"><![CDATA[
    <script src="../role-reflect.js"></script>
    
	<h1 class="contextual-heading" style="font-size: NaNrem;">Reflecting on Roles</h1>
	<p class="segue">Just a silly little experiment based on an observation...</p>

	<p>So much of what we write is trying to classify and identify things so that we can 'talk about them'. This is true in designs and meetings as well as practically in code: CSS Selectors can be used by DOM, programatically, and by CSS declaratively to 'talk
	  about' something in terms of function or style.</p>

	<p>ARIA provides a way for you to explain to the browser that a thing <em>is</em> or <em>behaves as</em> something it can understand. For example, an element can have a <code>role=heading</code> or <code>role=button</code> and the browser will expose that
	  to AT appropriately. This works because native elements have <em>implicit roles</em> as defined <a href="https://www.w3.org/TR/html-aria/">ARIA in HTML</a> and ARIA defines a rich taxonomy for explaining these.</p>

	<p>Now, however, let's say we want to talk about headings, or buttons. For us, verbally, that's trivial. For AT, that's trivial. But in terms of CSS selectors, it's kind of a pain in the ass. Let's say that you want to style "the first letter of any paragraph
	  immediately following a heading" and you've got a number of approaches across your site(s). Traditionally, to write this, you'd have to write:

	  <code></code></p><pre><code>h1 + p::first-letter,
h2 + p::first-letter,
h3 + p::first-letter,
h4 + p::first-letter,
h5 + p::first-letter,
h6 + p::first-letter,
[role=heading] + p::first-letter { ... }</code></pre>

	  <p>Eventually, we'll be able to use the <code>:matches</code> to make this a little better: </p>

	  <code><pre>:matches(h1,h2,h3,h4,h5,h6,[role=heading]) + p::first-letter { ... }</pre></code>

	  <p>But.. that still isn't super great and that's kind of a trivial thing to want to express. The thing is, the browser <em>already knows</em> they're all headings, it's just invisible to us for many practical purposes. If they were exposed to us somehow,
	    we could write a simple rule like. </p>

	  <code><pre>[role=heading] + p::first-letter { ... }
	</pre></code>

	  <p><em>Note, the syntax there is debatable - practically speaking it would probably make more sense to use a pseudo-class like <code>:role(heading)</code> for this purpose.</em></p>

	  <p>It's not limited to headings either - the taxonomy is useful in a lot of ways. Take buttons for example. If you wanted to generically talk about the style of "things that are buttons" - traditionally you would have to write something like:</p>

	  <code><pre>button,
input[type=button],
input[type=submit],
input[type=reset],
summary,
[role="button"] { ... }</pre></code>

	  <p>But, again, the browser already knows that these are all "button", so it seems almost tragic that you can't just write something like:</p>


	  <code><pre>[role=button] {
  background-color: #ccccff;
  border-color: blue;
  border-radius: 0.25rem;
  display: inline;
  border: 1px;
  margin: 0.25rem;
  padding: 0.5rem;
  font-size: 0.8rem;
  font-family: sans-serif;
}</pre></code>

	  <p>and that would apply to.. you know.. all the buttons. And for buttons, we do a lot - we style the hover state and the focus state and so on.</p>

	  <p>Now... I think that maybe this matters more than just "it feels nicer to write" because the simple fact is that without something like this, the data seems to show that we resort to workarounds.  For example, the Bootstrap <code>.btn</code> class, which ultimately leads to lots of things that are not accessible, and <a href="https://bkardell.com/blog/Divs.html">ultimately just 'less'</a> in pursuit of something that is pretty easy for authors to express.</p>

	  <section>
	    <h2>So here's a thing...</h2>
	    <p>This is <a href="../role-reflect.js">a little script</a> written using mutation observers that you can include in the head of your document and it will expose the implicit roles defined <a href="https://www.w3.org/TR/html-aria/">ARIA in HTML</a>      (if there isn't a role already). While you might think that is 'heavy', it simply looking at the tag name, doing a lookup and potentially setting an attribute - not really terrible at all.</p>

	    <p>The point isn't "we should use this" it is simply to give authors kind of enough to play with things and see if it's totally nuts or potentially really helpful <em>for authors</em>. If not, then maybe a way to begin to discuss what that might mean
	      in terms of a real solution.</p>

	    <section>
	      <div role="heading" aria-level="3" style="font-size: 1.4rem;">Demo..</div>
	      <p>This page is, itself a demo. You can see lots of buttony things styled with a rule about buttons and headings all styled purple with rules just like the above...</p>
	      <button>Test button</button>
	      <input value="Test input" type="button">
	      <input type="submit">
	      <input type="reset">
	      <div role="button">Test ARIA Btn</div>
	    </section>

	  </section>

	  <section style="background-color: #e1e1f6; padding: 0.05rem 1rem 1rem; margin-top: 1rem; font-size: 0.9rem;" class="sectioning">
	  	<h2 class="contextual-heading" style="font-size: NaNrem;">Post Script</h2>
	  	<p>While writing this I thought I recalled a nearly similar thing come up a few years back, and even reached out to some folks to see if I could find it, so I didn't mention it.  After posting, however, someone pointed me to it:  In 2013, James Craig requested <a href="https://www.w3.org/WAI/APA/track/issues/589">almost literally this</a>, which <em>just this last week</em> was moved to a <a href="https://github.com/w3c/css-a11y/issues/2">Github issue in the CSS A11Y Task Force repo</a> which somehow I was not following.  Great!</p>
	  	<p>Also, after I wrote this, my friend Michiel Bijl from TPG wrote a follow-up <a href="moiety.me/thinks/cascading-semantic-stylehooks.html">Cascading Semantic Stylehooks</a> as well.</p>
	  </section>



]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Divs]]></title>
        <id>https://bkardell.com/blog/Divs.html</id>
        <link href="https://bkardell.com/blog/Divs.html">
        </link>
        <updated>2017-03-21T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[I've been utterly failing to complete a couple of blog posts that I've been working on recently.  As sometimes happens when I am writing, I have a semi-random but kind of related thought that doesn't really fit in the post and I tweet it instead.  As it got some little attention/discussion, I'd like to expand on it here and offer a little more explanation/context.]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Divs</h1>
	<p class="segue">I've been utterly failing to complete a couple of blog posts that I've been working on recently.  As sometimes happens when I am writing, I have a semi-random but kind of related thought that doesn't really fit in the post and I tweet it instead.  As it got some little attention/discussion, I'd like to expand on it here and offer a little more explanation/context.</p>

	<p>Yesterday I tweeted a tweet about divs...</p>

	<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">I wonder, seriously, if it was a mistake to make the meaningless element &lt;div&gt; only 3 characters long. Would we abuse it less if it was long</p>— вкαя∂εℓℓ (@briankardell) <a href="https://twitter.com/briankardell/status/843917216533925888">March 20, 2017</a></blockquote>
	<script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

	<p>I'd like to share some context on that.</p>


	<p>Let's imagine that you have a small contract to create a website whose whole aim is just to collect data.  It's really just a few simple forms.  If you wrote vanilla HTML without CSS for that and showed it to your client your client would probably immediately begin the search for your replacement.</p>


	<p>It looks abysmal really.  Unprofessional even.</p>

	<p>And it's not just potentially complicated things like layout - even simple things like buttons look pretty terrible "out-of-the-box" by today's standards.  From what I observe in practice it seems that a lot of people have decided that the default UA stylesheet is just kind of a terrible starting point for lots of things that we do.</p>

	<p>So we turn to something like Bootstrap.  Include Bootstrap's CSS and it immediately looks better.</p>

	<p>Surpringly to many at first though is that it doesn't look <em>that much</em> better.  Your buttons, for example, don't look like those fancy Bootstrap buttons.</p>

	<p>That's because those "buttons" are actually painted based on classes.  If you want your <code tag-esc="">button</code> element to look like a Bootstrap button you have to add classes ala <code tag-esc="">button class="btn"</code>.</p>

	<p>Now, before I talk about any more of this I want to stress something:  <em>Bootstrap is a tool.</em>  Tools want to be generally purposed - able to be used to solve many problems.  Tools and parts kind of don't care what you do with them, they just are.  Sparkplugs, batteries, wires and gasoline are all perfectly wonderful tools and parts and with them you can build lawnmowers and tractors and go carts and semi-trucks and - well, all sorts of useful things.  You could also plug those things together directly and blow yourself up.</p>

	<p>Bootstrap is a perfectly useful tool that you can use to build wonderful things.  I'm not against it.</p>

	<p>In fact, a great thing about something like Bootstrap is that it comes with some pre-defined and useful vernaular that doesn't exist in native HTML.  The concept of a <em>primary</em> button for example. UIs frequently have a concept of a "primary" action. In our forms, "submit" or "next" is probably the primary action.  In an email client or chat client "send" is primary.</p>

	<p>The promise of CSS is really dependent on having more than just tags to work with. Part of the problem is that the standard vocabulary is quite limited and left to our own devices we'll just be all over the map.  Many of us won't even think about the idea of "primary".  The advantage of having some common "slang" with some good meanings like this is clear - people get in the habit of thinking about and identifying the "primary" action and marking it up as such.  Just like the default UA stylesheet, Bootstrap gives it some kind of visual treatment "out-of-the-box".  You can see how people appreciate this and how that isn't a bad thing at all.</p>

	<p>Where I have seen this really bite us is when those things aren't entirely clear and we combine that with an over-dependence on tools.  Tools <em>like Bootstrap</em> (this isn't unique to Boostrap in any way) enable people who don't know much about HTML or CSS to build a pretty nice <em>looking</em> sites and it's easy to take that a little too far.</p>

	<p>So, the thing is: Bootstrap will let you attach those button classes to absolutely anything.  Most of the time, the right answer is probably <code tag-esc="">button class="btn btn-primary"</code>.</p>

	<p>Here's why:  The <code tag-esc="">button</code> element is suprisingly full featured:</p>
	<div class="captioned-image" style="margin-top: 1rem;">
			<img src="/media/button-1.png" alt="">
			<div>The humble <code tag-esc="">button</code> is focusable, clickable, touchable and smartly integrated with DOM events, by default looks 'buttony', has the potential to integrate with form/HTTP automatically, has an accessible role and label and has <a href="https://www.oreilly.com/ideas/proposing-css-input-modality">quite a lot of smarts about how focus rings work</a> and more - all "built in" - and this is an incomplete list.  Buttons also have built in concepts like the ability to disable them and well-established meaning for that on all of these things.</div>
	</div>

	<p>However, all too frequently, once a project is already completed I find something like this instead <code tag-esc="">div class="btn btn-primary</code>.  Look, semantics are weird. Sometimes this can lead to you asking weird philosophical questions about which element you really should use and there isn't always a clear answer.  But that tweet and this observation aren't a slam on <code tag-esc="">div</code>s either: They're a perfectly useful 'container' structure.  You can use them to build structures that you can reason about more easily in your CSS and JavaScript. You should use them. I do. They just have absolutely no "meaning" at all - and in this particular case, it isn't really an especially philospocal question.  Point to the thing on the screen and say "this thing" and immediately most people will say "the button?".  It's a button.</p>

	<p>When you use a <code tag-esc="">div</code> instead of a <code tag-esc="">button</code>, all of those things sketched above go out the window.  You've got a lot of problems.  It might "appear to work in a demo with the CEO" but there's lots of issues that are harder to demonstrate and explain and that's a terrible situation to be in.</p>

	<p>Frequently, this isn't noticed until it's spread like a cancer.  Buttons are one of the most fundamental building blocks of UI.  You can't throw a stone without hitting a button, so remediating this late means touching your code in lots and lots of places. It might sound like a simple search/replace will fix you right up, but actually, those are quite different elements.  Subtle differences chase you, and you'll be suprised at how many bugs will keep coming back from your QA department if they're doing their job well.</p>

	<p>So, in the posts I'm currently failing to write I'm pondering the things that enable/reinforce us getting into these types of situations and why they are so terrible to find yourself in... and how to avoid them.  It seems pretty evident to me that the gap is in large part about presentation and the power of 'demonstration' to shape things - but that's for those other posts....</p>

	<p>What isn't clear to me at all is why so many developers seem to turn to a <code tag-esc="">div</code> in the first place instead of defaulting to using a <code tag-esc="">button</code>?</p>


	<p>That's kind of a mystery, and all I can do is speculate.</p>

	<p>One possibility is that perhaps if you think they "seem equivant" - one is shorter and looks less redundant?</p>



]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Document Outline...What's the Deal with that?]]></title>
        <id>https://bkardell.com/blog/Whats-The-Deal-With-That.html</id>
        <link href="https://bkardell.com/blog/Whats-The-Deal-With-That.html">
        </link>
        <updated>2017-02-24T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[Last week there was a blur of activity surrounding "headings" or - more accurately around discussions about the "document outline". It started with Jon Neal (re)opening an issue.  This issue seems to be about a new element - but it's not entirely.  There were lots of comments and there was lots of discussion on lots of github issues in lots of repos.  I wrote a piece about my own complex thoughts about this issue.  It seems to suggest I am arguing that we start something brand new.  My friend Jake Archibald wrote a piece too which seems really different than the other two.  Trying to keep them all straight and read through comments, one would think that there is a lot of disagreement... But here's the thing: I don't think there really is.  I think it's just really complicated to follow.  To this end - I've asked a few people if this is a fair summary and the answer seems to be pretty much "yes"... So, if you're looking to understand in fairly straightforward terms what the discussions are, here it is...]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">The Document Outline...What's the Deal with that?</h1>
	<p class="segue">Last week there was a blur of activity surrounding "headings" or - more accurately around discussions about the "document outline". It started with Jon Neal <a href="https://github.com/w3c/html/issues/774">(re)opening an issue</a>.  This issue <em>seems</em> to be about a new element - but it's not entirely.  There were lots of comments and there was lots of discussion on lots of github issues in lots of repos.  I wrote <a href="https://bkardell.com/blog/On-Headings.html">a piece</a> about my own complex thoughts about this issue.  It <em>seems</em> to suggest I am arguing that we start something brand new.  My friend Jake Archibald <a href="https://jakearchibald.com/2017/do-we-need-a-new-heading-element/">wrote a piece too</a> which <em>seems</em> really different than the other two.  Trying to keep them all straight and read through comments, one would think that there is a lot of disagreement... But here's the thing: I don't think there really is.  I think it's just really complicated to follow.  To this end - I've asked a few people if this is a fair summary and the answer seems to be pretty much "yes"... So, if you're looking to understand in fairly straightforward terms what the discussions are, here it is...</p>

	

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">FAQ</h2>

		<dl id="faq">
			<dt>What would happen if we could flip a switch?</dt>
			<dd>If there were a switch that we could flip tomorrow that would enable the document outline as described to be switched on on the existing web, in some cases, the heading levels communicated on existing websites would change in screen readers.</dd>

			<dt>That's it?</dt>
			<dd>Yes.  It could potentially enable development of new affordances which could be better, but that happens in the future, if it happens.</dd>


			<dt>Would this be better for existing content, or worse?</dt>
			<dd>Very hard to say universally since we haven't actually tested "it".  In theory, the feeling from the accesibility community is "generally better".</dd>

			<dt>"In Theory?"  "It?"</dt>
			<dd>Yes, there are a few problems here... First, there's not exactly an "it" we can flip on.  There are a lot of words in a lot of places and a few implementations (polyfills and tools, not browsers) that don't exactly match any of those words. </dd>

			<dt>Wait... why don't they match?</dt>
			<dd>In practice it was difficult and confusing to match the words.  There was occasionally some feeling that what it was producing was not entirely great.  So, there are a few variant interpretations.</dd>


			<dt>Wow!  Why haven't we sorted this out?</dt>
			<dd>Mostly, it's just been really hard to do so far.  There is a lot of speculation as to why, but we need to collect more data on that.</dd>

			<dt>We should do that, right?</dt>
			<dd>Collect the data?  Yes.</dd>

			<dt>No, but shouldn't we work to switch something very like "it" on?</dt>
			<dd>Maybe.  Probably.  It's hard to say, we don't even know why it hasn't been done yet... and not everyone agrees on the "it". _We need data, and we need experiments_.  It may be the easiest path from a standardization/paperwork standpoint to modify one of the existing sets of words in a spec.  But then, effectively we are redefining it again so I'm slightly wary of calling it an existing "it". Hard to say.</dd>

			<dt>What's the challenge?</dt>
			<dd>
				<p>Well, aside from we don't have a perfect "it" to discuss, first there is a correlary problem that not all change happens simultaneously IRL.  What really happens is that for some time there is ragged support.</p>

				<p>The second is that each "it" encourages some amount of "new advice" on how to write to really take advantage.  If you write code <em>that way</em> then in some cases there is general concensus that in many cases the result will be worse on the unsupporting browsers than if you had done nothing "new" and just kept doing the same old same old.</p>

				<p>The third is that having an outline enables new possibilities for anything that uses AT, where "AT" can be thought of as anything that consumes content non-visually (and that is a big/increasing bunch of stuff) that go beyond "some heading levels change".</p>

				<p>So, in at least some sense, it's about managing all that.</p>
			</dd>

			<dt>Ok, so what can we do?</dt>
			<dd>
				<p>We can work on figuring out what "it" should actually do in practice.
				</p>
				<p>We can speculatively polyfill and test the variations of "it" to produce document outlines such that if you include the polyfill you can go ahead and write "the new way" and everyone will get the same levels and we can use this to discuss/test any "it".  The "existing web" will remain unaffected until we have a clear "it" and some browser implements it.</p>
			</dd>

			<dt>Seems good?</dt>
			<dd>Yes.</dd>

			<dt>Should we do that?</dt>
			<dd>Yes.</dd>


			<dt>Have we?</dt>
			<dd>Kind of, but not really.  We have various levels of approximations of existing and new "it" ideas.  We need to work better on collecting together existing data and using experimentation to improve the main idea.</dd>

			<dt>So is 'it' a new tag?</dt>
			<dd>In most of the existing specs/words it is not.  Some custom elements exist which do some reasonable approximation of a subset, and they use a new tag.</dd>

			<dt>Are you suggesting that 'it' should be a new tag?</dt>
			<dd>The simple answer is: No not necessarily. Personally, I would rather see that if given the choice.  I explain in some detail why in my post.  I recognize this is my personal choice and it could be wrong.  We need some time and data to know, in my opinion.</dd>

			 <dt>Can we just polyfill exactly as in the spec, not as a new tag?</dt>
			 <dd>Yes! Well, probably.  As long as 'it' is polyfillable - and we should!  As soon as we figure out which spec and why - or are we going to change the spec to match one of the tools implemntation's approximations because they are more reasonable?</dd>

			 <dt>Hmm... Can we try both (as a new tag and not)?</dt>
			 <dd>Yes, and that is what I am suggesting is worth doing.</dd>

			 <dt>Well... Which one will we standardize?</dt>
			 <dd>Who knows?  Maybe neither.  Maybe both.  It's not an argument for or against.... More importantly - does it matter?</dd>

			 <dt>Wait, what? </dt>

			<dd>
				<p>What I mean to say is: Until we have an actual standard, guessing is actually not a great reason to use them.  Don't let this hang you up.  This is a source of a lot of frustration historically in the Web community - we think we are promised things and then don't come.  We believe too much in words that are written down.  When one browser implements it, pay attention.  When two browsers do, it's more likely.  And so on.  We're just not there yet and we don't know what's going to happen. </p>

				<p>In the meantime: Here is a thing.  You can use it if you want because it may be useful.  Or don't.  Here is another.  One may be more paletteable than the other or something.  For you, maybe one has really important features.  Using h1...h6 oriented polyfill will 'degrade' to a flat bunch of h1s without JS - but a lot of other ARIA isn't going to work well for you since a bunch of it requires JS.  </p>

				<p>The truth is:  <em>We just don't know</em>.  What we know is that you have a problem and one of these might help you solve it.  If not, how come?  If so, well done.  That's the job, right?  Get shit done.  Go spend some time with some "it".  Come back and tell us what you think and that will be helpful information.</p>
			</dd>
		</dl>
	</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Headings and the Seinfeld Pitch]]></title>
        <id>https://bkardell.com/blog/On-Headings.html</id>
        <link href="https://bkardell.com/blog/On-Headings.html">
        </link>
        <updated>2017-02-17T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[Because of its origins, HTML has a number of elements and concepts which are, in retrospect, probably not so great.  Headings being the way they are, for example, has caused seemingly no end of discussion.  I'd like to explain why I think this is, as well as what we should do about it.]]></summary>
        <content type="html"><![CDATA[
	
	<div id="downloadsPrefs">
		<p style="font-size: 1.5rem">Note from the author...</p>
		<p>My posts frequently (like this one) have a 'theme' and tend to use a number of images for visual flourish. Personally, I like it that way, I find it more engaging and I prefer for people to read it that way.  However, for users on a metered or slow connection, downloading unnecessary images is, well, unnecessary, potentially costly and kind of rude.  Just to be polite to my users, I offer the ability for you to opt out of 'optional' images if the total size of viewing the page would exceed a budget I have currently defined as 200k...
		</p>
		<p><label>Show me all the images when I read <input type="checkbox" id="download-all-images-pref" checked=""></label></p>
		<p><label>Don't ask me again on this device <input type="checkbox" id="download-all-images-pref-save"></label></p>
		<p><button id="setDownloadPrefs">Dismiss</button></p>
	</div>
	
	<h1 class="contextual-heading" style="font-size: NaNrem;">Headings and the Seinfeld Pitch</h1>
	<p class="segue">Because of its origins, HTML has a number of elements and concepts which are, in retrospect, probably not so great.  Headings being the way they are, for example, has caused seemingly no end of discussion.  I'd like to explain why I think this is, as well as what we should do about it.</p>

	<p>Let's talk about paragraphs.  You can't get much more basic than a paragraph. When I say "paragraph" pretty much everyone will know immediately what I mean.  While some of us might stumble a bit if pressed to describe it abstractly, most of us will, like the US Supreme Court surely "know it when I see it". <span style="display:block; margin: 1rem 0 0">Most people reading this, for example, will recognize immediately that this sentence is in its own paragraph.</span></p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">If it walks like a duck...</h2>

		<p>Except that the above sentence isn't its own paragraph. Kind of.  Let me tell you a story that will help explain the disconnect...</p>

		<div style="margin-top: 0" class="captioned-image p-attached p-attached-left optional">
			<img data-src="/media/angry-sea.jpg" alt="George Costanza 'The sea was angry that day my friends'">
		</div>

		<p>You see, the interesting thing about a paragraph is that we've had the concept for hundreds of years and its entire history has been to <em>visually</em> convey the start of something. Its meaning winds up coming from the visual.  The sentence above <em>looks</em> like a paragraph on the screen or on the printed page, so, in effect it is.  Except that it isn't really.  But we'll get to that.</p>

	    <p>Some of you may have seen a mark like this before: ¶.  If not, that's ok - it's an editor's mark called a "pilcrow".  It <em>means</em> "mark the start of a new paragraph".  Interestingly enough, the reason that paragraphs were historically indented in print comes from the fact that scribes began the habit of just starting a new line and leaving space to come back and draw the pilcrow later.  Once you had the new line and space, you had an easy visual semantic already - the pilcrow becomes just noise.  Editors (or teachers) will sometimes draw this mark between sentences to convey the same: "You should start a new paragraph here".</p>

	    <p>The thing worth noting in this story is that a pilcow (or newline+indent) were <em>visual markers</em> that implied, logically, that you were not just beginning a paragraph, you were inherently ending the previous one.</p>

	</section>

    <section class="sectioning">
    	<h2 class="contextual-heading" style="font-size: NaNrem;">Flat Earth Markup</h2>
    	<p>Flash forward a few hundred years to when we were just beginning to use computers.  GML borrowed the concept of editors marks like the pilcrow in the 1960s.  Thus, they reasoned about things the same way: No "closing tag" was required for many things.  These traditions carried on years later in SGML, and years laters still in HTML.  As you may know, the original vocabulary of HTML was based on a lot of SGML at CERN.  It was built "on the bones" with the intent that you could view these documents with a web browser and still pretty much understand it.</p>

    	<p>Given this history, HTML originally (unsuprisingly) contained only the simplest and most basic concepts from print. It was originally intended to be written with a simple rich text style editor in your browser, in a more or less "flat" fashion - visually. Thus, something like this might be an example of a really common "original" document back in the day:</p>

    	<code-format type="html"><pre>&lt;h1&gt;This marks the top level heading
&lt;p&gt;You can know that this is a paragraph and not heading,
because paragraphs and headings are mutually exclusive ideas,
so, no need for a closing tag to that h1
&lt;p&gt;Similarly, you can know that the previous paragraph
ends when this one starts, because anything else would be non-sensical.
It is, effectively, a pilcrow, no need to close the p
&lt;h2&gt;You can know that this is a subsection because we haven't hit
another h1 yet.
&lt;p&gt;And so on..</pre></code-format>

    	<p>Except... Remember at the beginning when I said that sentence "wasn't a paragraph?"  In fact, it is a <code tag-esc="">span</code> <em>inside</em> of the previous paragraph.  That is something that defies logic, and yet - there it is.  Kind of.</p>

    	 <div style="margin-top: 0; background-color: transparent;" class="captioned-image optional">
			<img data-src="/media/always-a-problem.jpg" alt="George Costanza 'Why must there always be a problem?'">
		</div>


		<section class="sectioning">
    		<h3 class="contextual-heading" style="font-size: NaNrem;">Much ado about nothing?</h3>

	    	<p>A lot of people might think <em>who cares? is it that big of a deal?</em>.  Yes, I think it is.  We can't understand an "outline" of the document and it would be super if we could.  Have you ever wanted to auto-generate a table of contents?  Well, you can't easily do that based on mud or at best it is a really "dumb" outline.  If the only way to really discern the proper boundaries of a section and their relationships with "headings" requires eyesight, well, machines don't have it.  What if a new device, like a watch or something came along and wanted to generate an outline and present you with sections?  How could it?  Or how about this: You're driving in your car and I send you a link that says "read the history section here".  Wouldn't it be nice if you could ask your phone's voice assistant "open this link and read me the history section".  Or wouldn't it be nice if search engines and AI could analyze  your sections?    Oh, and also anyone using assistive technology (AT) would have a hard time.  I mention them last because I want to stress that, <em>in fact, all of these things rely on the same stuff</em>.  It's not just "people using screen readers" who need this. You too, effectively use (and will increasingly use) a kind of AT.</p>

    	</section>

    	<div style="margin-top: 0" class="captioned-image p-attached p-attached-left optional">
			<img data-src="/media/what-did-you-want-to-be.jpg" alt="">
			What did headings want to be? How did we want an outline to work? I don't remember... but it certainly wasn't this.
		</div>

    	<p>Ok, so why are we so bad at this?  First, I think it is because we are by and large such visual creatures.  If the visual semantics "seem right" we just kind of assume they are - even when they are total shit.  While "default visual styling" was supposed to be a side-effect of getting it right, it seems to have played the opposite role since it is so easy to muck up everything else and still get the visuals right.  You can put a heading in any old place - like as the only child of a meaningless element.  What is that a heading for? When does that "section" start and stop?  It's hard to definitively know.  Likewise, search engines making use of headings intelligently was supposed to be a side effect of getting it right too.  Given all this, we seem to have always stressed the side-effects and forgot the meaning.</p>


    	<p>However, it's not just that "we made a mess by misusing them" - the truth is, they are kind of unusable.  It's implausible to imagine reasoning about things with flat markers anymore.   Modern documents aren't flat, not remotely.  They are increasingly rich and structured and highly stylized.  Today we have complex sections and articles and navs and things <em>between</em> those and so on.  Hell, modern documents frequently contain a lot of markup that exists purely as something to hang CSS on.   We just cannot reason about "markers" in the same way.  We can create one hell of a mess though thinking that it actually "means" what it seems to clearly mean visually.</p>

 		<div style="margin-top: 0" class="captioned-image optional">
			<img data-src="/media/whatever-you-want-it-to.jpg
" alt="">
			Some people seem to think "it means whatever the hell you want it to mean".  It doesn't.
		</div>

    	<p>Consider all of the ways that we stitch together forms of reusable fragments: CMSs, build tools, application servers and templates, etc.  All of those are Really Good Things.  A whole lot of the Web only exists because of them.  Except that there is <em>no way to know ahead of time which level heading is actually appropriate to include in a reusable fragment!</em>  Wow.</p>

    	<p>Now - here's the really really shitty part: <em>We kind of seem to have known this since the beginning</em>.  Before there was a W3C, before there was a Netscape or even a Mosaic, before almost anyone even knew there was a "web" there was already (and continued to be) a lot of talk scratching around the idea that "flat" doesn't work here and at least at some level trying to talk about things in terms of just "sections with headings".  In fact, the in the 4th email ever sent to the new www-talk mailing list <a href="https://lists.w3.org/Archives/Public/www-talk/1991SepOct/0003.html">Sir Tim Berners-Lee described this as his preference himself</a>.  Note that the first message was Tim testing the server, and the second was announcing itself and 3rd was someone subscribing.  Realistically, one can say this might have been <em>the first real chat</em> about something in HTML.  Let that sink in.</p>

    	 <div class="captioned-image optional">
			<img data-src="/media/serenity-now.jpg" alt="Frank Costanza yelling 'Serenity now!'">
		</div>

    </section>

    <section class="sectioning">
    	<h2 class="contextual-heading" style="font-size: NaNrem;">Round Earth Headings</h2>
    	<p>So yeah - the earth is round, documents are structured, and we should fix this problem with headings.</p>

    	<p>During the creation of HTML5, this was much discussed and there was a proposal for how to create a "Document Outline".  This was speculative fiction, no one implemented it. Not even a little bit.  Not even at all.</p>

    	<p>In June 2014, Steve Faulkner posted a kind of speculative polyfill (aka prollyfill) for an <code tag-esc="">h</code> element which was implemented in Polymer and tried to stride the line that the Document Outline did.  Then, just recently, Jonathan Neal reopened the discussion with a "not exactly custom element" speculative polyfill (it uses Mutation Observers to achieve that effect).  That's great, I'm very excited.  So, Jon and I consulted a bit on this new <code tag-esc="">h</code> proposal.  I felt like I was having a hard time articulating my thoughts, and particularly why I had the same kinds of worries and what I'd like to see (and why).  So I wrote this to explain.  You see, a lot of proposals  so far seem to kind of attempt to stride the flat earth/round earth line. They carry on or adapt, to some degree or other, either the idea that the implication of starts can work or that 'level' is seperable somehow from structure.  However, I think these things are just kind of fundamentally broken and failed at their core.  So here's what I'd like to see, and what I think is missing that will really help... Nothing.</p>
    	
    </section>

    <section style="clear:both" class="sectioning">

    	<h2 class="contextual-heading" style="font-size: NaNrem;">The Seinfeld Pitch</h2>
    	<p>Ok, ready?  What does the <code tag-esc="">h</code> tag mean?  Nothing.</p>

		<p>Ok, that probably needs more...</p>

		<p>It is possible to create a fairly simple receipe in which you <em>can</em> express meaningful outlines with an <code tag-esc="">h</code> tag.  If you use it this way, we can derive meaning.  If you don't - for example, if an author tries to flat-earth them, or nest them, or do some other crazy shit - we can't.  That's where the Nothing comes in.</p>

		<div class="captioned-image share-image optional">
			<img data-src="/media/well_do_nothing.jpg" alt="">
			Everyone is doing something.  We'll do nothing.
		</div>

    	<p>Let's pretend that you just open an editor and start typing HTML today and you use a <code tag-esc="">foo</code> tag.  You can, you always could  You know what it means?  Nothing.  You know what it looks like?  Again, Nothing.  Its insides match its outsides.  That seems... good?</p>

    	<p>Now, let's imagine something else: Take your <code tag-esc="">foo</code> and style it to look like an <code tag-esc="">h1</code>.  Visually it means <code tag-esc="">h1</code> - just like our opening example.  But guess what it means to everything else?  Nothing.</p>

    	<p>I would wager that if anyone suggested that we simply solve the heading problem by adding an <code tag-esc="">h</code> rule to the default UA stylesheet, pretty much everyone would have the same reaction "you will confuse authors - because it <em>means Nothing</em>".  And they'd be right - but that's kind of what we've been doing with headings all these years.  In those scenarios where authors wrote funky markup, the visual looks great, but the tree is whack.  It means "nothing" (or at least it is misleading enough to not have real meaning). That seems... bad?</p>

    	<p>I think this is kind of broken. Our "meaning" isn't obvious by default visually, so we're lulled into thinking it is "mostly right" or something, but really, that's a side effect.</p>

    	<p>Imagine instead that we wrote that such that only a "good" tag would take on any meaning at all - even visually.  The rest would be explictly Nothing.  Then, our insides would match our outsides again.  It would be a really good incentive to learn "the right way to convey meaning" and to apply it.</p>

    	<p>A really incomplete visualization/explanation of this can be seen in <a href="http://codepen.io/bkardell/pen/vgbgBp?editors=1100">this codepen</a> and I've opened <a href="https://github.com/jonathantneal/hfill/issues/3">an issue in Jon's repo</a> to discuss it.</p>


    </section>

    <p class="thanksTo">Very special thanks to Jeremy Keith for locating the email I was looking for originally from www-talk but had been unable to find.  This article originally contained a reference a year and a half later.</p>

]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Incubate All the Things]]></title>
        <id>https://bkardell.com/blog/Incubate-All-The-Things.html</id>
        <link href="https://bkardell.com/blog/Incubate-All-The-Things.html">
        </link>
        <updated>2016-12-26T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[There's a conversation going on right now on the mailing list public-w3process, it's exceptionally long and twisty at this point, it took me a few hours to get caught up and... Wait, what's that? You've never even heard of this mailing list? No worries, I'll fill you in and tell you why this is important...]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Incubate All the Things</h1>
	<p class="segue">There's a conversation going on right now on the mailing list public-w3process, it's exceptionally long and twisty at this point, it took me a few hours to get caught up and... Wait, what's that? You've never even heard of this mailing list? No worries, I'll fill you in and tell you why this is important...</p>

	<p>Chances are pretty good that you've never even heard of the <a href="https://lists.w3.org/Archives/Public/public-w3process/">public-w3process</a> group, but it's dedicated toward discussion of, effectively, process changes at the W3C.</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">The Process</h2>
		<p>Everything about how the W3C works is codified in a document called "The Process".  It's a really important document, but a <em>very</em> dull one.  However, if you want to change the way that the W3C actually <em>works</em>, then ultimately, you have to modify it, which must be done in accordance with... surprise: The Process.</p>

		<p>Generally speaking, the Terrible, Awful, Horrible, No Good, Very Bad Job of maintaining this document is the domain of the Advisory Board (AB).  It takes a long time and it is painful process that involves lots of debate with lots of people about all sorts of arcane silliness.</p>

		<p>Traditionally, these changes and discussion about them had happened more or less behind closed doors until this list was started in 2011.  Kudos to the W3C for opening it up.  Now, pretty much anyone in the whole world can follow, read, join or participate in the discussion, etc.</p>

		<p>If a process change occurs in the forrest... Well, you might see where I'm going with this: In the ~5 years that it's been open, only 43 brave souls on the entire planet have signed up.  Far fewer have actually participated at all and only a tiny few are involved more than a few times.  You might wonder why that is, because it sounds kind of crazy.  Let me answer by way of analogy:  If someone forced you to choose between following W3C process changes and eating drywall, I'd recommend getting a bib and a whole lot of your favorite condoment. It is that boring and arcane.</p>

		<p>Right now there is a conversation happening there which is 50+ replies deep and spans several different email threads.  Most of the posts are about this size of this article and the topic is incubation.</p>
	</section>

	<p><em>Zzzz... ok, wake up, this is where the real important stuff enters.</em></p>

	<p>As you may or may not know, there is a movement in the W3C to embrace incubation as a part of the process.  I've mentioned aspects of this in blog posts since before there was an thing with a name we could point to, but I don't know that I've ever written about it and explained why I think it is so important on it's own, so here it is....</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Old Fiction: Why we need incubation</h2>
		<p>If you ask "who writes the specs" the answer is inevitably "some standard development organization".  This often leads to the wrong mental image.  To paraphrase a friend who will remain nameless just incase they regret their particularly colorful choice of words:</p>

		<blockquote>So many people come to standards work with stars in their eyes and say, "Well, I just have to get it in the standard and it will be real" and "we're doing R&amp;D here" and... I just want to find ways to kill those people [because] this is really about consolidation and building a platform that we can agree upon and then building value on top of that [and markets in which they can fail].</blockquote>

		<p>That's a big problem historically with no easy seeming answers deployed so far.  Or, rather, it's <em>several</em> big problems.  Let me explain...</p>

		<p>Once you're on a working group you can propose anything and very frequently it is difficult for the average developer to tell the difference between "Just some shit than Brian wants to do" and "Something that has a really good shot at being widely implemented soon". There's also no formal recognition of some very real realities.</p>

		<p>First, that they operate generally by willing cooperation of interested parties and very few actually fund development of the software or control the codebases required to make these things a reality. We can say "that sucks" or "it shouldn't be that way" but, we're  lying if we simply continue to pretend that that "isn't so".  It is.  Second, each of those organizations that do fund or control a codebase have different interests and priorites.</p>

		<p>This mix of things leads to, as you might imagine, a lot of contention in the working groups themselves between all parties.</p>

		<p>Worse still was the idea that browsers would ship "experimental" support by simply prefixing it.  Developers didn't understand that these were experimental and that their intent was to have <em>some</em> way for people to actually use it and give feedback about how to make it better and then kill it off in favor of the "real" thing - so that actually couldn't happen.  Instead, this led to even more contention - accusations that vendors were trying to create a scenario where the only viable option was to use precisely what they'd proposed.</p>

		<p>All of this, as you can probably guess, leads to it taking a very long time to get both concensus and interoperable implementations widely deployed to where the average developer can actually try to use them, because there is some promise of actually getting some work done with it.  That is, after all, the point.  It is also, all too often the case that very frequently initial enthusiasm is quickly dampened as developers come to find that it isn't quite what they were hoping for and a number of things that they wanted aren't there, and that getting that means going back to the drawing board.</p>

		<p>This is frequently the stage where a number of people attempt to enter the process, now that we have mostly open mailing lists.  To do so, they have to find which arcane list to join and figure that out.  Once joining they are often met with a number of unfortunate side-effects - the realization that this is noisy and complicated and takes a really long time."Super-groups" like CSS have tons of proposals at various stages and covering a staggering variety of concerns.  It is nearly economically impossible for a developer to be involved in the real formation of a spec.  These incentives mean that an awful lot of conversation that happens in the working groups surrounds trying to "get it right" for developers: What will they prefer, what will they understand, what use cases will they have.  Which, of course, everyone has an opinion on.  As you may predict, this makes things take even longer.</p>

		<p>If all of this sounds kind of deeply intertwined and seems like it creates a kind of self-magnifying cascade of poo, I agree.  Thus, the desire to change it and the proposal for ways we might do better.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Incubation: Useful speculation</h2>
		<p>Put very simply, incubation is based on the idea that until a certain point, things are really just useful speculation and that finding better ways to identify it as such and work within that idea may be very advantageous.  If we're really fortunate, instead of the cascade of bad, we can build a virtuous cycle of good. This is the aim of the Web Incubator Community Group (<a href="https://wicg.io">WICG</a>).</p>

		<p>Instead of entering the conversation as a something that looks like more than it is in a working group then, ideas begin in incubation.  Incubation happens out in the open, and not on a mailing list where you have to subscribe to everything but in a forum where you can choose smaller, more focused topics to participate in and engage in those.  They don't just come from working group members either because they are, just that: Ideas.</p>

		<p>No more vendors shipping with a prefix - experiments are experimental, they can't leak out into the open by being confused with more than they are.</p>

		<p>This lowers the barrier to entry and focuses the discussion.  Working group members too can benefit from this as it turns out that not even all members are really interested in all things.  Let's just move the noise in to an appropriately noisy place and be clear about what it is until we're reasonably certain that it stands a really good chance of becomming more.</p>

		<p>Incubation goes hand in hand with the <a href="https://extensiblewebmanifesto.org">Extensible Web Manifesto</a>.  For a lot of things, we can build <em>prollyfills</em>.  If you're unfamilliar with that term, there are some new efforts to re-brand those "speculative polyfills" - that is, something experimental which is intended to give you a very good idea what working with that standard will be like, but actually works today in all browers.  The idea here is to short-circut the conversation allowing developers to weigh in themselves at a far earlier stage and with a better value proposition.</p>

		<p>How much earlier?  Well, the "real lifetime" of a lot of ideas that have made it to "widely deployed standard" status is a decade or more.  People were talking about what would become flexbox, for example, in at least 2004 (very possibly earlier).  <em>Most</em> of the things in Selectors Level 4 (and some still not in 4) were already in a draft in 1998.  But you couldn't <em>use</em> any of them.  This meant that taking the time to follow the conversations and understand them and comment on them along the way was impractical - very impractical.  It was intimidating too for anyone who wanted to discuss, and frustrating because chances are very good that there were long conversations and topics years ago that you really should have a look at before commenting, but how would you even know that.  The mailing lists make this hard.</p>
		<p>By comparison, I have seen people turn around a functional approximation in incubation upon request in just a day or two.  Not all of them, of course, but it is frequently faster, the number of people who can contribute is much greater, and it is clearly nothing more than "potentially useful speculation" on a particular/limited topic.  Generally speaking, topics are much easier to deal with as topics than a collection of searchable emails.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Fears</h2>
		<p>Change is difficult and make no mistake, including incubation as an even relatively formal concept in W3C is a change.  It's natural then that some people have fears. Working groups have been the exclusive way to work for a really long time. Why should something not happen in a working group if members of the working group think it should start there and most mailiing lists, like www-style, are technically forums open to the public?  How doesn't this hollow out working groups and make them nothing more than paper-pushers as things move through the process?</p>

		<p>The interesting thing is, it's actually a smaller change in practice than you might think.  Currently, the vast majority of specs have a single primary editor and sometimes two or three collaborators.  They work outside of any working group and answer most of the questions, and have deep discussion and come back with an answer.  It's only at this point that the rest of the working group often talks about it much at all.  There are also exceptionally noisy conversations along the way between other folks on IRC or slack or lots of other venues to help them hammer out ideas which they then bring back to wider audiences.  They move the noise, because that's just how information works.  In many cases then, what incubation provides is, realistically, mostly a move of the venue and the admission of how serious/likely it is to become a standard.</p>
		<p>Working Groups and Incubation are not mutually exclusive ideas, they are complimentary ideas. The aim of incubation is not to replace working groups, as much as to simply to help setup healthier scenarios that provide checks and balances earlier on and allow ideas to succeed or to improve or fork in ways that working groups currently make confusing and difficult.  It's to help balance out the idea of 'powers' and recognize realities.  It's even to just let ideas fail and move on.</p>

		<p>Is it the only way to achieve these goals?  Probably not, and it's not fully fleshed out or perfect - but I think it's the best start on an answer that we have so far.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Cool Story Bro</h2>
		<p>So why do you care, and what am I asking of you?  Well, it's my opinion that this is your Web, as much as it is any W3C member orgs Web.  Ultimately, it is developers who have to live with this stuff.  It's developers who advocate and adopt and occasionally complain about or even occasionally outright reject standards.  You are, in the end, a very important piece of the puzzle and I don't know that anyone is really specifically asking you what you think.  I don't think that you should have to wade through all of the discussions but, somehow, you should be heard.  Your voice matters, if you want it to.  But noone <em>else</em> is gonna do it, if we want to be involved, we've got to be involved.  I think that incubation is an important part of that, but I'm just one guy.  So I'm asking you to start a public discussion, share your perspective - tweet, blog, share. Or, if you're uninterested with changing anything, feel free to ignore.  Here's my own perspective:</p>


		<div class="captioned-image">
			<img src="/media/incubate_the_things.jpg?a=1" alt="Incubate All the Things">
		</div>
	</section>

]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Performance: Shame, Hope, Nuance and Interesting Problems]]></title>
        <id>https://bkardell.com/blog/Perf.html</id>
        <link href="https://bkardell.com/blog/Perf.html">
        </link>
        <updated>2016-11-22T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[My free account on Wordpress.com has served me pretty well over the years by most measures.  I didn't have to set anything up, I use it, people all over the world read it - and did I mention it was free?  What else is there really?  But I've always wanted more control, and ownership of your own content is a really good thing, so couple of weeks ago, I broke down and bought bkardell.com. Given a domain, I decided that now that moving lots of legacy content there would be an interesting and fun exercise. I'd like to tell you about some things it's made me think about...]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Performance: Shame, Hope, Nuance and Interesting Problems</h1>
	<p class="segue">My free account on Wordpress.com has served me pretty well over the years by most measures.  I didn't have to set anything up, I use it, people all over the world read it - and did I mention it was free?  What else is there really?  But I've always wanted more control, and ownership of your own content is a really good thing, so couple of weeks ago, I broke down and bought <a href="https://bkardell.com">bkardell.com</a>. Given a domain, I decided that now that moving lots of legacy content there would be an interesting and fun exercise. I'd like to tell you about some things it's made me think about...</p>

	<p>Being a nerd with a new green field pet project with no deadline is fun, so when I decided to move my legacy posts to my new domain I decided not to just install some blogging software.  I'll take it slow, build it out from nothing - try to have no preconceived notions and re-experience pain (or not).  So, every morning for the past week, instead of reading twitter I while I drank my coffee, I worked on my site for half an hour.  I made some HTML and CSS and setup a home page.  Then I added a build so that I can generate pages from templates and a few other things.  Then, for most of the week, each morning I opened the wordpress editor and copied a post into my new little system, made a few tweaks, and moved on. For now, I'd just leave the image hosting to wordpress until I got the all content up, then maybe I'll write a little tool to download them all and update their URLs automatically.  That was the plan.  Fun.  Each day, I'd pat myself on the back and think "Well done Brian, well done."</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">And then I saw it</h2>
		<p>Friday morning, after I had already closed the Wordpress editor containing the post that I was moving, I realized that I'd messed up a URL for an image during editing.  Instead of re-opening the editor, I just went to the post and opened devtools to grab it. Then I noticed it: <em>My simple blog post on wordpress.com had been making over a hundred HTTP requests and weighing in at 4.3Mb!</em> </p>

		<p>Wait.... What?  How???  I recoiled in horror.  How had they not taken away my nerd license??  My immediate reaction was to do some more analysis - just in order to properly deepen my feelings of shame.  I setup devtools to emulate 3g and a low end device and pulled the blog post up again.  It took almost 16 seconds to reach DOMContentLoaded and 48 seconds to reach Loaded. In reality, about 20 seconds before I had usefully readable content.  I fed it to <a href="https://www.webpagetest.org">https://www.webpagetest.org</a> - it choked before giving me a report, twice. (There were a lot of accessibility issues too, but that's another post)</p>

		<p>Clearly, this was terrible.</p>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">A timeout for nuance</h3>
			<p>Apologies for this long caveat, but I feel like it is necessary in our industry... Look, everything has nuance. Lest someone take the observations this post out of context, and go start beating one another over the head, I want to ask:  Is this really a catastrophic problem?</p>

			<p>It feels bad to a developer to see this, for sure.  But it seems that it was not, in fact, a problem of epic proportions.  Many people, from all around the world read my blog. Not a single person ever commented on this.  Further, I frequently proof my own posts and even go back and find them when I'm in some distant location trying to remember something - and in all the years that I had it, I have never once noticed it to be a problem.  "Yes, but.." you think "you are tech guy in a wealthy country with unlimited speed - you wouldn't notice it".  Except that in this case that's not entirely true.</p>

			<p>You see, I recently spent 2 years living with a very low-end Android phone that you can buy (not with a plan, brand new) for $20 retail.  I live in and regularly visit areas with some pretty terrible sketchy/slow mobile service. Why?  Because I am a real person.  Real people run the gambit of situations and mine briefly made this a choice I was willing to live with for a time.  Even under these conditions, I never noticed.  You might wonder how that is possible, so I'll explain...</p>

			<section class="sectioning">
				<h4 class="contextual-heading" style="font-size: NaNrem;">Real People, Real Cases</h4>
				<p>How fast should your site load? How many bytes should it be? I believe the answer is not a number any more definititely quantifiable than the question "what kind of car should I buy?".  The answer is frequently circumstantial - it depends on what you need to do with it, how much you have to invest, the climate that you live in and so on.  This is no different.  Everything you view in a Web browser is not equal simply because it is in a Web browser, it's a negotiation of a lot of complex factors in real life for both you and your users.</p>

				<p>When I'm on 3g, I know things are going to take longer.  When I'm on shitty hardware, I know my hardware is shitty. In these conditions, I won't leave your site in 2 seconds if it doesn't load.  Why?  Because nothing loads in 2 seconds in those conditions.  Literally nothing.  Opening twitter on that device could take, in some cases, 10 seconds.  I'm willing to wait, in fact, I don't even notice the wait time after a while because I know that it is my situation.  It was my norm.  Further, in this  case (the native Twitter app), I know that I am paying a startup cost and that once it's all loaded and primed it'll be absolutely fine.</p>

				<p>I develop lots of apps that have all sorts of different concerns.  Sometimes they are on an internal network where we control the browsers and once logged in people are in it pretty much all day every day.  In those kinds of cases, I don't worry about these sorts of things so much.  Loading 2 or 3Mb isn't a huge concern in those cases, especially if you can heavily cache and reduce those payments to be very infrequent things.  Spending an inordinate amount of time and money catering to an audience we don't have would be wasteful.  Sure, we might save our company users a fraction of a second once a day, maybe even a whole second.  But... They're not going anywhere.</p>

				<p>The time that influences the bounce rate for online banking is probably much much higher than it is for an article that you only kinda sorta wanted to read in the first place, and everything else lives on a scale somewhere in between.</p>

				<p>So, please - read this all with nuance.  I am not making a hard-line argument that everything needs to be infinitely tweaked. How lean is lean enough? How fast is fast enough? It's debatable... Obviously, lighter and faster is always better, but there is a point of diminishing return that you'll have to decide for yourself.</p>

			</section>
		</section>



		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">For <em>me</em>, this is unacceptable</h3>
			<p>All those caveats aside, this is still unacceptable to me and here's why:  As I said, articles are not special in any way.  I'm not going to get a lot of good will because a user really wants to or needs to read my post.  I'm not providing a service.  Users don't want to "spend time" with my blog.  We're not building relationships there or achieving tasks to our complete work.  For a number of people, it might be the only time they ever visit my site.  They're not playing a game or conferencing.  Maybe they just <em>kind of</em> want to read some fucking content. In my experience, this is precisely the kind of thing that I would give up on if it took too long.  Further, I really really <em>want</em> them to read my content.  For me, I have another concern:  Metered connections.  I have a whole lot of readers who travel internationally and have metered plans while traveling.  It's awfully nice if they read my post, but it feels a little thoughtless if I take a noticable hunk of their plan if I can avoid it.</p>

			<section class="sectioning">
				<h4 class="contextual-heading" style="font-size: NaNrem;">So now what?</h4>
				<p>Well, at least now I was in control and - I know that <em>I</em> did not require 100 HTTP requests, so I opened my new post to compare:</p>

				<p><em>Number of requests</em>: 13.  Yes, much much better. <em>DOMContentLoaded</em> in milliseconds, not seconds.  Much better.  <em>Size?</em>  Still megabytes large.</p>

				<p><em>Let me put this into perspective:  The HTML, CSS and even my avatar all combined weigh in at a whopping 20k.</em></p>

				<p>So where were all these megabytes coming from?  JavaScript?  Nope, I didn't have any yet. None. The answer is images.  Another post was even worse - 21mb and mostly because of a single animated gif.</p>

				<section class="sectioning">
					<h5 class="contextual-heading" style="font-size: NaNrem;">Enter: suprisingly interesting problem</h5>
					<p>This raises an interesting challenge that I don't frequently get to spend a lot of time thinking about... The traditional CMS and "page oriented" web and content with graphics.</p>

					<section class="sectioning">
						<h6 class="contextual-heading" style="font-size: NaNrem;">The scary thing</h6>
						<p>On some level, the truly scary thing is how it got that way:  After all, I'm not the average Joe who you give a CMS to in order to create content.  I am savvy.  I do this for a living.  But CMS's have been around for a long, long time and there are lots of products and when it comes to a problem that is easily handled with a CMS, my attitude is often just "well, let's just use a CMS for that, there are more interesting problems to solve".  It's unlike me to just assume things, but I assumed that Wordpress.com was really doing a lot more for me than it was.  The brand, the interface, and the ease with which I could setup and publish content made me essentially 'forget' to really care about any of this stuff.  My first thought was that if I am writing huge pages as someone with skills, I wonder what happens to people who walk into this without any knowledge?  I'll bet there are some truly gnarly blog pages out there.</p>

						<p>The good news is that simply optimizing even <em>some of</em> my images, turning some animated gifs into video and choosing better image formats for some things and the image weight went from megabytes to a few hundreds of kilobytes.  But, is that good enough?  Maybe.  At least it isn't blatantly disrespectful of their plans and bandwidth, but it led me to an interesting bit of thought...</p>


						<p>I frequently write my blog posts with themes and images for no "real" reason other than that I happen to like that.  I spent some time finding an acceptable way to make the same images look good, size and layout well on any device.  It's my style.  I find it more engaging. I think that my readers usually do too.  I don't have data to back that up beyond that I continue to have readers and that often people comment in relation to that aspect as much as the content itself.  I'd really prefer not to change that.  It's my style.  So I'm left with an interesting choice:  Stop being me, or conceed that I'm unwilling to give you content without the images... Just serve the less engaging content to everyone.  Am I?  Sometimes perhaps?</p>
					</section>

					<section class="sectioning">
						<h6 class="contextual-heading" style="font-size: NaNrem;">Optional Images and a budget</h6>
						<p>Here's why this is an interesting problem to me:  Images aren't new, we've had them since 1996 and this has kind of always been the case, but the truth is that our approach doesn't take a lot into account.  Whether I am willing to give you content without images or content with images or content with fewer images has a lot to do with the role of the image.  Sometimes, images are really important.  As an amature painter, I can tell you that I have posts in which the image <em>is</em> the primary content. I have other cases where there's an important illustration and then I have a bunch of stuff that is less so. It's more than just visual decoration, but less than absolutely critical.  Thus far, I haven't seen any realy interesting ways of dealing with this as a <em>set of problems</em>...</p>

						<p>Every 6 months or so, someone floats an idea about being able to make media queries based on connection speed or whether your connection is metered or not, but these are always problematic and quickly shot down.  The browser just really has no excellent way of knowing - bandwidth fluctuates, there are privacy concerns, people tether and use all kinds of weird setups. Further, I'm not sure it should be <em>only</em> my decision.  As I said earlier, what you're willing to read or wait for is a negotiation of sorts - but how can we negotiate this?</p>

						<p>This has me thinking it might be worth running some experiments with UI.  I'm beginning to mark my images as essential or optional, I'm collecting the weight of optional images and setting up some rules around it in my build such that when I have scenarios that might be costly but are mostly due to my writing flare, I can ask you whether that's ok and give you the option of skipping them and saving that choice on that device so that I don't annoy you if you're never in that situation (or always are).  This approach should really limit the amount of time I spend pestering 99% of users to somewhere between 0 (if they never encounter a themed post with a size beyond my totally arbitrary limit of 200k for my own assets) and 1 (the first time they hit one).  Will this cause a big bounce rate increase and actually be counter productive?  I honestly don't know... Let's see.</p>

						<p>Here are a smattering of results to illustrate...</p>

						<table style="width: 100%; border-spacing: 2rem; font-size: 0.8rem">
							<tbody><tr>
								<th>Post</th>
								<th>Wordpress</th>
								<th>bkardell.com <br> (w/optional)</th>
								<th>bkardell.com <br> (w/o optional)</th>
							</tr>
							<tr>
								<td>X-Web Days of Future Past
									<br>
									<a href="https://briankardell.wordpress.com/2016/06/02/x-web-days-of-future-past/">old</a> |
									<a href="/blog/X-Web-Days-of-Future-Past.html">new</a>
								</td>
								<td>102 requests / 21.4 MB</td>
								<td>8 requests / 957k</td>
								<td>4 requests / 45.3k</td>
							</tr>
							<tr>
								<td>The Future Web Wants You
								<br>
									<a href="https://briankardell.wordpress.com/2016/08/24/the-future-web-wants-you/">old</a> |
									<a href="/blog/The-Future-Web-Wants-You.html">new</a>
								</td>
								<td>109 requests / 4.3 MB</td>
								<td>12 requests / 431k</td>
								<td>4 requests / 49k</td>
							</tr>
							<tr>
								<td>Prognostication and the Failure of the Web
									<br>
									<a href="https://briankardell.wordpress.com/2016/05/06/prognostication-the-failure-of-the-web/">old</a> |
									<a href="/blog/Prognostication-And-The-Failure-Of-The-Web.html">new</a>
								</td>
								<td>117 requests / 966k</td>
								<td>18 requests / 176k</td>
								<td><em>Doesn't exceed 200k, no prefs applied</em></td>
							</tr>
							<tr>
								<td>A Brief(ish) History of the Web Universe - Part I: The Pre-Web
									<br>
									<a href="https://briankardell.wordpress.com/2015/11/22/a-briefish-history-of-the-web-universe-part-i-the-pre-web/">old</a> |
									<a href="/blog/Brief-ish-History-of-The-Web-Part-1.html">new</a>
								</td>
								<td>105 requests / 1.2Mb</td>
								<td>9 requests / 194k</td>
								<td><em>Doesn't exceed 200k, no prefs applied</em></td>
							</tr>
						</tbody></table>


						<p>Is it a good idea? I don't know.  What are the right thresholds, how do I let you know, etc - these are things I'll continue to toy with as I collect data.  In the meantime, if you have thoughts, I'm interested to hear them.</p>
				</section>
			</section>

		</section>



</section></section>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Glory Days of the Web]]></title>
        <id>https://bkardell.com/blog/The-Glory-Days-Of-The-Web.html</id>
        <link href="https://bkardell.com/blog/The-Glory-Days-Of-The-Web.html">
        </link>
        <updated>2016-10-05T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[For the past couple of years, there have been a number of pieces lamenting the current state of Web development: It's gotten pretty complicated. Very recently a satirical piece on this subject really struck a chord and got a lot of attention. Dion Almaer wrote a piece in reply in which he introduced what I thought was a really good analogy - the rose colored glasses that we often see the past through...]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">The Glory Days of the Web</h1>      
	<p class="segue">For the past couple of years, there have been a number of pieces lamenting the current state of Web development: It's gotten pretty complicated. Very recently a <a href="https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f#.m50p34qi8" rel="nofollow" target="_blank">satirical piece on this subject</a> really struck a chord and got a lot of attention. Dion Almaer <a href="https://medium.com/ben-and-dion/i-want-to-go-back-to-the-1950s-of-web-development-fa69d7fe357a#.bqj5a5ug1" target="_blank">wrote a piece in reply </a>in which he introduced what I thought was a really good analogy - the rose colored glasses that we often see the past through...</p>

	<blockquote>...it reminds me of folk who talk about the golden era of the 1950s in the US. It isn't hard to look at the current political climate and long for another time. Remember the white picket fences? Life was so good! Those glasses sure are rosy though, and when you take them off you see a society that had huge problems...</blockquote>

	<p>"Huge Problems" is an understatement at the level of "the surface of the sun is warm". In many ways, if most of us were placed in 1950's America we would characterize it as xenophobic, sexist and racist - but also not exactly afraid of taxes or the idea that the government had a big role to play. Today we squabble like it is an all-life-on-earth-ending decision to make what are historically very minor tax tweaks - we just know that the past was somehow better... They were the "glory days" and we don't seem to give a lot of thought to why.</p>

	<p>We seem to do this with everything - it's kind of human nature I think. Ask a 50 year old about their teenage years and they'll likely regale you with stories that make it seem pretty good. Now ask a teen how they feel you'll likely get a very different perspective. Things seem to get simplified, polished and a little more rosy with time. Somewhere in between these is probably a fairly objective 'reality'.</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">The Web's Glory Days that I don't actually recall...</h2>
		<p>Like Dion, I feel like we're doing that a little with our perspective of writing for the Web. If what you remember (or the story that you've heard) is that "once upon a time we just wrote HTML (and maybe CSS) - there weren't so many frameworks and programming to learn and life was good"- then we have very different recollections.</p>

		<p>If you were writing only HTML and CSS before, for example, and you're not anymore then you're comparing apples and oranges. If you could before, you still can. However, in reality, most sites were not that, even "static" ones.</p>

		<p>Did you manually copy, paste, edit things like your header and footer? If you did, you were one of a small few because these were problems that were obvious even in the mid-90s and answers were provided by even the earliest servers and many popular "IDEs" of the time or tools made it possible to do this as a 'build time' process.</p>

		<p>Also obvious, even in the mid-90's, was that no-one would sit and write HTML all day, every day. HTML was, by design, intended to be the lingua-franca for common understanding. It was the thinking that most of it perhaps would be generated by a program, not authored by hand. In fact, the very first significant use, even at CERN, involved writing programs that wrote HTML and TimBL's original browser effectively hid the HTML from you.</p>

		<p>To generate HTML from bits, to query a database or services and so on, to hide things under non-standard abstractions - you need a programming language. Enter the complexity and the variance.</p>

		<p>Over the years I have watched as people built sites using tons of server-side and build tech in order to do precisely this. These involved choosing a server. Once you have a server, frequently there are N choices of languages you can use. Given a language there are frequently N templating languages and N possible frameworks you can use to express how those things pinned together. Some of them required compilation, many had a concept of 'build time' work. All of them also had to deal with server configuration that dealt with how you deal with things like threading, connection pooling, caching, etc. All of them dealt with databases, and so on. Did you use cgi/bin and Perl? Did you use .asp and COM? Did you use Java? If you did, did you use JSPs, FreeMarker, ECS, Velocity, JSF or Ice Faces? Did you use Struts, Spring MVC, Spark, Dropwizard? Did you transpile with something like GWT? Did you ever try thinking about portlets? Or did you prefer Ruby on Rails? Or PHP? If it sounds like I am reaching for examples, I can assure you this is an exceptionally abbreviated list of actually popular approaches that I have encountered. People who dealt with those all had similar complaints to the ones I hear now.</p>

		<p>Building this stuff - especially building it well, has never, to the best of my knowledge, or in my experience, been simple.</p>

		<p>It's never not involved a lot of variety of choice or strong opinions about "the right way" or what is "good enough" or tough/interesting challenges regarding how to fit into existing ecosystems. Instead, primarily what seems to have changed is where it's possible to build what.</p>

		<p>Today it is possible to build rich, engaging UI that happens on the client that wasn't really possible before JavaScript - but it's also not exactly new - merely the level at which we aspire to do it is. By the mid-2000's sites were getting pretty rich. The reason we have HTML5 is that JavaScript allowed us to not stand still and wait for something better to come along.</p>

		<p>Was this the simpler time? Not for me it wasn't - in addition to all of the server frameworks, every week there was a new library. Prototype, Scriptaculous, MooTools, Dojo, qooxdoo, Bindows, YUI, ext.js and many more, until finally jQuery. But jQuery itself was pretty low level and stopped there as opposed to something like ext.js which came complete with a UI toolkit. This is where a lot of frameworks come in today - it's not necessary maybe to have a 'client approach' and a 'server approach' be quite so far apart - maybe that's good.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">An added bit of non-technical complexity</h2>

		<p>Somewhere along the way, we seem to have had a split. In some orgs that I worked for, this was all considered "equal". I was a "full stack" developer and the whole stack was equally important. In other orgs, there were "front-end" developers and the front-end was an important discipline on it's own, but it was separate from "design". Design was more of a static deliverable of HTML and CSS and maybe some "demo-y" JavaScript that we probably wouldn't really use. Some people saw that as lesser, some people just thought of it as different. In still others all of this was somehow viewed as "lesser" and "not real programming" and so many "real programmers" avoided it and handed it to people who were actually primarily interested in designs and didn't have experience with "real programming languages". In the meantime, a lot of people strode weird middle grounds.</p>

		<p><strong>So... suck it up?</strong></p>

		<p>No, none of this is to say "suck it up folks, that's just how it is". I too feel like it's gotten a little overwhelming. But I'm more overwhelmed by simpler things. It was a really nice quality of jQuery, for example, that you can simply grab a release off a CDN, include it however you like, and go. Frequently, a simple <code tag-esc="">script</code> include was "good enough" and you were off to the races. Today, a lot of projects lack that level of friendliness. You need to have node installed. And NPM. And probably a certain build tool. And maybe something like TypeScript - just in order to get a single file. And it might be that that file really wants to work with a package manager that you don't know about so you have to get that - and so on. It's hard to not feel overwhelmed by that alone. We should really work on that.</p>

		<p>But I'm also fairly realistic about what we can/should do about it I guess and why I think it is that way. History shows that eventually we do shake the good bits out into standards - and it's slow, kind of painful and more than a little overwhelming at times along the way. But I find hope in knowing that we're all working on making that process a lot better by reconsidering how we approach standards (see also <a href="https://extensiblewebmanifesto.org/" rel="nofollow" target="_blank">The Extensible Web Manifesto</a>, The <a href="https://wicg.io/" rel="nofollow" target="_blank">W3C Incubator CG</a> and <a href="https://chapters.io/" rel="nofollow" target="_blank">Chapters</a>). If we can make this lifecycle better, that could be pretty dramatic. The best thing about standardizing things on the client, in my opinion, is that there's only one. JavaScript isn't really in competition with 17 other languages and there is ultimate only the DOM. That's at least something promising.</p>

		<p>But let's also try to remain realistic in how we compare the present to the Glory Days.</p>
	</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Potentially Scattered Thoughts on Web Components and Frameworks]]></title>
        <id>https://bkardell.com/blog/Potentially-Scattered-Thoughts-On-Web-Components.html</id>
        <link href="https://bkardell.com/blog/Potentially-Scattered-Thoughts-On-Web-Components.html">
        </link>
        <updated>2016-09-26T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[Chances are pretty good that you've seen at least one of the many articles and tweets flying around lately about Web Components and Frameworks. For the past week I've watched as all sorts of arguments have been made by friends of mine on both sides and wanted to weigh in and share some thoughts, but my life hasn't been cooperating. Finally, I have a moment so I tried to put down some thoughts that have been banging around in my head... No guarantee they are coherent and I'm out of time, so here they are....]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Potentially Scattered Thoughts on Web Components and Frameworks</h1>
	<p class="segue">Chances are pretty good that you've seen at least one of the many articles and tweets flying around lately about Web Components and Frameworks. For the past week I've watched as all sorts of arguments have been made by friends of mine on both sides and wanted to weigh in and share some thoughts, but my life hasn't been cooperating. Finally, I have a moment so I tried to put down some thoughts that have been banging around in my head... No guarantee they are coherent and I'm out of time, so here they are....</p>


	<p>A lot of developers (by far the vast majority) don't work for browser vendors, they aren't involved in building frameworks or standards development. They don't have the time to spend a few years considering all of the gory little details and discussions that got us to where we are today.  A lot of us stay in the loop by looking to and take queues from a comparatively small number of people who do and boil it down for us. We all have to do this with at least some things.  Then, we then further categorize into "good" and "bad" piles mentally, and we use that to determine what's worth spending time on or what will be a waste. Right now, for most people, it's probably a little overwhelming. Which pile do Web Components belong in? Are they going to be Shangri La or a real shit show?</p>

	<p>The answer is: No. Neither. A little of both at times. I'm sorry if that sounds wishy-washy but real life is like that.  It's full of grays. We move forward in fits and starts.  We frequently can't even predict what people will do with things until they get them - I've written about all of this a lot.  Reality is messy.  Getting agreement is hard.  Truth is often subtler than we imagine and non-binary.</p>

	<p>Let me explain what I mean though because without more, that's kind of a non-answer...</p>

	<p>Web Components are <em>super </em>cool, and also - believe it or not - imperfect. I think that they're a fundamental step toward us getting much better at a lot of things, <em>and</em> I think we're kidding ourselves if we think it's not going to be bumpy for a while while we sort some things out.  I believe that we <em>can</em> make them work with very popular frameworks <em>and I also believe </em>that they are not ideally suited to them today for a number of reasons and that people may choose not to use them.  This creates challenges that I think we are not articulating well and... that actually might matter.</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Web Components or Custom Elements?</h2>
		<p>Since I'm talking about articulating to developers... We're not always clear on this.   Sometimes we're even conflating Web Components with Polymer. We're doing better than we were in 2013, but we've got to do better still.  Polymer isn't Web Components in the way that birds aren't ducks.  Polymer is conceptually built around Web Components, but it's a library.  Because it is a library created by Google and it includes polyfills and prollyfills and because these are not always historically clearly labeled, that's gotten a little confusing sometimes.  Occasionally, that's caused bad feelings.  Use Polymer, React, Angular or Ember.  They're all good, I'm not trying to pick on one.  Just be aware what's what and what isn't.  Your mileage may vary.</p>

		<p>So, in an effort to be clear - in this piece I when I say "Web Components" I am talking about Custom Elements and Shadow DOM as those are the two pieces that are near shipping.</p>
	</section>


	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Can/should you use the current incarnation of Web Components with all of the popular frameworks?</h2>
		<p>Yes, probably you <em>can</em>... Sort of.</p>

		<p>Believe it or not,<em> I think this is where most of the trouble lie</em>s.  "Can you" isn't the question to ask.  "Should you" or "Will People" are the questions.  One group says "resoundingly yes you should because it is native and therefore is most widely usable."  Another counters "potentially you can, but you really might not want to with a framework because it won't be as convenient as you might think.  A lot of components will either not work or will require wrappers/adapters in practice".  "Can" has a definite answer and, I'm pretty sure the answer is "yes" because we can make just about anything work if we try hard enough (see: the entire Web).</p>

		<p>That's where "should you" comes in and I'm afraid that the answer there doesn't seem so cut and dry - and that "Will People" is kind of up in the air.  Why?  Because "can you" isn't the only variable.  You've probably had experiences where it gets pretty hard and you think "is this really worth it?"  I'll tell you about one of those I had below that makes me sensitive to this one.  I'm happy to be shown "it's worth it" in actual practice and "people will (more than once)" in the real world, but my own experiences thusfar don't entirely bear that out.  I'll also explain why I'm ok with that.</p>

		<p>It's a pickle. But it's a pickle like "should you do x" and we have a lot of those.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Will people use Web Components with their framework?</h2>
		<p>Yes, or at least they will <em>try </em>if a whole bunch of people are all telling them that for sure this  should work and that's part of what people are worried about.  I'm not sure this is being well articulated but the worry that some have is: It's not going to be the walk in the park that they imagine and that's that's going to turn people off to Web Components. Even framework people think that would be a shame because we <em>all</em> agree that Web Components are a great idea that we absolutely want. Web developers have been disappointed and frustrated a few times already with challenges in the morphing of Web Components as we struggled to get consensus. Regardless of reasons or blame, that seems true and we probably can't afford a lot more of that.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">So, should we go back to the drawing board and re-think Web Components from the ground up?</h2>
		<p><em>Hellz No!</em> But, believe it or not, I don't actually think anyone really meant to imply this literally regardless of what they might have said in 140 characters one day after lunch.</p>

		<p>Why not?</p>

		<p>Because they're a good step forward and not shipping something fits just as neatly under the "we probably can't afford a lot more of that" heading.</p>

		<p>For those who might not be aware, "Web Components" is actually a cold reboot of many previously failed attempts to do many of the same things - HTC, XUL, XAML, FLEX and XBL were all trying to do the same. These efforts were restarted, to the best of my recollection around 2009 or 2010 under the banner "Web Components" - but you can track the general idea of "custom elements" (lowercase because they were more like "Web Components") in some fashion back, practically as far as the Web itself. In all that time, we have never been so close. Why? Because the problem is hard.  Because new things come along and give us pause. Because consensus is hard. Even just between those who actually make a browser it is, in a word: <em>fucking hard</em>. <a href="https://www.youtube.com/watch?v=SHnTocdD7sk" target="_blank">Standards are like this Weird Al Song</a> . On anything that asks for the ability for authors to be able to mint elements and define them, doubly so.</p>

		<p>It's not the end of the game but we can't move on further until we beat this level.</p>
	</section>


	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">So what <em>should</em> we do?</h2>
		<p>Just be realistic I think. We move forward in steps. If we are pitching an all-singing, all-dancing, no challenges to be found future, that's probably not realistic.  A de-facto <em>implementation</em> that will be used everywhere regardless of framework, might be over-selling a vision until we actually see it broadly happen.  Sure, it might be <em>possible</em>, but possible isn't the only variable.  It's also entirely likely that even if someone posted such a thing, even one with an adapter for Ember or React, or even Polymer of a very popular custom element with "Web Components Underneath" that within a few days someone will say "yeah, but that's inefficient".  It's pretty easy for them to make a derivative component in their framework that does the same thing but cheaper, and it's very likely that many people with that framework will gravitate toward the "more efficient for their framework version."  I'm not sure.  We'll see.  That's all I'm saying.  That and...</p>

		<p>Meh.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Meh?</h2>
		<p>Yeah, meh. I'm ok with that for now.  We're not there yet, but we'll figure it out as long as we work together.  I know that might sound a little disappointing if you were hoping for total Nirvana - but it's hella better than what we had a few years back.  Declarative solutions are very easy to use and thank goodness we all agree on that much, even to the basic point of how we express them. In fact, all of the major frameworks have a solution that looks a lot like Custom Elements. Here's some markup, is it an Ember component or a Custom Element?  You can't tell.</p>

		<code-format type="html">
			<pre>&lt;div&gt;
  &lt;common-button id="btn"&gt;Status&lt;/common-button&gt;
  &lt;common-badge icon="favorite" for="btn" label="favorite icon"&gt;&lt;/common-badge&gt;
&lt;/div&gt;</pre>
		</code-format>

		<p>Yes, it means there might be N implementations of the same thing instead of the one true implementation -- and yes that kinda sucks.  But... meh.</p>

		<p>We have armies of developers who are probably willing to port a popular custom element to their framework of choice until we sort this out.  Within my own company we have some things implemented twice - once as a Custom Element and once as an Angular directive.  It didn't start that way, it<em> wound up that way</em> because that turned out to be easier and more efficient to say to Angular "Ok - you be you".  I fought it until I could fight no more.  Now that we did it, it's not the end of the world.  The folks who write markup still don't need to learn something new moving from frameworkless pages to Angular pages.  Their knowledge is portable.  That's not as amazing as I'd originally hoped, but in practice, it's actually been pretty damned good.  And I'll take it over all of the N-solution, very complex alternatives we had before any day.</p>

		<p>I believe we will get to the day when that isn't necessary, but - if someone says "that day might not be today" I don't think they're just being difficult.  I'm super happy to be shown - in reality - that this isn't likely, but there only time will tell.  Dueling speculations won't tell us, only real experience will.</p>

		<p>The mere fact that we can mint tags and easily transfer understanding between all of these is, in itself, a pretty significant leap in my opinion.  That it allows us to begin the process of developers helping to establish the "slang" and further wrestles away creative powers from being the sole domain of browser vendors and for standards to play the role of dictionary editors is, in and of itself,<a href="https://briankardell.wordpress.com/2013/05/17/dropping-the-f-bomb/"> pretty significant</a>.  We should throw this in the win column regardless of any of that other stuff.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">What next?  Are we resigned to this forever?</h2>
		<p>Nah, I don't think so.  We should manage expectations for now, but React, Ember and Angular all have some really interesting observations about declarative serialization and how we express things and why that's a challenge for Web Components within their frameworks.  We should listen.  We should gain some experience.  We should also write the hell out of some Web Components and see what we can do.  Given new abilities I can't wait to see what developers come up with.  New capabilities inevitably breed new ideas and solutions that it's nearly impossible to imagine until it happens.</p>

		<p>Will it be as pretty as it might be if we started over?  Probably not, but, I think it'll actually get done this way.  If we make some progress, we inch the impossible destination ever closer.</p>
	</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Future Web Wants You]]></title>
        <id>https://bkardell.com/blog/The-Future-Web-Wants-You.html</id>
        <link href="https://bkardell.com/blog/The-Future-Web-Wants-You.html">
        </link>
        <updated>2016-08-24T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[A few weeks ago I gave a talk in Pittsburgh, PA at Code and Supply. It was recorded if you would rather watch the video (the actual talk is ~40 minutes, the video captures some of the Q&amp;A afterward as well), but I'm more comfortable writing and I thought it might be worth a stab at a companion piece that tries to make the same points/arguments in blog-post-size, so - here it is.]]></summary>
        <content type="html"><![CDATA[
	
	<div id="downloadsPrefs">
		<p style="font-size: 1.5rem">Note from the author...</p>
		<p>My posts frequently (like this one) have a 'theme' and tend to use a number of images for visual flourish. Personally, I like it that way, I find it more engaging and I prefer for people to read it that way.  However, for users on a metered or slow connection, downloading unnecessary images is, well, unnecessary, potentially costly and kind of rude.  Just to be polite to my users, I offer the ability for you to opt out of 'optional' images if the total size of viewing the page would exceed a budget I have currently defined as 200k...
		</p>
		<p><label>Show me all the images when I read <input type="checkbox" id="download-all-images-pref" checked=""></label></p>
		<p><label>Don't ask me again on this device <input type="checkbox" id="download-all-images-pref-save"></label></p>
		<p><button id="setDownloadPrefs">Dismiss</button></p>
	</div>
	
	<h1 class="contextual-heading" style="font-size: NaNrem;">The Future Web Wants You</h1>
	<p class="segue">A few weeks ago I gave a talk in Pittsburgh, PA at Code and Supply. <a href="https://www.youtube.com/watch?v=rwWEQPc5GRE" target="_blank">It was recorded if you would rather watch the video </a>(the actual talk is ~40 minutes, the video captures some of the Q&amp;A afterward as well), but I'm more comfortable writing and I thought it might be worth a stab at a companion piece that tries to make the same points/arguments in blog-post-size, so - here it is.</p>

	<div class="captioned-image p-attached p-attached-left optional" aria-hidden="true">
		<video data-src="/media/me-in-early-90s-dreaming" autoplay="" loop=""></video>
		Me in the mid-1990's dreaming about standards.
	</div>

	<p>In the mid-1990's, I didn't really know much about standards, but it seemed that they obviously existed.  So, when I heard that there was going to be a "standards organization" setup to bring together all sorts of powerful tech interests and that it would be led by Tim Berners-Lee (creator of the Web) himself, it didn't take much more to win my confidence.</p>

	<p>I suppose I imagined something between Michelangelo's Creation panel on the Sistine Chapel Ceiling and Raphael's School of Athens. Somewhere, perhaps high in a tower in a proverbial Mount Olympus where the Gods of programming - wise and benevolent beings would debate and design - and the outcome would be an elegant, simple and beautiful solution. They would show us the One True Way. Specifications might have been handed down on tablets of stone as far as I imagined.  The future was bright. They would lead me to the promised land.</p>

	<div class="captioned-image optional">
		<img data-src="/media/school-of-athens.jpg" alt="A painting of Raphael's School of Athens">My imagination of what a W3C meeting was like..
	</div>

	<p>By around 2009, I guess you could say that my outlook had "matured".</p>

	<div class="captioned-image optional" aria-hidden="true">
		<video data-src="/media/colbert-freaking" autoplay="" loop=""></video>
		Me, circa 2009 expressing my feelings on Web standards.
	</div>

	<p>I was jaded, yes.</p>

	<p>What had happened?  I decided to begin to try following standards a little more "from the inside" and I learned a lot.  I talk more about it in the video, but here is the most important takeaway I can give you: <em> There is no standard for standards.</em></p>

	<p>That is:  We really don't know what we're doing.  Standards are a really "young" idea.  In the roughly 100 years we've been trying to deal with them you can sum up a brief history something like this:</p>


	<ul>
		<li>Countries established national standards organizations - here in the US, ANSI.</li>
		<li>National Standards really weren't good enough for some things, so we got an international standards organization: ISO.</li>
		<li>ISO tweaked how they approached things a few times along the way, but when it came to networks and software, they were kind of abysmal.  After a decade of working on the OSI 7 Layer Model, Vint Cerf and some others left and created the IETF.  We got the internet. The IETF works very differently from ISO/ANSI.</li>
		<li>When Tim Berners-Lee came along he could have taken things to ISO, or the IETF - and in fact, he did choose the later.  Some things were standardized there, others languished and never actually reached what you could call, in IETF terms, a standard.  After some mulling, the W3C was created.  It works differently than ANSI, ISO or the IETF.</li>
		<li>When Internet Explorer began reverse engineering JavaScript and Netscape wanted to standardize it, they could have taken it to any of the above.  Instead, they took it to ECMA - a body previously dedicated to the manufacturing standards for computers in Europe.  Why?  Because historical events led them to believe that Microsoft would wield less powerful influence in this venue and that ECMA would be more fair to the creators.  It works differently than all of the above.</li>
		<li>After a period in which much of the world (including major players like Microsoft who controlled 95% of the browser market share at the time) decided that perhaps HTML wasn't the future we wanted after all and spent a decade trying to influence a different possible future in the W3C, a group defected and created the WHATWG which - again - works very differently than all of the above.  The WHATWG was spun up in 2004, the first draft of HTML was published in 2008.</li>
	</ul>
	<p>Along the way we've seen features that were disappointing (AppCache) things that aren't quite interoperable (IndexedDB/WebSQL), things that failed to materialize (native dialogs, the document outline) and battles over control of the "really official standard" as well as what that even means.  In late 2014, it reached W3C status that we might call 'standard' - however, there's still a lot that doesn't work in all browsers - HTML input types support, for example.  So it would be foolish to say that process really "worked well" in total either.</p>

	<div class="captioned-image p-attached p-attached-right optional">
		<img data-src="https://briankardell.files.wordpress.com/2016/08/frabz-tis-blasphemy-cc135d.jpg?w=291" alt="A grizzled man meme pointing and saying 'tis blasphemy!" width="291" height="300"> It's not blasphemous to suggest that we can do better.
	</div>

	<p>The interesting point here is that the reason there are many venues is simple: That the ones that came before them weren't working well and that each of these has tried to adapt to get better.</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Lessons Learned</h2>
		<p>In a nutshell: We've moved around a lot of variables a lot of times, trying to figure this out - but the one thing we haven't figured out how to tap into is developers.  This is strange because ultimately, it is developers who decide the fate of it all.  Over the years standards have come to say "we have businesses, we have academia, we have government."</p>

		<div class="captioned-image p-attached p-attached-left optional">
			<img data-src="https://briankardell.files.wordpress.com/2016/08/a967331492c30ea8002d09b1ebed6bbf.jpg" alt="A captioned scene from The Avengers where Tony Stark says 'We have a Hulk'"> Bring your army, we have developers.
		</div>

		<p>Yay.  That's great.  But, the truth is: we have <em>developers</em>.  Developers are like the Hulk,<em> their potential power is nearly limitless, it's just untapped!  </em>If you want to win the day - you<em> need the Hulk on your side.</em></p>

		<p>Think about it.  Microsoft quite literally "owned" the browser market and disbanded the team.  When work continued on HTML, it created what might have been an impossible impasse.  There was no obvious way to get there from here.</p>

		<p>What happened?  Polyfills. Remy Sharp coined the term and developers stepped up and filled the gap, providing a way forward.</p>

		<p>When virtually every major tech company on earth was focused on "how on earth can we imagine a new, better 'Web' based on XML?" - when billions of dollars in R&amp;D had been spent over a decade and everyone was desperately trying to figure it out, developers said "JSON: I choose you!".  Guess who carried the day?</p>

		<div class="captioned-image optional">
			<img data-src="/media/i_choose_you_03.jpg" alt="photo of Pokemon's Ash saying 'I choose you'!"> JSON: I choose you!
		</div>

		<p>It's not that standards bodies are "bad" at making standards. The problem, at its core, is how we approach/view standards and how we set up the right economics.</p>
	</section>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Fixing the economics</h2>
		<div class="captioned-image p-attached p-attached-left optional">
			<img data-src="/media/ewm-1.jpg" alt="The extensible web logo"> The Extensible Web Manifesto Logo by the great Bruce Lawson
		</div>
		<p>Around 2010, a lot of people began talking about what was wrong with Web Standards and how we might fix it. This led to, not a new standards body, but a joint statement of core principles by people involved at many levels: <a href="https://extensiblewebmanifesto.org/" target="_blank">The Extensible Web Manifesto</a>.</p>

		<p>Since it was published in 2013 it has become a statement of "core principles" for all of the major standards bodies involved with the Web.</p>

		<p>The Extensible Web Manifesto is a short document, but it comes from considerably more detailed discussions and a bigger vision. It's a vision that says that the economics are broken.  Failure isn't avoidable, it's inevitable.  Experiments are necessary in order to get there from here.</p>

		<div class="captioned-image p-attached p-attached-right optional">
			<img data-src="https://briankardell.files.wordpress.com/2016/08/capturew5.jpg" alt="A photo of an early fan with a lightbulb socket connecting cord" width="232" height="387">Early electrical appliances plugged into light sockets!
		</div>

		<p>As my friend Matt Griffin explains well both in his A List Apart Article <em><a href="http://alistapart.com/article/the-future-of-the-web" target="_blank">The Future of the Web</a></em> and his documentary on the Web <em><a href="http://www.futureisnext.com/" target="_blank">The Future is Next</a> </em>- you can't do it right until you've done it wrong.</p>

		<p>History, both of the Web and physical standards proves out that an evolutionary result is inevitable.  When homes were first electrified, for example, it was for the purpose of artificial light.  There weren't outlets - there was nothing to plug in.  Companies were battling over lights.  The result?  Early appliance inventors stepped up and filled the gap - they made cords that screwed into light sockets and birthed a whole new industry!</p>

		<p>The Extensible Web Manifesto simply argues that while we're busy arguing about light bulbs, <em>the really amazing stuff is what you can do given electricity</em> - and that we'll very likely miss it.  It's unanticipatable.  We will try, and we will fail.  All failures aren't dead ends though.  Service Workers, for example, are the result of many failed experiments.</p>

		<p>Some failure persists and only <em>looks</em> like failure for a time - the sum of the DNA however ultimately provide new possibilities far far beyond any of our plans.  If you were busy trying to "design" the perfect canine you'd never come up with a maned wolf.  Chances are you've never seen a maned wolf since they only evolved in a certain environment in South America.  But they are <em>amazing</em> and kind of a testiment to the power of evolution to create something that survives.  Ultimately, we need things that survive in all of the environments, even the ones we aren't thinking of - and to do that we need to be adaptable.</p>

		<div class="captioned-image optional">
			<img data-src="https://briankardell.files.wordpress.com/2016/08/maned-wolf.jpg" alt="a photo of a maned wolf - it looks kind of like half deer, half fox"> The maned wolf is real, and it is awesome.
		</div>

		<p>So, experiments and failure to reach "standard" are actually good things - that's how we can get better by exploring the edges and learning.  But the original Web plan made it the norm that experimentations ship with browsers - out in the open, and usually very high level. That led to serious problems of miscommunication and frustration and interoperability challenges.</p>

		<p>Polyfills showed us a different way forward though by mixing what little DNA we had exposed to us to fill the gaps.  If you could polyfill a feature because a few browsers didn't support it, you could just as easily fill it before <em>any</em> browser supported it.  Instead of proposing something that only works in a single browser - why not use the power of the Web to propose something that works in <em>all browsers.</em>  A <em>prollyfill (</em>will it become a standard? I dunno, prolly something like it).  Given lower level DNA, we can experiment.  The Extensible Web Manifesto calls this DNA "Fundamental Primitives" and it encourages standards to focus majority efforts on them.  Sometimes this may mean introducing new ones, but there's already a lot of rich DNA already locked away within the existing higher level APIs of the platform.  Exposing it means we have more raw materials and can prollyfill more and better experiments.  Beneath the existing features are all sorts of things that deal with network fetching, streaming, parsing, caching, layout, painting and so on.  Each of these is being currently being 'excavated'.</p>

		<p>The huge shift in economics that this could create is amazing.</p>

		<p>In the mid-2000's, a lot of people wanted something like flexbox.  It's only now, in 2016, that we can really begin to get broad feedback from developers who are largely just starting to see what they can use it for.  In all likelihood, they will find some faults and have some better ideas.  But if we could have <em>given</em> developers flexbox in a fashion that at least many of them could use to accomplish real things - that's a good incentive to be involved. The feedback loop could be tighted up considerably and it's possible because even if it fails to become a standard, it still <em>works to accomplish something.</em></p>

		<p>Wait a minute.  Hold the presses.  Think about that for a moment:  Why do developers want to learn about standards?  To feel smart?  Shit no.  Developers want standards because they have work to get done.  A standard way is portable. "Being standard" means it's had a lot of eyeballs and ultimately it winds up being "free".  But if they can't use a standard, they'll use a library.  Why?  Because things have to get done.  Libraries have <em>many </em>of the same benefits, but not all.  A lot of people ask me "why didn't we just standardize library X".  The answer is generally simple: No library has been proposed as a standard, in a fashion compatible with standardization.  They're usually too big, there are IP issues, and at the end of the day lots of people feel like they didn't get a say.  But... If a proposal is delivered like a prollyfill that works everywhere, it's roughly that - only in the right form!</p>

		<p>What we need then is a way to <em>incubate </em>ideas, build prolyfills and somehow get lots of eyeballs, use and participation.  We need to see what sticks, and what can be better.  We need ideas to fail safely without breaking the economics of participation or breaking the Web<em>. </em> And we need standards to act more like<a href="https://briankardell.wordpress.com/2013/05/17/dropping-the-f-bomb/"> dictionary editors</a> than startups.  I explain in the presentation that, in fact, most of their successes have been this and that the idea is not at all radical, but I'll spare you that here.</p>
	</section>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">A million voices cried out...</h2>
		<p>Meetup.com has 4 million people signed up who call themselves Web developers.  How can we involve even thousands of them the way that we do standards now?  The answer is simple: We can't.  Discussing things on mailing lists while we wait forever for consensus and implementation doesn't scale.  An incubator would need people helping cream rise to the top - it needs <em>networked </em>communication.  Just as in networking, not all noise needs to be in all places.</p>

		<p>Chapters.io is the answer (or at least the first attempt at an answer) to that problem.  Chapters is an effort to pair people who are involved with standards with meetups about the Web who can help them find, try, and discuss things that are in incubation (or proposed for incubation).  They provide a "safe" space for noisy and potentially less formal discussion.  Ideas can be collected, summarized and championed.</p>

		<p>This is not a far flung dream: It is happening. The Extensible Web has helped shape ideas like the <a href="https://wicg.io/" target="_blank">Web Incubator Community Group</a> (WICG) which provides just such an outlet for incubation and the <a href="https://www.smashingmagazine.com/2016/03/houdini-maybe-the-most-exciting-development-in-css-youve-never-heard-of/" target="_blank">Houdini</a> Task Force. Browser makers and standardistas are making proposals there, and we're figuring out how to incubate them.  Good ideas find champions and move forward.  The WICG also provides a Discourse instance where developers can subscribe to and participate in a way a lot more plausible than a mailing list.  Very recently, the <a href="http://blog.jquery.com/2016/07/27/the-jquery-foundation-and-standards-2/">jQuery Foundation announced that the standards team will be helping to establish, manage and champion chapters</a>.</p>

		<p>So what do you say?  Are you in?  The future Web wants you.</p>

		<div class="captioned-image share-image optional">
			<img data-src="/media/join-the-rebellion.jpg" alt="A Star Wars Poster with Leia in an Uncle Sam WWII style recuiting poster" width="284" height="432"> Don't be silent: Join the rebellion and help us organize a chapters.io near you.  Tweet interest to me @briankardell or <a href="https://github.com/jquery-foundation/standards/issues/48">open an issue like this</a> with the jQuery standards team and we'll see if we can help you get something started!  If you are in Pittsburgh, PA - <a href="http://www.meetup.com/Pittsburgh-Code-Supply/events/233600837/">join us</a>!
		</div>

	</section>
	<p class="thanksTo">
		<em>Very special thanks to my friends the great <a href="https://twitter.com/brucel">Bruce Lawson</a> and (the also great) <a href="https://twitter.com/garazi">Greg Rewis</a> for proofreading this piece.</em>
	</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[X-Web: Days of Future Past]]></title>
        <id>https://bkardell.com/blog/X-Web-Days-of-Future-Past.html</id>
        <link href="https://bkardell.com/blog/X-Web-Days-of-Future-Past.html">
        </link>
        <updated>2016-06-20T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[If you're not a comic book nerd, or a comic movie nerd, I suppose an explanation is necessary: In the Marvel Universe, there is a genetic mutation in some humans called "the X-gene". This gene leads to development of an exotic protein which can radically affect other genes in unpredictable ways. The result is mutants with all sorts of different "super" abilities. This is the basis for the story lines in the X-Men comics. Some humans, without the X-gene, see mutants as freaks, there is prejudice against them. Others would like to recruit them as weapons. Still others are friends. The mutant community is divided too. One group of mutants believe that they are a new homo superior destined to become the dominant species and they're willing to earn this by fear and force. Another group of mutants, the X-Men, led by Professor Xavier, believe that mutants and non-mutants should live in harmony. Mutants powers can even aid humanity. They work very hard for the advancement of peace and tolerance. And then, there are quite a lot of people - both mutants and everydays humans who are torn back and forth somewhere in the middle on a lot of the subtleties that arise. One of the most amazing parts of the narrative is that the leaders of the two groups are actually best friends. They actually agree on much. Most of their followers are not similarly friendly. It's kind of a hot mess, and it reminds me a little of the Web community.]]></summary>
        <content type="html"><![CDATA[
	
	<div id="downloadsPrefs">
		<p style="font-size: 1.5rem">Note from the author...</p>
		<p>My posts frequently (like this one) have a 'theme' and tend to use a number of images for visual flourish. Personally, I like it that way, I find it more engaging and I prefer for people to read it that way.  However, for users on a metered or slow connection, downloading unnecessary images is, well, unnecessary, potentially costly and kind of rude.  Just to be polite to my users, I offer the ability for you to opt out of 'optional' images if the total size of viewing the page would exceed a budget I have currently defined as 200k...
		</p>
		<p><label>Show me all the images when I read <input type="checkbox" id="download-all-images-pref" checked=""></label></p>
		<p><label>Don't ask me again on this device <input type="checkbox" id="download-all-images-pref-save"></label></p>
		<p><button id="setDownloadPrefs">Dismiss</button></p>
	</div>
	
	<h1 class="contextual-heading" style="font-size: NaNrem;">X-Web: Days of Future Past</h1>
	<p class="segue">If you're not a comic book nerd, or a comic movie nerd, I suppose an explanation is necessary: In the Marvel Universe, there is a genetic mutation in some humans called "the X-gene". This gene leads to development of an exotic protein which can radically affect other genes in unpredictable ways. The result is mutants with all sorts of different "super" abilities. This is the basis for the story lines in the X-Men comics. Some humans, without the X-gene, see mutants as freaks, there is prejudice against them. Others would like to recruit them as weapons. Still others are friends. The mutant community is divided too. One group of mutants believe that they are a new homo superior destined to become the dominant species and they're willing to earn this by fear and force. Another group of mutants, the X-Men, led by Professor Xavier, believe that mutants and non-mutants should live in harmony. Mutants powers can even aid humanity. They work very hard for the advancement of peace and tolerance. And then, there are quite a lot of people - both mutants and everydays humans who are torn back and forth somewhere in the middle on a lot of the subtleties that arise. One of the most amazing parts of the narrative is that the leaders of the two groups are actually best friends. They actually agree on much. Most of their followers are not similarly friendly. It's kind of a hot mess, and it reminds me a little of the Web community.</p>

	<p>I don't think it should be controversial to say "we aren't really where we'd like to be" on the Web. For some reason there seems to be more division that we'd like. Some would like to paint the future, or even the present, as being dark and desolate...</p>

	<div class="captioned-image optional">
		<img data-src="https://briankardell.files.wordpress.com/2016/05/fsztzvwcr6kpsmzcbjx2.jpg" alt="A still from X-Men Days of Future Past in which the quote applies">
		The future: a dark, desolate world. A world of war, suffering, loss on both sides. Mutants, and the humans who dared to help them, fighting an enemy we cannot defeat. - Professor Xavier
	</div>

	<p>However, I don't think that this is the case. It strikes me that our debates are as much about the past as they are about the future. Given this, it's worth stopping for a moment and assessing where we are, considering how we got to this place, and whether (and how) we will adapt.</p>

	<blockquote>Are we destined down this path, destined to destroy ourselves like so many species before us? Or can we evolve fast enough to change ourselves... change our fate? Is the future truly set?- Professor Xavier</blockquote>

	<p>For a little over 20 years, we have attempted to develop the vocabulary and features of HTML via a standards body. HTML was designed to give you the structure and function with a default look and feel. Author provided CSS prettied up the presentation. Because of this, with CSS disabled a user should, in theory, get a perfectly usable (if not very pretty) interface. Both HTML and CSS had forward-compatible parsers which effectively just ignore the stuff they don't understand. All of this is designed to make HTML work on the greatest number of browsers.</p>

	<p>Our lexicon has indeed increased, though, admittedly slowly. Unfortunately, even after reaching 'standard' even some of the authors don't agree on the proper use and meaning of some elements <code tag-esc="">main</code> is an example of this. In other cases, things that made it through to the "standard" (recommendation) are implemented by no one (the document outline is an example of this), so writing markup assuming that is actually wrong. In still other cases, even when elements pass standards and are widely implemented and experts agree on how they should be used, actual developers misunderstand and use them differently on an all too common basis - <code tag-esc="">address</code> and<code tag-esc="">article</code> are examples of this.  Some very common UI metaphors still have no native definition to use (tabs are an example of this). Most native elements have some styling limitations, sometimes these are trivial but other times not: <code tag-esc="">select</code>, for example, is unstylable in non-trivial ways - it is incapable of doing multi-line options or including any text formatting inside them. Some, like table-oriented elements, lack the semantics on their own (without ARIA attributes) to be meaningful enough for a screen reader to make sense of in a lot of cases, yet this is infrequently taught.</p>

	<p><strong>But there's more... let's go to the video...</strong></p>

	<p>In still other cases, combinations of these factors conspire against us, like the universe itself trying to keep us from success. For example: The vast majority of browsers have supported the <code tag-esc="">video</code> element for some time. Someone following lots of conventional advice would think that markup like this would be a pretty safe bet.</p>

	<code-format type="html"><pre>&lt;video crossorigin="anonymous" poster="http://cdn.example.com/link/to/poster.jpg"&gt;
  &lt;a href="http://cdn.example.com/link/to/video.blah"&gt;
    Download my video of a cat playing with a grape.
  &lt;/a&gt;
  ...
  &lt;track kind="captions"
    label="English captions"
    src="https://cdn.example.com/link/to/video-en.vtt"&gt;
  &lt;/track&gt;
&lt;/video&gt;
</pre></code-format>

	<p>In theory at least, unsupporting browsers would show a link.  A user clicking it would be prompted to download it, and then they could play it with their favorite media player (an even relatively recent OS would even help them find one if they didn't have one). Browsers that did support <code tag-esc="">video</code> would just go ahead and use it.  With no JavaScript and no author provided CSS at all, a simple, declarative HTML document can give you a pretty valid experience on just about every browser ever made and accessibility would be free.</p>

	<p>But actually, that's wrong. In fact, <em>regardless of whether you had a new browser or an old one in early 2016, your native <code tag-esc="">video</code>  element would be inaccessible!</em> It didn't really "work" to some extent or other. That is, if the user of a screen reader had an old browser, they could download the video, but not connect it to the captions files.</p>

	<p>Ouch, that is suck.</p>

	<p>But even if the user of a screen reader had a "modern" browser it was still potentially problematic: IE11 would fail to download the captions, regardless of whether you included the right CORS headers.</p>

	<p>Sigh, IE. Double Suck.</p>

	<p>Even outside of that, however, the player in all browsers but Chrome was not keyboard accessible.</p>

	<p>Triple suck.</p>

	<p>Oh yeah, did I mention that you can't style the controls of the player when it is embedded?</p>

	<p>Quadruple suck.</p>

	<p>But...</p>

	<p>We left out an important detail. If this was really the only option, HTML 5 might still be lingering as something we 'hoped' to achieve. The truth is that there are still commonly used HTML 5 bits that are not universally implemented even in modern browsers. The implementation space is, was, and always will be ragged. The aspect that launched a thousand ships with HTML uptake was the polyfill. Key to the polyfill, of course, is JavaScript. </p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">If the Web had an "X-Gene" it would be JavaScript.</h2>
		<p>Yes, the X-Gene can give you powers that are seriously abused. Yes, people might use their powers in not super ways. They might even do something like try to drop a stadium on the White House...</p>

		<div class="captioned-image optional" id="s" aria-hidden="true">
			<video autoplay="" loop="" controls="" data-src="/media/magneto-lifting-stadium">
			</video>
			Please, don't try to drop a stadium on the White House)
		</div>

		<p>But it can also give us powers to do good things, like, you know... Save the world. You might have noticed that there are a number of sites using the <code tag-esc="">video</code> element that are perfectly accessible when used with a modern browser, and styled when embedded as well. That's possible because of JavaScript. JavaScript made a solution that was more accessible possible. It's a nice thing to say "It should work in really old browsers, even without JavaScript enabled" but the truth is, that doesn't match where we are in a lot of cases. Saying "you don't have to use a modern browser or have JavaScript enabled... unless you are disabled" seems like... I don't know, kind of a dick move.</p>


		<p>This is the reality of where we actually are as I see it.</p>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">Enter: Xavier's School for Gifted Youngsters</h3>
			<div class="captioned-image p-attached p-attached-left share-image optional">
				<img data-src="/media/x-web-first-class.jpg" alt="Professor's Xavier's School For Gifted Youngsters Logo">
				X-Web: First class.
			</div>

			<p>In the comics, Professor Xavier runs a "School for Gifted Youngsters". A place whose purpose Marvel's wiki describes as "train young mutants in controlling their powers and help foster a friendly human-mutant relationship." What if we could learn to harness our powers for good? What would it look like? If, as in Days of Future Past, we could go back in time and apply those same lessons, what kind of difference could that make - and is it worth applying them now?</p>

			<blockquote>The past: a new and uncertain world. A world of endless possibilities and infinite outcomes. Countless choices define our fate: each choice, each moment, a moment in the ripple of time. Enough ripple, and you change the tide... for the future is never truly set. - Professor Xavier</blockquote>


			<p><a href="https://extensiblewebmanifesto.org" target="_blank">The Extensible Web Manifesto </a>stresses the duality of ideas that <em>we want developers to write more declarative code, not less</em> <strong>and</strong> <em>we want browsers to focus on low-level-features. </em> Those things can seem at odds, unless you understand the intent. JavaScript is already a superpower. Very much Web as we know it could not rightly exist without it, no matter how much we'd like to pretend otherwise. Without JavaScript, there are no polyfills. Without JavaScript, there are unresolvable accessibility issues. We might wish it weren't so, but it is.</p>

			<p>What good is spending years debating whether we should have a high level element, followed by years of ragged implementation that we couldn't patch, followed by years of unhappiness that it still doesn't give us what we want.</p>


			<div class="captioned-image p-attached p-attached-right optional">
				<img data-src="https://briankardell.files.wordpress.com/2016/05/x-men-days-of-future-past-storm-wallpaper.jpg" alt="">
			</div>

			<p>Imagine then, that we could go back in time - low level features exposed and the ability to mint custom elements. Imagine, if you can, that this was part of the Web from Day One. It's a big ask of the imagination, I realize, but it requires no more suspension of belief than time travel or a genetic mutation that somehow grants its possessor control over the weather, and we find that entertaining, so try to follow along...</p>

			<p>Would we have the vocabulary that we have today? Doubtful. We'd have addressed these issues with experience by now. This is the ultimate goal of prioritizing the low-level-features -- so that we can actually figure out the high level in a sane way. <em>We want low-level features exposed because we want developers to <a href="https://briankardell.wordpress.com/2013/05/17/dropping-the-f-bomb/">help us define new vocabulary</a>.  W</em>ould we have debates about whether you should count on JavaScript? I don't think so. It can fail to download - but so can your page midway through and that's no good either. There are ways we can reduce that likelihood and improve performance too, and we're working on it. It can have an error, but in truth, so can a Web browser's native code. The trouble is that we have no common, good way to currently find and evaluate high quality custom elements. However, if this became common practice - if it had been a thing since Day One - we'd have solved that by now, 25 years in.</p>

			<p>Given a better vocabulary, things that currently require authors to write complex HTML, CSS and JavaScript can be simplified. We can say more with less.</p>

			<p>That's good for authors.</p>

			<p>That's good for accessibility.</p>

			<p>That's good for performance.</p>

			<p>That's good for slow connections.</p>

			<p>JavaScript is not the enemy, it's the the killer asset. I'd also like authors to have to write less of it by harnessing common high level, preferably declarative code.</p>

			<p>This is the present I wish that we had. Unfortunately, changing the past is only an option in fantasy. What we can do, however, is learn the lessons and make today the new Day 0, and begin a new timeline. Not disconnected from the past, but with a different path forward.</p>

			<p>We have the powers, now let's learn to use them really well. What we really need is a Professor Xavier's Home for Gifted Youngsters where we can go to find the quality X-Web. This problem is the one I'm most interested in. <a href="https://wicg.io" target="_blank">wicg.io</a> is a step in the right direction. More soon, I hope.</p>

		</section>

	</section>


]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prognostication and the Failure of the Web]]></title>
        <id>https://bkardell.com/blog/Prognostication-And-The-Failure-Of-The-Web.html</id>
        <link href="https://bkardell.com/blog/Prognostication-And-The-Failure-Of-The-Web.html">
        </link>
        <updated>2016-05-06T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[For almost as long as there has been a Web to write about, people have been prognosticating the death of the Web.  Mine is a different kind of prediction, but as I look into my crystal ball, I'm absolutely certain of it:  The Web will fail. Let me tell you what I see through the glass...]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Prognostication and the Failure of the Web</h1>
	<p class="segue">For almost as long as there has been a Web to write about, people have been prognosticating the death of the Web.  Mine is a different kind of prediction, but as I look into my crystal ball, I'm absolutely certain of it:  The Web will <em>fail.</em> Let me tell you what I see through the glass...</p>

	<div class="captioned-image share-image">
		<img src="/media/fortune-teller.jpg" alt="fortune teller">This awesome stock art depicting me predicting failure thanks to http://obliviate-stock.deviantart.com/
	</div>
	<hr style="visibility: hidden">
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">A Story of Failure</h2>
		<div class="captioned-image p-attached p-attached-left">
			<img alt="" src="https://briankardell.files.wordpress.com/2016/05/86632h.jpg">
			A Photo of Scott's phonautograph on display in the Smithsonian
		</div>

		<p>In school, most of us learn to associate the recording of sound with Thomas Edison who invented the phonograph in 1877.  What a lot of people don't know, however, is that two decades before Edison, a man named Édouard-Léon Scott de Martinville invented, used and patented a means for recording sound waves.  The "phonautograph,"  as he called it, used vibrations from a brush to capture the sound waves from within a cone to make lines on soot covered paper as it passed along a rotating drum.</p>

		<p>If you've never heard of the phonautograph, you're probably thinking "wow... that's amazing!?  How did one play it back?" Of course, that's a natural question.  What could be more natural?  So you'll probably be shocked to learn "you couldn't".</p>

		<p>Let that sink in for a moment.  The man invented a sound recorder that couldn't be played back.</p>


		<p>Why would someone even invent such a thing?  To understand that, you'll have to some mental gymnastics and put yourself back in Scott's world.  Until that time, people had been recording things for thousands of years - by <em>writing it down</em>.  Sound was an expression of thoughts from your brain, through your voice.  There were lots of alphabets and even things like stenography which Scott had studied that made it more efficient.  Words were made of phonemes.  In all these cases, by transforming the phonemes into an alphabet, our brain learned to make sense of these markings via our eyes, rather than our ears.</p>

		<p>Scott just assumed that if he could manage to get the soundwaves "written down" then people could just learn to "read" soundwaves.  He spent a lot of time on this, and, in terms of reaching his proposed destination, <em>he failed kind of epicly:  </em>You can't read soundwaves with your eyes.</p>

		<p>Except that, as we see from this vantage point, he didn't.  While he couldn't even see or conceive of "playback," his work enabled others to see further.  <em>As a side note - many many years later, when we got to where we have computers that could be made to 'read' a sound wave, a team actually did just that and '<a href="https://www.youtube.com/watch?v=uBL7V3zGMUA&amp;feature=youtu.be&amp;t=44s" target="_blank">played back</a>' some of Scott's recordings.  The quality is pretty terrible, as you might expect, but it is undeniable that he was successfully recording.</em></p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Our Inability To See the Future</h2>
		<p>Our ability to see the future is, as we just saw, very tied to our place in time and our current perspective.  Very frequently, in trying to solve one problem, we are affecting another.  If we measure "failure" by intent to complete what we set out to do, it's truly astonishing how much around us that we'd typically view as huge success was actually rooted in "failure".  When he created sound recording and playback, Edison imagined that people would use it for correspondence.  Again, his world was a world of writing and mail.  He prognosticated that a fine and probably common use of his technology would be for someone to record a "letter" and pop it in the mail.  When Bell invented the telephone he imagined that it might be used to pipe music from a performance to an audience remotely.  When people got their hands on both, they were basically used inversely.  Meanwhile, Lee de Forest who helped pioneer AM radio, had imagined something so different that he sent a letter to National Association of Broadcasters saying ""What have you done with my child, the radio broadcast? You have debased this child, dressed him in rags of ragtime, tatters of jive and boogie-woogie."  Ever used super glue?  That isn't what he was trying to invent.  Not remotely.</p>

		<p>Have a look-see here...</p>

		<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Sir Tim Berners-Lee thinks that if we can predict what the internet will look like in 20 years, than we are not creative enough. <a href="https://twitter.com/hashtag/www2016?src=hash">#www2016</a></p>— Dragan Milchevski (@Agandrau) <a href="https://twitter.com/Agandrau/status/720260781481308161">April 13, 2016</a></blockquote>
		<script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

		<p>That's pretty relevant because in many ways the Web today is hardly what Tim Berners-Lee was trying to accomplish at all.  Tim imagined that browsers would be equal parts authoring environments and that the Web would be a very two-way medium.  Instead, it has been until recently, very one way.  And it still isn't a real editing environment as imagined.  Tim imagined annotations, we've still not got those, really.  In fact, some early browsers had them and took them out.  Tim didn't initially see scripting, nor CSS nor HTML <em>being</em> the content so much.  His initial use case was research, yet still, I can't find most scientific research available in HTML format.  By the measure of accomplishing the goals of the time, the Web is kind of a failure... But is it?  No way.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Failure vs Death</h2>
		<p>he death of the Web would mean it was over, done.  But failure is something different, or at least it can be.  Failure can be good. It's necessary even.  If you are capable of seeing or hearing this post, it's only the result of millions of failures in DNA and the consequence of a process with no long-term vision at all - just an inherent bias toward not dying long enough to reproduce.</p>

		<p>But the really interesting thing to note is that this is possible only because failures breed opportunity.  The entire universe (but especially humanity) seems very adept at finding opportunity and exploiting it.  The general trend then is usually, at least from the perspective of those viewing it, "up" as we capitalize on an increasing number of opportunities.</p>

		<p>By these measures, the Web already <em>is</em> a spectacular failure.  Emphasis on the word "spectacular".  It's absolutely great in some ways, but not quite exactly as intended in the first draft.  Even Tim's vision of what the Web could, should or might possibly be is affected by what's all around.</p>

		<p>Seeing the difference between the two (death and failure), however, kind of matters.  The reason that the Web isn't going to die, in my opinion, is that it is learning this lesson.  All of the major Web Standards Bodies have "adopted" the <a href="https://extensiblewebmanifesto.org" target="_blank">Extensible Web Manifesto</a> and they're hard at work taking the stuff that works and just exposing more opportunity DNA.  The W3C Technical Architecture Group (TAG) is helping to make sure that W3C projects keep this in mind and don't go off the track with spec reviews and community and working group-coordinated efforts like <a href="https://extensiblewebreportcard.org/" target="_blank">The Extensible Web Report Card</a> and task forces like <a href="https://dev.opera.com/articles/houdini/" target="_blank">Houdini</a>.  Friends at the WHATWG are doing lots of hard work explaining nitty-gritty details and getting those hard last-mile agreements on ideas like Streams and Fetch.  ECMA provides prollyfills and transpilers before specs are finished and accepts feedback  The W3C Web Incubator Community Group provides a place for lots of ideas <em>from anywhere </em>to take root, be discussed, prollyfilled and, frequently usefully used before they take deep roots in standards... And importantly<em> to fail.  It </em>offers value along the way and provides new opportunities, which begin to let us see the future more clearly.  Finally, the W3C Advisory Board (AB) is working on changes to the W3C Process which would require <em>all </em>of the things to be incubated.</p>


		<p>I think that the Web has a bright and vibrant future ahead, full of beautiful failures.</p>
	</section>

	<p class="thanksTo"><em>Note, if you enjoyed the stories of failure in this piece, I'd highly recommend <a href="http://www.amazon.com/How-We-Got-Now-Innovations/dp/1594632960">"</a></em><a href="http://www.amazon.com/How-We-Got-Now-Innovations/dp/1594632960"><span id="productTitle" class="a-size-extra-large">How We Got to Now: Six Innovations That Made the Modern World" by Steven Johnson.</span></a></p>

]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[A Brief(ish) History of the Web Universe - Part IV: New Hope(s)]]></title>
        <id>https://bkardell.com/blog/Brief-ish-History-of-The-Web-Part-4.html</id>
        <link href="https://bkardell.com/blog/Brief-ish-History-of-The-Web-Part-4.html">
        </link>
        <updated>2016-04-10T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[
		It's early 1994. AT&amp;T has purchased Go and PenOS (see&nbsp;Part I: The Pre-Web) and now they are pulling the plug. &nbsp;SmartSketch FutureSplash (again, Part I) won't be released. Its makers Jonathan Gay and Charlie Jackson briefly try porting to the desktop, but there they would have to compete with well-funded and mature products and that isn't practical. &nbsp;Keep them in the back of your mind, we'll come back to them.
	]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">A Brief(ish) History of the Web Universe - Part IV: New Hope(s)</h1>
	<p class="segue">
		It's early 1994. AT&amp;T has purchased Go and PenOS (see&nbsp;<a href="/blog/Brief-ish-History-of-The-Web-Part-1.html">Part I: The Pre-Web</a>) and now they are pulling the plug. &nbsp;SmartSketch FutureSplash (again, Part I) won't be released. Its makers Jonathan Gay and Charlie Jackson briefly try porting to the desktop, but there they would have to compete with well-funded and mature products and that isn't practical. &nbsp;Keep them in the back of your mind, we'll come back to them.
	</p>

	<p>For the past few years, Tim Berners-Lee's "Web" concept has experienced increasing growth month over month thanks to a number of large number of contributing factors (see <a href="/blog/Brief-ish-History-of-The-Web-Part-3.html">Part III: The Early Web</a>). Still, its&nbsp;audience is comparatively almost microscopic by 2016 standards and mainly composed of academics and hard-core internet and markup enthusiasts. But, to put this into perspective: Just having a computer at home remains a pretty novel concept, even in America. Studies reveal that where they do exist they are frequently underused. While it's true that from 1984 to 1994 the percentage of homes with a PC tripled, it is still only 1 in 4 &nbsp;US homes that has a computer. Of those, many don't have modems or any kind of internet access. Only about 2% of Americans have access to the internet from home. Of this, only a small fraction are using the Web.</p>


	<div class="captioned-image" style="margin-top:0">
		<img src="/media/early-households-with-internet-chart.gif" alt="">
	</div>

	<p>Note carefully&nbsp;that that 2% represents <em>all internet access - not just the Web. &nbsp;</em>Very many people are getting on the "internet" through an online service. &nbsp;&nbsp;Just a few months ago, America Online began direct mailing disks to people encouraging them to get online. It now has advertisers and 1 million members, many of whom are not the same crowd as the Web right now. The world is confused about the Internet, online services like AOL and the Web, but this isn't all bad news for the Web. It introduces a whole lot of people to the idea of getting "online" and Moore's law continues to lessen the price of computers and more and more of them are coming with increasingly capable modems. &nbsp;Even now, however,&nbsp;t<em>he Web itself (including work and home) only accounts for only about 2.5% of Internet traffic.&nbsp;</em></p>


	<p>Given the small size, the number of browsers that have sprung up is truly astonishing, and each has extended Tim's original definition of HTML with their own ideas. A few people, like Dan Connolly, have been actively working on trying to hammer down agreements and a base standard. Over the past year however a new dominant factor has emerged: <em>Mosaic</em>.</p>

	<p>Of those that are using the Web at this point, estimates are as high as 97% of them are now using the Mosaic browser (see <a href="/blog/Brief-ish-History-of-The-Web-Part-3.html">Part III: The Early Web</a>) which is available on many platforms and comparatively easy to install thanks to the hard work of folks like Marc Andreessen, Eric Bina, Chris Wilson, Jon Mittelhauser and Aleks Totic. It's name has become so synonymous with using the Web that the line between the two has become blurred: Even people who are interested in the Web begin to ask if you're "on Mosaic" instead of "on the Web".</p>


	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">"Web Time..."</h2>
		<p>The next few months is almost a blur, so much happened so fast. This pace would become known to some as "Web time".</p>

		<div class="captioned-image p-attached p-attached-left" style="margin-top:0">
			<img src="/media/netscape1994.jpg" alt="">
			A screenshot of the Netscape home page from 1994 featuring an early "Mozilla" monster
		</div>

		<p>In March 1994, Silicon Graphics, Inc. (SGI) founder Jim Clark &nbsp;begins&nbsp;working on a business venture with Mosaic creator Marc Andreessen. They'll hire up a lot of talent from both SGI and NCSA and they're working on some server products and, more importantly a commercial browser built to kill Mosaic. &nbsp;Initially it is called "MCOM" (Mosaic Communications). &nbsp;Internally, the browser project is&nbsp;called "Mozilla" (a name given to it by another co-founder, Jamie Zawinski, who would go on to write much of the Unix version of their 1.0 browser) or "Mosaic-killer". &nbsp;As you might imagine, the MCOM name was a problem and so "Netscape" was born. &nbsp;Very early Netscape website (while still in the mcom.com domain) even featured a "Mozilla" character originally created by employee Dave Titus.</p>

		<p>Two months later in May, NCSA hands off licensing of&nbsp;Mosaic to Spyglass, Inc. - a commercial offshoot of University of Illinois at Urbana-Champaign built to monetize research there. Spyglass would license the Mosaic product for modification and distribution. &nbsp;At least one of those licenses will come back and change things again very soon...</p>

		<p>That same month, the first World Wide Web Conference is held. Attended by 380 people from around the world. &nbsp;Unsurprisingly, overwhelmingly made-up of technically enthusiastic academics. Thanks in large part to Dan Connolly's presentation entitled "Interoperability: Why Everyone Wins" it launched the first very serious efforts behind creating an HTML standard. However, by this point, just what the baseline should be is very fuzzy: Almost no-one stuck&nbsp;to Tim's original specifications to begin with and some aspects of it already seem defunct. &nbsp; HTML has been re-spec'ed into an actual implementation of SGML, except still not quite really... Some browsers (even Tim's now) have inline images thanks to hard-pulling/pioneering work by Marc Andreessen. Some have tables, some had forms. &nbsp;Dave Raggett has a proposal called HTML+ which contains a lot of this. &nbsp;Further adding to the challenge, Tim Berners-Lee has also begun talks of starting a consortium modeled after the x-consortium designed to help the Web remain open, competitive and interoperable.</p>

		<p>Meanwhile, Sun Microsystem's Green Team (see <a href="/blog/Brief-ish-History-of-The-Web-Part-2.html">Part II: Time</a> and <a href="/blog/Brief-ish-History-of-The-Web-Part-3.html">Part III: The Early Web</a>) has been given a new lease on life by the success of Mosaic. They imagine a Web in which "write once, run anywhere" applications could be delivered regardless of the user's operating system because of their Oak VM (later "Java") - and their foot in the door will also be a Mosaic competitor: "WebRunner" (soon "HotJava") which the team is getting increasingly excited about.</p>

		<p>The summer was abuzz with talks of styling too. &nbsp;With more authors creating content and finding new uses, a typewritten page seemed pretty insufficient. &nbsp;SGML didn't really have a single standard but it had helped create a small group of what appeared to be reasonably successful ideas and from these discussions there came&nbsp;<a href="https://www.w3.org/Style/History/Overview.html" target="_blank">a myriad of proposals</a>.</p>

		<p>Two months later, in July 1994, Dan Connolly presents HTML 2.0 at an IETF meeting in Toronto, an IETF Working group is formed. &nbsp;But in October, two key factors emerged: First, an agreement to start the World Wide Web Consortium (W3C) is signed setting up the eventual future question of where the HTML standard will live and what the relevant roles will be. &nbsp;Second, <a href="https://www.w3.org/People/howcome/p/cascade.html" target="_blank">Hakon W Lie proposes "CSS"</a> which will become one of the first targets of the new W3C.</p>

		<p>In November 1994, HTML finally received an IETF identifier: <a href="https://tools.ietf.org/html/rfc1866" target="_blank">RFC-1866</a>.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Money</h2>
		<p>There was a lot of speculation about how one might make money with the Web, but 1994 put some real ideas to the test.</p>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">Ads</h3>
			<p>On&nbsp;October 27, 1994, HotWired.com launched the first major banner ads, including a campaign that looked like this:</p>

			<div class="captioned-image share-image" style="margin-top:0">
				<img src="https://briankardell.files.wordpress.com/2017/04/first-ever-banner-ad.gif" alt="The first ever banner ad saying 'Have you ever clicked your mouse right here? You will.">
				The first ever banner ad
			</div>

			<p>It was the first real, modern(ish) attempt to apply the advertising model that had worked for TV, newspapers, magazines, etc - to&nbsp;the Web. If you're using the Web in 2016 as you're reading this, you're probably aware that this is how the vast majority of Web content is funded, and it's pretty debatable whether the Web would still exist in anything remotely resembling its current form without ads. &nbsp;Why? &nbsp;Because the Web had no payment or compensation model. &nbsp;In fact, not only did it have&nbsp;no concept of how you could monetize, the insecure nature of HTTP, the protocol that made it possible, effectively made things like privacy, which are necessary for transactions,&nbsp;nearly impossible.</p>
		</section>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">Licensing, Commerce and the Netscape Factor</h3>
			<p>One&nbsp;could reasonably make the case that Netscape changed everything. &nbsp;It was about this same time (late 1994)&nbsp;that&nbsp;Netscape began&nbsp;releasing beta versions of Netscape Navigator. Within just a few months it overtook&nbsp;Mosaic as the dominant browser in 1.0. Very much like all browsers before it, Netscape innovated and added its own tags to HTML which are part of neither HTML 2.0 nor the new HTML 3.0 specifications (notably <code tag-esc="">font</code> and <code tag-esc="">center</code>). "What's that" you say, "3.0?! Where did that come from?!". As you might expect, history doesn't stand still - things that weren't included in the pending HTML 2.0 standard are being collated into a possible HTML 3.0 standard. As the now dominant force, however, and with the increasing growth of the community being introduced to HTML without past knowledge and theory - and this is critical: It actually&nbsp;made&nbsp;it possible to do things that everyone actually wanted. &nbsp;Regardless of how it accomplished it, these things made the Web a <em>lot</em> more interesting. &nbsp;<em>A hack that works and can get used, as it turns out, is of&nbsp;considerably more practical value than theoretical purity that doesn't. &nbsp;</em></p>

			<p>As a commercial endeavor, Netscape realizes that they need to make e-commerce possible and the Web commercially viable. As plain-text, HTTP wasn't going to cut it. Netscape/Dr. Taher Elgamal's SSL is the result, but before version 1.0 can ship it's realized that there are serious concerns and so, a lot like it was with HTML, SSL 2.0 is the first one most people hear about. It is released in February 1995 and if you were there, it might have looked something like this:</p>

			<div class="captioned-image optional" style="margin-top:0">
				<iframe width="560" height="315" data-src="https://www.youtube.com/embed/Ojmng198Ni0" frameborder="0" allowfullscreen=""></iframe>
				<div>A video of early Netscape in action</div>
			</div>

			<p>That same month the HTML 2.0 specifications are revised at IETF in hopes of actually getting something passed. Changes are mostly around MIME, encoding an improved DTD and simple formatting.</p>

			<div class="captioned-image" style="margin-top:0">
				<img src="https://briankardell.files.wordpress.com/2017/04/ae02.jpg" alt="">
			</div>

			<p>By March 1995 Sun was giving some demos to people outside and "Java" was&nbsp;starting to make news. &nbsp;The San Jose Mercury News ran a front-page piece entitled "<a href="https://web.archive.org/web/19961220215426/http://www.sjmercury.com/archives/hotjava.htm" target="_blank">Why Sun thinks Hot Java will give you a lift</a>". &nbsp;Sun released Java for public download&nbsp;and in short order Sun's T1 line were&nbsp;so saturated that developers weren't able to download. The piece explains that browsers are dumb (not to have, just not especially capable) and in the piece, Marc Andreessen is quoted giving it praise.</p>

			<p>Thinking that a browser that viewed HTML was "dumb" wasn't new. &nbsp;As explained in <a href="/blog/Brief-ish-History-of-The-Web-Part-1.html">Part I: The Pre-Web</a>, there were plenty of more capable hypermedia systems <em>before</em> HTML. &nbsp;As explained in <a href="/blog/Brief-ish-History-of-The-Web-Part-2.html">Part II: Time</a>, Tim didn't <em>expect</em> HTML to be the whole thing he just thought that the "dumb" parts would be&nbsp;the ones that connected everything. &nbsp;As explained in <a href="/blog/Brief-ish-History-of-The-Web-Part-3.html">Part III: The Early Web</a>, others like Pei Wei had already shipped a browser capable of doing embedded programs very much like applets. And Midas, developed at Stanford, had sort of pioneered the idea of plugins (it could display postscript). &nbsp;Again, this wasn't shocking, but rather seemed exciting to Tim. &nbsp;So, unbeknownst to developers at Sun, but certainly unsurprisingly: &nbsp;Certain players at Netscape have <em>also</em> been thinking about the need for a&nbsp;less-dumb&nbsp;imperative language in the browser.</p>

			<p>Netscape folks from SGI like Jim Clark and Kipp Hickman&nbsp;have been courting an enterprising engineer named Brendan Eich (also an SGI alumnus) with the lure of doing "Scheme in the browser". You might think that this means that Brendan was an advanced Scheme developer, but that's not the case at all. In fact, he had no practical professional experience with Scheme at all. Instead, Brendan was something of a language nerd and saw a lot of promising things in Scheme that were&nbsp;lacking in other languages and he was interested in seeing what he could do. Quietly, and without fanfare, he left&nbsp;MicroUnity for Netscape in April 1995. &nbsp;Netscape who was just releasing Navigator&nbsp;1.1 which, as noted in&nbsp;<em>Information&nbsp;Today,&nbsp;</em>contained what would be a new bit of DNA:</p>

			<blockquote>Netscape Navigator 1.1 includes sophisticated new features such as the Netscape Client Application Programming Interface (NCAPI) for easy integration with third party applications, advanced layout capabilities for more visually compelling pages, dynamic document updating for changing information and enhanced security features.
				<div> - <a href="https://www.questia.com/read/1G1-16926084/netscape-unveils-netscape-navigator-1-1" target="_blank">Information Today, April 1995</a></div>
			</blockquote>

			<p>The plugin architecture, developed in large part&nbsp;by John Giannandrea (now working on Search / Deep AI at Google) spurred&nbsp;a lot of excitement: A number of companies quickly got to work, including Macromedia - the maker of the popular Director software (see <a href="/blog/Brief-ish-History-of-The-Web-Part-I.html">Part I: The Pre-Web</a>), Real Networks and Sun.</p>

			<p>Unfortunately, by the time Brendan started, Marc Andreessen has also begun talks with Sun to license their Java Virtual Machine (VM) for redistribution within the Navigator browser, for embedding applications. Given this and some unfortunate headcount issues, Brendan is initially placed on the <em>server</em> team.</p>

			<p>It's May 1995 before Brendan is moved to the client team and begins work on a project code-named "Mocha". Certain factions within Netscape are scheming for a possible alternative to Java. If your first reaction is "why?" let me explain: People like Brendan and Andreessen realize Java is rather close to C++ and this is very unlike the Web so far which is pretty easy for amateurs and beginners to get started with. Writing code in Java requires a developer with an understanding of compilation, classes, data types, a main method, packages and so on. Microsoft is making a lot of headway in expanding the number of people who can program, by contrast with Visual Basic. "The Web needs something like that", they argued. For that kind of idea to really work, they decided that it would be necessary to be able to code right there in the page. It would have to be interpreted, not compiled. It would have to have simpler qualities. &nbsp;In order to keep the project alive, get funding and not destroy other potentially lucrative avenues with the Sun agreement, they realize that he will have to pretty quickly show that it is possible to do a language in the browser, show that it isn't redundant with Java.</p>

			<p>While he hasn't started anything, Brendan has been quietly thinking about this since before he came on: What kind of language would work? &nbsp;Being a language buff, he knows the history of languages and bits about their theory. &nbsp;He is drawn particularly to languages like Self. &nbsp;Most programmers have heard references to Xerox-PARC's Smalltalk as being way ahead of its time and elegant, but certain people at Xerox-PARC went on to work on better&nbsp;models, among them,&nbsp;Self. &nbsp;David Ungar pioneered the idea of reducing the number of concepts and maximizing their utility. &nbsp;Self was prototypal and that was appealing. &nbsp;Brendan was also drawn to aspects of HyperTalk, the programming language available for the wildly successful HyperCard (see&nbsp;<a href="/blog/Brief-ish-History-of-The-Web-Part-I.html">Part I: The Pre-Web</a>) for inspiration on&nbsp;how you could put these things together in a way that amateurs could glue things together.</p>

			<p>And so, in 10 days in May 1995, Brendan put together <em>just enough:</em> &nbsp;The core language parser, interpreter, decompiler, and minimal standard library core language. &nbsp;He integrated it via Lou Montulli's protocol handler (Lou Montelli was another Netscape founder who also co-authored the Lynx browser). &nbsp;Using these , Brendan created a demo in which you could use it&nbsp;as a protocol in the browser's URL bar. &nbsp;If you've ever done <code>javascript:alert('hello world')</code> or something you're using a similar idea. Here, however, typing the protocol <code>mocha:</code> would launch a primitive frameset based console.&nbsp; Using this Brendan was able to give a demo that would&nbsp;both generate&nbsp;enough interest and allay concerns of redundancy with Java. &nbsp;It wouldn't officially become "JavaScript" until Bill Joy of Sun signed the trademark license with Marc, Brendan and Rick Schell (Netscape VP of Engineering) later on December 4, 1995. &nbsp;For convenience, we'll still refer to it as JavaScript.</p>

			<p>A few more challenges for JavaScript: &nbsp;First, the Netscape browser (nor really any browser save perhaps Viola) had been written to have an embedded scripting language intertwined in the mix. As a result, Brendan compared trying to shoehorn this in in a rush to juggling with chainsaws. &nbsp;Why the rush? &nbsp;well, that's the second challenge: &nbsp;It would have to ship in the same release as Java (Netscape 2). &nbsp; Here's why:&nbsp; Because while&nbsp;the tech world is abuzz about both Netscape and Sun,&nbsp;yesterday's talk about the rising power that was Microsoft has turned into speculation that Bill Gates has missed the boat. &nbsp;Everyone knows that it's just a matter of time before Microsoft leans in and attempts to stake claim, and the best way to prevent that is to be too good and too well entrenched by the time it arrives. &nbsp;People at&nbsp;Netscape realize that if they can't get a firm grasp on the market, Microsoft will just eat them up. &nbsp; That same month, Bill Gates&nbsp;sends a lengthy internal Memo titled "<a href="http://www.lettersofnote.com/2011/07/internet-tidal-wave.html" target="_blank">The Internet Tidal&nbsp;Wave</a>" setting precisely those priorities - and Microsoft licenses Mosaic from SpyGlass and "Internet Explorer" is conceived.</p>

			<p>Netscape 2 also shipped with NPAPI - a plugin architecture that used the protocol handler to associate another, helper program for understanding, handling and (potentially) rendering other kinds of non-HTML content.</p>

			<p>At the August SIGGRAPH (Special Interest Group on GRAPHics and Interactive Techniques) conference that year Steve Jobs gave the keynote. &nbsp;He&nbsp;had bought Pixar and they were&nbsp;doing incredibly interesting things - including working with Disney to produce the first full-length computer animated feature: Toy Story. &nbsp;But a lot of the talk was about the internet and the Web. &nbsp;James Gosling of Java fame sat on a panel called&nbsp;Set-Top Boxes - The Next Platform" in which he said:</p>

			<blockquote>It's madness out there... My personal guess is that there will never be 'intelligent set top boxes'.
			<div>-<a href="http://www.siggraph.org/s95/PANELS.PDF" target="_blank"> James Gosling SIGGRAPH 1995 (page 5)</a></div>
			</blockquote>

			<p>Another panel was called "Visualizing the Internet: Putting the User in the Driver’s Seat" and it really centered a lot on "Wow, this WWW thing is really taking off and it kind of looks like shit." &nbsp;Jonathan Gay who opened our piece was there too and heard a lot of people saying that the internet needed a really good vector based animation product. &nbsp;Netscape's NPAPI gave him the tool that he needed and his product was rebranded as "FutureSplash Animator" and the "FutureSplash plugin". &nbsp;Just start removing letters and you might sense where this is evolving before we get there in Part V. &nbsp;<em>Note: If you want to get a jump on it, it turns out that after posting I discovered that my friend Rick Waldron wrote<a href="http://www.flashmagazine.com/news/detail/the_flash_history/" target="_blank"> a whole piece on exactly this subject </a>about 16 years ago.</em></p>

			<p>On August 9, 1995, Netscape made an initial public offering and the world, to put it mildly,<em> went nuts.</em></p>

			<p><em>Special thanks to friends like Brendan Eich, Chris Wilson and Simon St Laurent for helping fill gaps, stay honest and fix typos. &nbsp;Especially Brendan, without whom this post would not have been possible on many levels.</em>

		</p></section>


	</section>


]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TokenLists: Missing Web DNA]]></title>
        <id>https://bkardell.com/blog/TokenLists-Missing-DNA.html</id>
        <link href="https://bkardell.com/blog/TokenLists-Missing-DNA.html">
        </link>
        <updated>2016-03-29T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[As we move forward with the Web, it's important that we look down into the DNA and continue to find the missing connections - things that are fundamentally related in concept and managed so by the browser, but not exposed to developers in similar fashion.  I'd like to talk about one of those I recently uncovered...]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">TokenLists: Missing Web DNA</h1>
	<p class="segue">As we move forward with the Web, it's important that we look down into the DNA and continue to find the missing connections - things that are fundamentally related in concept and managed so by the browser, but not exposed to developers in similar fashion.  I'd like to talk about one of those I recently uncovered...</p>

	<p>A long long time ago, in a browser far far away, Brendan Eich introduced what would become known as "DOM Level 0" - basically: Simple reflective properties that allowed you to access useful bits of what would later become "DOM" and twiddle with them. &nbsp;It looked something like this...</p>

	<code-format type="javascript">
		<pre>document.forms[0].firstName.value = "Brian";</pre>
	</code-format>

	<p>
		However, there is a long, complex and twisted history that led us to where we are today (see my&nbsp;<a href="/blog/Brief-ish-History-of-The-Web-Part-1.html">A Brief(-ish) History of the Web Universe</a>&nbsp;series of posts). &nbsp;To sum up some key bits: CSS and the actual DOM were conceived of separately from thoughts of DOM0 and JavaScript. &nbsp;Unlike its predecessor, the "real" DOM was intended to be generic.  Part of this was just trying to bring a lot of people together and "fix" the Web.  At the time of its conception, there was a lot of focus on trying to address the problems of SGML that made HTML so appealing in the first place - so we got DTDs for HTML and work began on all things XML.
	</p>

	<p>
		The "real" DOM, then, was intended to serve all masters, and as such it&nbsp;dealt with basic attributes in a tree which could be serialized, manipulated and parsed and rewritten in any language with a common interface.  This&nbsp;meant that authors would use <code>getAttribute(attributeName)</code> and <code>setAttribute(attributeName, value)</code> to get and set attribute values respectively. &nbsp;It seemed to those spec writers, then&nbsp;absolutely logical to create an attribute called "<code>class</code>" and allow a user to type:
	</p>

	<code-format type="javascript">
		<pre>element.setAttribute("class", "intro")</pre>
	</code-format>

	<p>Which would be serializable or parsable as something like</p>
	<code-format type="javascript">
		<pre>&lt;div class="intro"&gt;</pre>
	</code-format>


	<p>This was problematic in the browser though because DOM Level 0 was not only&nbsp;more well known, but far more&nbsp;terse/convenient.  Most authors really just wanted to deal with reflective properties and type something like:</p>

	<code-format type="javascript">
		<pre>element.class = "intro";</pre>
	</code-format>

	<p>In CSS, the <code>class</code> attribute has special meaning, surely it deserved some sugar.  But the above wouldn't have worked because at the time, using property names that were JavaScript reserved words just wouldn't work.  To resolve all these issues, we got the <code>.className</code> property&nbsp;which was reflective on the <code>class</code> attribute. &nbsp;Problem solved... Except, not.</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Not Simple Enough</h2>
		<p>CSS says that any element can specify&nbsp;0...N classes, not 0 or 1.  These are provided in a space separated list. &nbsp;In SGML/XML terms these were "<code>NMTokens</code>". &nbsp;It sounds quite simple - a space separated list of values with some simple constraints should work everywhere, and it does... kind of.</p>

		<p>In the browser world, however, where we were messing with&nbsp;classes at runtime all over the place that needed to be reflected back (CSS wasn't based on&nbsp;runtime properties, it was based on&nbsp;attributes) we began facing issues. &nbsp;Someone would come along and write code like the above example, which assumed that it was a single value:</p>

		<code-format type="javascript">
			<pre>element.className = "intro";</pre>
		</code-format>

		<p>The net result being that any existing class names at the time of execution were replaced with just one. &nbsp;Some other person would assume they wanted to toggle a value and write something like:</p>

		<code-format type="javascript">
			<pre>// Toggle the 'selected' class
element.className = (element.className === "selected") ? "" : "selected";</pre>
		</code-format>

		<p>The problem being two-fold: &nbsp;First, it assumes it could === a single value, the second being that it can overwrite all the others. &nbsp;We had problems removing classes, adding them, removing them, toggling them, finding out if it contained something. &nbsp;It sounds trivial but it turns out that it wasn't: Each time you wanted to touch the className you had to deal with deserializing the string, doing your work and re-serializing it without stepping on any of a number of landmines. &nbsp;The net result was, as one might expect, we came up with libraries to help with this - however, they varied in quality and assumptions. It was still a mess.</p>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">Problem Solved.</h3>

			<p>When jQuery joined the W3C after becoming the most widely used solution, they lobbied to improve this situation (disclaimer, I represent jQuery in several W3C groups). &nbsp;It wasn't long before we had the <code>.classList</code> interface. &nbsp;The world is much better with <code>.classList</code> at our disposal - finally we can be rid of the above problem. &nbsp;Now users can write:</p>

			<code-format type="javascript">
				<p>element.classList.add("intro");</p>
			</code-format>

			<p>It's the missing interface developers&nbsp;always&nbsp;needed.</p>
		</section>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Wait... Problem Solved?</h2>
		<p>Sadly, I think still not quite. &nbsp;While it's a major improvement, the trouble is that the <code>NMTokens</code> issue does not solely affect the <code>class</code> attribute, or even just in JavaScript, but we only exposed it through <code>.classList</code>.</p>

		<p>It's quite possible that you are thinking "Well, this probably isn't something I need to worry about because I've never come across it". &nbsp;However, I think you will, and that's the problem.</p>

		<p>There are other <code>NMTokens</code> issues that you've probably not thought about before but eventually will have to. &nbsp;Accessibility is a good example of where this pops up a lot, and if you've not thought about accessibility in the past, it's very possible you've never run into it for that reason alone.</p>

		<p>The <code>aria-describedby</code> attribute is just one example.  A control can be described by multiple elements for different purposes. &nbsp;For example, an <code tag-esc="">input</code> element may have associated helpful advice that appears in a tooltip popup&nbsp;<em>and&nbsp;</em>associated constraint validation errors. &nbsp;Further, it works a lot like the <code>class</code> attribute and has similar challenge&nbsp;in JavaScript in that it frequently has to be actively maintained, not just written in markup, and that's deceptively hard. &nbsp;For example, an author should not associate an input with an errors collection until there are actually errors.</p>

		<p>This sucks. &nbsp;ARIA is hard enough without re-facing remedial seeming sorts of challenges that are indentical to once we've already solved.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Good News and Bad</h2>
		<p>The good news is that standards makers had the foresight to create an interface for this type of problem called <code>DOMTokenList</code> with all the useful methods and properties that <code>.classList</code> exposes. &nbsp;The <code>.classList</code> property holds a <code>DOMTokenList</code>.</p>

		<p>The bad news is that it's pretty much locked away and there's no way to easily re-apply it to new things as they emerge. &nbsp;We could continue to identify spec properties and create new things&nbsp;like <code>.classList</code> each time we find them. &nbsp;For example, we could expose <code>.ariaDescribedByList</code> - and we might want to occasionally do that - but it's not great. &nbsp;It's just additive. &nbsp;Each time we do, the API of things to learn gets bigger, it also doesn't expose these abilities to custom elements, and it doesn't help with anything that isn't specifically HTML (if you care about that sort of thing).</p>

		<p>Alternatively, however, <em>we could define a single new foundational DOM method to expose <strong>any</strong> attribute this way</em></p>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">Can you show me?</h3>
			<p>
				Yes!  The good news is that this is actually pretty easy to do, minimal new API to learn and should reasonably work for everyone. &nbsp;Jonathan Neal and I are providing a <a href="https://github.com/bkardell/tokenListFor/blob/master/_tokenListFor.js" target="_blank">prollyfill</a>, or a "speculative polyfill", for this (public domain).  This allows people to ask for an attribute as a <code>DOMTokenList</code>&nbsp;and deal with it the same as they would <code>.classList</code>. &nbsp;Because it's a proposal, and should a standard ultimately arrive it may differ, we've underscored the method name to keep it future safe, but here's an example of its use...
			</p>

			<code-format type="javascript">
				<pre>element._tokenListFor("aria-describedby").add("foo-help-text");</pre>
			</code-format>

			<p>
			In <a href="https://extensiblewebmanifesto.org" target="_blank">Extensible Web</a>&nbsp;terms, this isn't asking for new additive functionality at all - it is explaining existing magic that already exists, but lies mostly dormant and unexposed in the bowels of the platform. &nbsp;Given this interface, the <code>.classList</code> property, for example, is then merely legacy sugar for its equivalent <code>.asTokenList(attr)</code> accessor&nbsp;(which doesn't require 'name' distinction either and deals with dasherized attributes just fine too):</p>

			<code-format type="javascript">
				<pre>element._tokenListFor("class").add("intro");</pre>
			</code-format>
		</section>

		<p class="thanksTo">Thanks to the many people who proofread, looked at demos, discussed or&nbsp;gave thoughts on this as it developed, including Jonathan Neal, Bruce Lawson, Mathias Bynens,&nbsp;Simon St Laurent, Jake Archibald, and Alice Boxhall.</p>
	</section>

]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[A Brief(ish) History of the Web Universe - Part III: The Early Web]]></title>
        <id>https://bkardell.com/blog/Brief-ish-History-of-The-Web-Part-3.html</id>
        <link href="https://bkardell.com/blog/Brief-ish-History-of-The-Web-Part-3.html">
        </link>
        <updated>2016-02-05T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[
	Part I: The Pre-Web and Part II: Time of this series attempt to set the creation of the Web, the first Web browser and early attempts to publicly share Sir Tim Berners-Lee’s idea of “the Web” into some historical context.  They attempt to illustrate that there were ideas and forks of ideas along the way, each  considering different aspects of different problems; and that each had varying degrees of success. Some were popular and increasingly mature desktop products, others created standards upon which many products would be built.  Some were technically interesting but completely failed to take off and some which were academically fascinating but were largely vapor.   All of these were still “in motion” at the time that the Web was being conceived and it’s important to realize that they didn’t stop just because Tim said “wait, I’ve got it.”.  Those posts also attempt to explain how Tim really wanted the Web to be read/write, wanted to tap into existing mature products and which bits he imagined were most and least important.  I described the landscape of deployed hardware and technology at the time – the world was close, but not yet “ready” to be wired in richer form/  We weren’t connected by and large – In fact, the entire amount of information sent across the Internet monthly at that time would easily fit on a single sub $100 (US) external USB hard-drive in 2016.    All of this led helped shape the Web.]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">A Brief(ish) History of the Web Universe - Part III: The Early Web</h1>
	<p class="segue">
	<a href="/blog/Brief-ish-History-of-The-Web-Part-1.html">Part I: The Pre-Web</a> and <a href="/blog/Brief-ish-History-of-The-Web-Part-2.html">Part II: Time</a> of this series attempt to set the creation of the Web, the first Web browser and early attempts to publicly share Sir Tim Berners-Lee’s idea of “the Web” into some historical context.  They attempt to illustrate that there were ideas and forks of ideas along the way, each  considering different aspects of different problems; and that each had varying degrees of success. Some were popular and increasingly mature desktop products, others created standards upon which many products would be built.  Some were technically interesting but completely failed to take off and some which were academically fascinating but were largely vapor.   All of these were still “in motion” at the time that the Web was being conceived and it’s important to realize that they didn’t stop just because Tim said “wait, I’ve got it.”.  Those posts also attempt to explain how Tim really wanted the Web to be read/write, wanted to tap into existing mature products and which bits he imagined were most and least important.  I described the landscape of deployed hardware and technology at the time – the world was close, but not yet “ready” to be wired in richer form/  We weren’t connected by and large – In fact, the entire amount of information sent across the Internet monthly at that time would easily fit on a single sub $100 (US) external USB hard-drive in 2016.    All of this led helped shape the Web.</p>

	<p>It would be an understatement to say that early on, the vast majority of folks in the mature bits of the industry didn't really take the Web&nbsp;seriously yet. &nbsp;As explained in previous posts, the authors of mature hypertext products turned down early opportunities to integrate the Web outright. &nbsp;In 1992 Tim's&nbsp;talk proposal for&nbsp;the Hypertext Conference was actually rejected. &nbsp;Even in terms of new "Internet ideas" the Web didn't seem like the popular&nbsp;winner. SGML enthusiasts by and large shunned it as a crude interpretation of a much better idea with little hope of success. &nbsp;<a href="https://en.wikipedia.org/wiki/Gopher_(protocol)" target="_blank">Gopher</a>, which&nbsp;was created at almost exactly the same time, was gaining users far&nbsp;faster than this "World Wide Web". What did happen for the Web, however, is that a <em>huge percentage of the&nbsp;</em>small number of early enthusiasts involved started building browsers... Meanwhile,&nbsp;<em>existing ideas&nbsp;kept evolving independently</em>, and <em>new&nbsp;ideas started</em>&nbsp;emerging&nbsp;too and these would continue to help shape and inspire.</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">1992-1993: &nbsp;WWWWI</h2>
		<p>1992 saw the birth of a <em>lot</em> of browsers and little actual hypertext. &nbsp;For perspective, by the end of 1992 there were&nbsp;<em>seven</em>&nbsp;web browsers which allowed users to surf the vast ocean of what was at the time <em>only 22 known Websites</em>. &nbsp;As each browser came online they built on Tim's original idea that the parser&nbsp;could just ignore tags it didn't understand and each attempted to "adjust" what we might call the political map of the Web's features. &nbsp;Each brought with it it's own ideas, innovations, bugs and so on. &nbsp;Effectively, this was the first "Browser War" or what I'll call "World Wide Web War I".</p>

		<p>There is one in particular, worth calling&nbsp;out: &nbsp;ViolaWWW. It was created by a student named Pei Wei and it included innovations like stylesheets, tables, inline images, a scripting language and even the ability to <em>embed</em> small applications. &nbsp;Remember that nearly all the popular non-Web, desktop hypertext and hypermedia products of the time had many these features. &nbsp;What made ViolaWWW different was that it was so much more than text. &nbsp;Viola (not ViolaWWW)&nbsp;was&nbsp;an Object Oriented programming language and a bytecode VM. &nbsp; The ViolaWWW&nbsp;browser was&nbsp;a just VM application (though, it was the killer one that made most people care about it) - this made it possible to do all sorts of incredibly interesting things.</p>

		<div class="captioned-image p-attached p-attached-left" style="margin-top:0">
			<img src="/media/viola-www-screenshots.png" target="_blank">viola.org
		</div>


		<p>Some&nbsp;people reading this in 2016 (or later) are likely simultaneously impressed and a perhaps just a little horrified by the idea that attempts to "move away from"&nbsp;nice clean declarative, semantic markup with scripts and programs came so early on. &nbsp;Tim must have been absolutely horrified, right?</p>

		<p>Well, no that doesn't seem to be quite accurate - at least from what I read from the record. &nbsp;History is a&nbsp;lot more nuanced than we frequently tend to present it. &nbsp;Ideas are complex. &nbsp;Understanding nuances can be hard, but I'd like to try.</p>

		<p>As I described in Part II, Tim didn't imagine HTML would be "<em>the</em> solution" for content but rather</p>

		<blockquote><em>I expected HTML to be the basic waft and weft of the Web but documents of all types: video, computer aided design, sound, animation and executable programs to be the colored threads that would contain much of the content. - Tim Berners-Lee in Weaving the Web</em></blockquote>


		<p>In fact, regarding Pei and Viola, he spoke in generally glowing terms in&nbsp;<em>Weaving the Web, </em>and numerous interviews. &nbsp;In his address at CERN in 1998, upon accepting a fellowship, he said</p>


		<blockquote>It's worth saying that I feel a little embarrassed accepting a fellowship when there are people like Pei Wei ...[who] read about the World Wide Web on a newsgroup somewhere and had some interesting software of his own; an interpreted language which could be moved across the NET and could talk to a screen.. in fact what he did was really ahead of his time.</blockquote>

		<p>As questions came in related to similar ideas on the www-talk mailing list Tim&nbsp;answered and explained a number of related concepts. &nbsp;<a href="http://1997.webhistory.org/www.lists/www-talk.1992/0065.html" target="_blank">Here's one that <em>might</em> capture his feelings at the time from May 1992</a>&nbsp;(Tim's is the reply):</p>

		<blockquote><i>&gt; I would like to know, whether anybody has extended WWW such, that it is possible</i><i>&nbsp;to start arbitrary programs by hitting a button in a WWW browser.
		</i>
		<div style="margin-top: 1.5rem;">Very good question. The problem is that of programming language. You need something really powerful, but at the same time ubiquitous. Remember a facet of the web is universal readership. There is no universal interptreted [sic] programming language. But there are some close tries. (lisp, sh). You also need something which can run in a very safe mode, to prevent virus attacks.... [It should be] public domain. A pre-compiled standard binary form would be cool too. &nbsp;It isn't here yet.</div></blockquote>

		<p>While I don't know <em>precisely&nbsp;</em>what Tim was thinking in the early 1990's I do think it is worth&nbsp;noting the description, his the use of the words "<em>cool"&nbsp;</em> and "<em>yet"&nbsp;</em>as well as the absence of any sort of all caps/head exploding response. &nbsp;In fact, if you wade through the archives, it turns out that a lot of early talk and efforts in 1991-1992 were <em>already</em> specifically surrounding this weird line between documents and applications or HyperText and HyperMedia. &nbsp;Traditional desktop system makers had recognized the gap and early&nbsp;Web enthusiasts&nbsp;did too.</p>

		<p>The point of this observation is simple:<em>&nbsp; "We" didn't really fully know what we were doing then, and in many ways we're still figuring it out today.</em>..&nbsp;and that's ok.</p>

		<p>Even the inclusion of inline images brought new questions - MIME wasn't a given, content-negotiation was still kind of a rough dream and requests were very expensive.</p>

		<p>Others were starting to add things like <code tag-esc="">input</code> and annotation and comment systems and variable 'slots' into the markup for some rough idea of 'templating' to help flesh out the problem that a whole lot of a sites, even then, would have to be concerned with repeating things.</p>

		<p>Some people wanted to make servers really smart. &nbsp;They saw the investment in a server as a thing which could query databases, convert document types on the fly, run business logic, etc. &nbsp;These folks thought that modifying HTML would give them something akin to the IBM 3270 model which allowed the pushing of values and the pulling of page-based responses. &nbsp;Others, like Pei, wanted to make clients smarter, or at least the cooperation between the two. &nbsp;At some level, these are conversations nearly as old as computing itself and we're still having them today.</p>

		<p>Tim continues in that same post above to say that:</p>

		<blockquote>In reality, what we would be able to offer you real soon now with document format negotiation is the ability to return a document in some language for execution.</blockquote>

		<p>Viola script by way of&nbsp;negotiation - which he explains would "cover <em>most</em> Unix systems". For Tim it seems (from my reading) that the <em>first</em> problem was that there wasn't a standard language, the <em>second</em> was that it might not be safe, the <em>third</em> was that if there was one it should be in the public domain. &nbsp;If you were on a Unix machine you'd be covered. &nbsp;If you had Viola, you'd be covered. &nbsp;If you had neither... well... it's complicated. &nbsp;But Viola had already begun tackling the safety issue too.</p>

		<p>But even this early on - it&nbsp;didn't seem to be a question of&nbsp;<em>whether</em> applications should be part of the Web, but more like&nbsp;<em>how they should be. &nbsp;S</em>hould be&nbsp;<em>one&nbsp;</em>way or maybe a few?</p>

		<p>There was so much innovation and variance in browsers themselves that in December 1992 Tim sent an email entitled "Let's keep the web together" simultaneously praising the wealth of ideas and innovations and stressing that they should work to begin the process of future standardization/alignment lest the Web fragment too far.</p>
	</section>


	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">1993-1994: The Perfect Storm</h2>
		<p>When Marc Andreessen, was shown <em>Viola</em> it helped inspire him to start an&nbsp;effort at NSCA - at least that's one story.</p>

		<p>For all its value Viola had what turned out to be a critical flaw: &nbsp;It was hard to get it working. &nbsp;Despite all of its advantages, you had to install the runtime itself (the VM) and then run the browser in the runtime. Getting it setup and running proved problematic, even for a number of pretty technically savvy people. There were issues with permissions and bugs and Pei was kind of alone in building and maintaining it.</p>

		<p>But this wasn't unique. &nbsp;Browsing the Web in 1993 was still a&nbsp;kind of&nbsp;painful endeavor to get going. The line mode browser was placed into the public domain in May 1993. There wasn't a terribly lot there to browse either - even by the end of that year&nbsp;there were only&nbsp;130 known websites. Setup was difficult and things were generally very slow. &nbsp;Even finding something on that small number of sites was hard - forget searching Google, even Yahoo wasn't a thing yet. Even if you <em>could</em> get something working with one browser, chances were pretty decent that you might come across something where it wasn't the <em>right</em> browser for you to get the whole experience.</p>

		<p>Marc Andreessen was the first one to start treating the browser like a modern product -&nbsp;really taking in feedback and smoothing out the bumps. &nbsp;The team at NCSA quickly ported his UNIX work to Mac and PC, there was even one for the Commodore Amiga. &nbsp;Mosaic was a good browser, but feature-wise, it probably wasn't even the&nbsp;<em>best</em>. &nbsp;Aside from ViolaWWW's notable work, some browsers already had pioneered forms, for example, and Mosaic initially didn't support forms.&nbsp;&nbsp;But&nbsp;there was at least one thing they <em>nailed: &nbsp;&nbsp;</em>They created&nbsp;an <em>easy to install and setup</em> browser on many platforms and drove the barrier to entry way down.</p>

		<p>Moore's Law had finally created faster and cheaper machines <em>with modems</em> entering a more mainstream market; some notable regulation changes happened; when the makers of Gopher announced that&nbsp;<em>maybe just possibly in some circumstances you might be charged a very small fee</em> Tim convinced CERN to make a statement that the Web wouldn't do that.</p>

		<p>In other words:&nbsp;<em>When Mosaic was released publicly in late 1993 "free for non-commercial use" it was in the midst of the perfect storm.</em> &nbsp;Timing matters.</p>

		<p>Suddenly the Web&nbsp;<em>really started</em> to hit and growth began to really explode. &nbsp;By 1994, there were an estimated 2800 sites. &nbsp;Regular People<sup>TM</sup> were being introduced to the Web for the first time and they were using Mosaic. &nbsp; After only&nbsp;roughly a year since&nbsp;being placed in the public domain, it is &nbsp;estimated that<em> less than 2% of Web users (still a comparatively small total by today's measures) were getting around&nbsp;using the line mode browser</em>. In April of that year, James Clark and Marc Andreessen established what would become Netscape.</p>

		<p>Previous efforts to standardize didn't get there - It wasn't until November 28, 1994 that RFC-1886 was finally sent to the IETF to begin to create an HTML "standard" which we'll talk about in Part IV, but wouldn't ultimately arrive for another year and then in debatable form.</p>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">The VM</h3>
			<p>Pei wasn't the only one thinking about a runtime VM, Sun Microsystems was too.&nbsp;&nbsp;As described in <a href="/blog/Brief-ish-History-of-The-Web-Part-2.html">Part II</a>,&nbsp;Project Green spawned Oak thinking they'd found the next big market in consumer devices with embedded systems. &nbsp;By&nbsp;1992 they had a working demo for set-top boxes which created a read/write interactive internet-<em>like</em> experience for television - MovieWood which they had hoped to sell to cable companies. &nbsp;But the cable companies didn't bite.</p>

			<p>This confluence of timing and ideas left the Green Team at Sun wondering what to do with the rest of their&nbsp;lives and their ideas. &nbsp;Over the course of 3 days they discussed the success of Mosaic and decided their future.&nbsp; As James Gosling would later describe:</p>

			<blockquote>Mosaic...&nbsp;revolutionized people's perceptions. The Internet was being transformed into exactly the network that we had been trying to convince the cable companies they ought to be building. All the stuff we had wanted to do, in generalities, fit perfectly with the way applications were written, delivered, and used on the Internet. It was just an incredible accident. And it was patently obvious that the Internet and Java were a match made in heaven.</blockquote>

			<p>So the Sun team went back to the drawing board to build a browser like Mosaic - but in Java (which was a lot like Pei's approach) and in 1994 they had a demo called "WebRunner", which would later be renamed "HotJava<sup>TM</sup>. Within just a few months everyone, not just techies, were going crazy imagining the possibilities.</p>

			<p>Nearly everyone seemed to think that this would change the world. As we'll see in Part IV, they might have been right, but not how they thought....</p>
		</section>

	</section>


]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[A Brief(ish) History of the Web Universe - Part II: Time]]></title>
        <id>https://bkardell.com/blog/Brief-ish-History-of-The-Web-Part-2.html</id>
        <link href="https://bkardell.com/blog/Brief-ish-History-of-The-Web-Part-2.html">
        </link>
        <updated>2015-12-07T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[
	Part II of&nbsp;"A Brief(ish) History of the Web Universe" aka "The Boring Posts". &nbsp;No themes, no punch, just history that I hope I can use to help explain where my own perspectives on a whole bunch of things draw from…]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">A Brief(ish) History of the Web Universe - Part II: Time</h1>
	<p class="segue">
	Part II of&nbsp;"A Brief(ish) History of the Web Universe" aka "The Boring Posts". &nbsp;No themes, no punch, just history that I hope I can use to help explain where my own perspectives on a whole bunch of things draw from…</p>

	<p>Tim Berners-Lee was working at CERN which was, by most measures, pretty large. Budgets and official policies were, as they are in many large organizations, pretty rigid and a little bureaucratic. &nbsp;CERN was about particle physics, not funding Tim's idea. &nbsp;More than that, many didn't recognize the value of lots of things which were actually necessary in some way.</p>

	<blockquote>The paradox of the Web was that this very very hard problem to connect heterogenous information from heterogeneous computers on heterogenous networks all over the word -- a very very hard problem, was solved by a small, non-official, open approach by a team with no resources, or, practically none. - Ben Segal from CERN who brought in TCP/IP 'under the radar'</blockquote>


	<p>In 1989, despite being actually&nbsp;<em>necessary </em>at this point&nbsp;for CERN to function, a memo went out reminding that it was "unsupported". &nbsp;A lot of the best things in history turn out to effectively have been people of good will working together outside the system to get things done that needed getting done.</p>

	<p>So, in September 1990 Mike Sendall, Tim Berners-Lee's boss at CERN&nbsp;found a  way to&nbsp;give&nbsp;Tim the approval to to develop his idea in a way that many good bosses through history tend to: While no one wanted to fund development of "Tim's idea," there was some interest in Steve Jobs' new NeXT computer (which it appears was also brought in initially despite, rather than as part of CERN policy and plans). &nbsp;And so, under the guise of&nbsp;testing the capabilities/suitability of the NeXT computer for development at CERN in 1990 Tim&nbsp;would be able to create a prototype browser and server.</p>


	<p>The&nbsp;NeXT had great tools for developing GUI applications and Tim was able to build a pretty nice prototype GUI with read-write facilities pretty quickly. &nbsp;It let him figure out precisely&nbsp;<em>what</em> he was proposing.</p>


	<div class="captioned-image p-attached p-attached-left share-image" style="margin-top:0">
		<img class="size-medium" src="/media/tims-next-editor-bw.gif" alt="">
		A screenshot of the NeXT browser from 1993, courtesy of CERN - it looked very similar in 1991.
	</div>

	<p>As explained in <a href="/blog/Brief-ish-History-of-The-Web-Part-1.html">Part I of this history</a>, there was already a lot going on, standardized or in place by then - for example SGML. &nbsp;Because of this, CERN somewhat unsurprisingly, already had a bunch of SGML documents in the form of a thing called "SGMLGuid" (sometimes just GUID). &nbsp;Unfortunately, the earliest capture of this&nbsp;I can find is from 1992 but here's&nbsp;<a href="http://www.w3.org/History/1992/nfs_dxcern_mirror/rpc/doc/User/rpcuser.sgml" target="_blank">what SGMLGuid&nbsp;looked like</a>.</p>

	<p>SGML itself had gotten quite complex as it tackled ever more problems, and&nbsp;Tim&nbsp;didn't really <em>know</em> SGML. &nbsp;But he&nbsp;saw the clear value in having a language that was at least familiar l<em>ooking</em> for SGML authors, and of having some existing corpus of information. &nbsp;As he said later</p>

	<blockquote>Who would bother to install a client if there wasn't already exciting information on the Web? Getting out of this chicken and egg situation was the task before us....</blockquote>

	<p>Thus, he initially started with a kind of a subset of ~15 GUID tags (<em>plus the critical <code tag-esc="">a</code>  tag for expressing hyperlinks&nbsp;which is Tim's own creation and at the very core&nbsp;of the idea - an exact number is hard to say because the earliest document on this isn't until 1992)</em>. &nbsp;As explained on <a href="http://www.w3.org/2012/08/history-of-the-web/origins.htm" target="_blank">w3.org's origins</a> page:</p>

	<blockquote>The initial HTML parser ignored tags which it did not understand, and ignored attributes which it did not understand from the CERN-SGML tags. As a result, existing SGML documents could be made HTML documents by changing the filename from<em class="code">xxx.sgml</em> to <em class="code">xxx.html</em>. The earliest known HTML document is dated 3 December 1990:</blockquote>

	<code-format type="html"><pre>&lt;p class="code"&gt;&lt;h1&gt;Standardisation&lt;/h1&gt;
There was not a lot of discussion of this at &lt;a href=Introduction.html&gt;ECHT90&lt;/a&gt;, but there seem to be two leads:
&lt;ol&gt;
&lt;li&gt;&lt;a href=People.html#newcombe&gt;Steve newcombe's&lt;/a&gt; and Goldfarber's "Hytime" committee
looking into SGML, and
&lt;li&gt;An ISO working group known as MHEG, "Multimedia/HyperText Expert Group".
led by one Francis Kretz (Thompsa SA? Rennes?).
&lt;/lo&gt;&lt;/p&gt;</pre></code-format>

	<p>There's a lot of history hiding out in this first surviving HTML actually.</p>

	<p>First, note that this and many others weren't "correct" documents by many counts we'd think of today: There was no doctype, no <code tag-esc="">html</code> element, no <code tag-esc="">head</code>, <code tag-esc="">title</code> or <code tag-esc="">body</code> etc. &nbsp;There actually <em>wasn't</em> an HTML standard yet at that point so at some level it's kind of amazing how recognizable it remains today - not just to humans, but to browsers. &nbsp;Your browser will display that page <em>just fine.&nbsp;</em>&nbsp;HTML, as it was being defined however, also wasn't valid <em>SGML </em>necessarily. &nbsp;The W3C site points out that the final closing tag is an error (it transposes the letters).</p>


	<p>More interestingly still for purposes here, I'd like to note that the very first surviving HTML document was about quite literally about Hyper<em>Media.&nbsp;</em>It's part of notes from what they called the hypertext conference and, unsurprisingly, that is what everyone was talking about. &nbsp;To understand why I think this matters, let's rewind just a little and tie in some things from&nbsp;<a href="/blog/Brief-ish-History-of-The-Web-Part-1.html">Part I</a>&nbsp;with some things that weren't....</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">The Tim<em>ing</em> of the Web</h2>
		<p>Remember VideoWorks/Director from <a href="/blog/Brief-ish-History-of-The-Web-Part-1.html">Part I</a>? &nbsp;It&nbsp;illustrated that perhaps&nbsp;the concept of Time was really important to&nbsp;hyper<em>media. &nbsp;</em>However,&nbsp;they weren't the only ones to see this.&nbsp;In fact, even as early as&nbsp;1984 people were already seeing a gap between <em>documents</em> and <em>hypermedia/multimedia</em> and talking about how to solve it. It&nbsp;turns out SGML, the reigning standard approach of the time for documents as markup actually wasn't quite suited to the task.&nbsp;It needed revision.</p>


		<p>So, Goldfarb (original GML creator, presumably mistyped above) went back to the drawing board with&nbsp;some more&nbsp;people to figure out how to apply it to a musical score. What they came up with was called SMDL (Standard Music Description Language), an&nbsp;effort that was ANSI&nbsp;approved in late 1985. &nbsp;However, no practical demonstration of SMDL was completed until 1990 and as part of a Master's thesis rather than a product (this dissonance over what makes a "standard" appears and reappears over and over in standards history).</p>

		<p>It's key though because&nbsp;you could definitely say that by the mid-late 80's,&nbsp;it was becoming obvious to many that the problem of time and linking objects in time was a more generalized problem. &nbsp;Video, for example, might have been a neat thing on the desktop but don't forget that in&nbsp;the 1980's, cable television was spreading along with computers and multimedia -- and much faster. By this time, a number of folks were beginning to imagine&nbsp;something like "interactive TV" as the potentially Next Really Big Thing (even before the Web). &nbsp;Sun Microsystems established a group, "Green" to figure out the next big thing, who&nbsp;thought it would be interactive consumer electronics (like interactive TVs).</p>

		<p>And so in 1989, just about the time Tim was putting together his ideas on the Web, the grander problem of Time/SGML was moved out of SMDL into a new ANSI project known as "HyTime" (Hypermedia/Time-based Structuring Language" which had a lot of key players and support from major businesses.</p>

		<p>It really looked like maybe it was going somewhere. &nbsp;Remember Ted Nelson from <a href="/bog/Brief-ish-History-of-The-Web-Part-1.html" target="_blank">Part I</a>? &nbsp;In 1988, AutoDesk had decided to fund him directly and commercialize his ideas which had become known as Project Xanadu. An AutoDesk press release said:</p>

		<blockquote>In 1964, Xanadu was a dream in a single mind. In 1980, it was the shared goal of a small group of brilliant technologists. By 1989, it will be a product. And by 1995 it will begin to change the world.</blockquote>

		<p>Nelson/Autodesk were some of the big names on that HyTime committee. &nbsp;Ironically, I think they got the years pretty close, but the technology wrong.</p>


		<p>At approximately the same time the MPEG (Moving Pictures Experts Group) and&nbsp;MHEG (Multimedia and Hypertext Experts Group - also mentioned in that initial post above) were established. &nbsp;MHEG's focus, like a lot of other things included hypermedia&nbsp;documents, but unlike SGML required an MHEG <em>engine - </em>basically, a VM. &nbsp;The files they'd trade would be compiled binary rather than text-based. While they were authorable as documents, they were documents about interactive <em>objects</em>.</p>

		<p>And so&nbsp;<em>this&nbsp;</em>is what people were talking about at the conference which Tim was summarizing in that early surviving HTML document. &nbsp;Both HyTime and MHEG were already thinking about how to standardize&nbsp;<em>this</em> quality in part because there is a lot of <em>media. &nbsp;&nbsp;</em>An interesting thing about media is that people were building multimedia&nbsp;<em>applications.</em></p>


		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">Shipping</h3>
			<p>So the world around him was moving forward and there were lots of interesting ideas on all fronts. Tim had a prototype in hand. &nbsp;HTML as&nbsp;understood by the NeXT&nbsp;had no forms, no tables, you couldn't even nest things - it was flat. &nbsp;Not only did it have no&nbsp;CSS but no colors (his screen was black and white). &nbsp;But, for the most part&nbsp;many of his tags&nbsp;<em>were</em>&nbsp;simple formatting. &nbsp;You can debate that an H1 <em>is&nbsp;</em>semantic, but&nbsp;in Tim's interface it was under styling. &nbsp;That is, as you could "style" things as an H1, more or less WYSIWYG style, and the editor&nbsp;would flattened it all out in serializing&nbsp;markup.</p>

			<p>Tim&nbsp;imagined (and has repeated since) that the most important thing was the URI, then HTTP then stuff like HTML and later CSS. &nbsp;URIs, in theory, can work for anything as long as you have a concept of a file that is addressable. &nbsp;HTTP was built with a feature called 'content type negotiation' which allows the sender to say what it's prepared to handle and the server to give him back something appropriate. &nbsp; As Tim explains this feature in&nbsp;<em>Weaving the Web:</em></p>


			<blockquote>In general&nbsp;... the client and server have to agree on the format of data they both will understand. &nbsp;If they both knew WordPerfect for example, they would swap WordPerfect documents directly. &nbsp;If not, they could try to translate to HTML as a default.</blockquote>


			<p>So the weird intricacies of HTML or things above weren't drastically important at the time because Tim didn't imagine HTML&nbsp;would be for everything. In fact, help address his chicken and egg problem described above, Tim just made his browser give URIs and auto-translate some popular existing protocols like NNTP, Gopher and WAIS to the HTML. &nbsp;But perhaps even this is over-simplifying just a bit - as he also explained:</p>

			<blockquote>I expected HTML to be the basic waft and weft of the Web but documents of all types: video, computer aided design, sound, animation and executable programs to be the colored threads that would contain much of the content. &nbsp;It would&nbsp;<em>turn out</em> that HTML would become amazingly popular for the content as well...</blockquote>
		</section>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">It would turn out...</h3>
			<p>One of the most interesting things&nbsp;about invention is the stuff that the inventor&nbsp;<em>didn't&nbsp;</em>expect people would do with it. &nbsp;It would&nbsp;<em>turn out</em> that HTML would become really popular for content for a number of reasons. &nbsp;One reason, undoubtedly, is that the simplest thing to do is simply to provide HTML in the first place with no alternatives. &nbsp;More importantly, perhaps, &nbsp;to re-iterate the point from part I:&nbsp;The line between documents and 'more than documents' was clearly fuzzy.</p>

			<p>To illustrate:&nbsp;Even with the NeXT browser "in hand", it was very hard to show people value. Very few people had a NeXT, even at CERN - after all, it was a pilot&nbsp;for establishing whether the new-fangled machines&nbsp;would be useful. &nbsp;Lugging it around only went to far . &nbsp; There was a new project at CERN to provide a directory and&nbsp;Tim and early partners like Robert Cailliau&nbsp;convinced CERN to publish the directory via the Web.</p>

			<div class="captioned-image p-attached p-attached-left share-image" style="margin-top:0">
				<img class="wp-image-1396 size-medium" src="https://briankardell.files.wordpress.com/2015/12/251-2.jpg" alt="">
				A screenshot of the Mac HyperCard address book application thanks to www.atarimagazines.com
			</div>

			<p>This is interesting because address book applications were something that a lot of the <em>modern&nbsp;</em>computers of the time had, but a phonebook was a bunch of printed <em>pages</em>. &nbsp;Who wouldn't have liked that <em>application? &nbsp;&nbsp;</em>It might have been potentially "easy" to create a nice HyperCard stack and auto-transform to HTML based on content type negotiation - but which part was document and which part was application? &nbsp;It was actually much easier to just deliver HTML which could be generated any number of ways - and with the current digital expectations of the day, on the machines they were using, that was just fine. &nbsp;Thus, the simple line mode browser that made the fewest assumptions possible was born as something that could be distributed to all the CERN machines (and all the world's machines - more on this below).</p>

			<p>The line mode browser was, frankly, boring. &nbsp;It was wildly inferior to the NeXT interface which was itself&nbsp;wildly inferior to something like OWL's Guide. &nbsp; &nbsp;But it worked, and as usual, that matters. &nbsp;Let me repeat that: &nbsp;<em>Shipping something useful matters.</em></p>

			<p>If you've never&nbsp;heard of Maslow's Hammer, you're probably at least familiar with the software version of it: &nbsp;We like to say "If the only tool you have is a hammer, everything looks like a nail". &nbsp;Usually when we say it we're trying to say "use the right tool for the job". &nbsp;However, there's a corollary there that is just as true and often goes unnoticed: &nbsp;If someone only has a butter knife<em> it would turn out that they</em> can suddenly screw in some kinds of screws.</p>

			<p>It would also turn out that that's not entirely a bad thing: &nbsp;If you need to unclog something, a butter knife works. &nbsp;If you need a lever to lift something small in a tight spot, a butter knife works in a pinch. &nbsp;If you need a paperweight on a windy day, guess what turns out to work pretty well? Perhaps that wasn't the butter knife's original intent, but it is universally true. And guess what else turns out to be true? &nbsp;A butter knife and some other things were&nbsp;probably an "almost" approximation for some tool that didn't&nbsp;yet exist. &nbsp;What's more, having a few of those "almost" tools frequently&nbsp;helps&nbsp;inspire something better. &nbsp;Steven Johnson calls this "the adjacent possible" in his Ted Talk "<a href="http://www.ted.com/talks/steven_johnson_where_good_ideas_come_from?language=en" target="_blank">Where good ideas come from</a>" and I think it's as true of the Web as it is of anything.</p>
		</section>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">Adjacent Possibles</h3>
			<p>However it came about, it turns out as well that the line mode browser was kind of perfect in time for a number of reasons. &nbsp;To keep things in perspective, this was 1990. &nbsp;While computers were starting to catch on, in 1990 they were still very expensive. &nbsp;As such, as deployed, many of them didn't even have OS' with something remotely like what we would call graphical UIs as a norm yet. &nbsp;Of those that did, few even had modems. &nbsp;And of those with modems, many still connected at 1200 or 2400 baud. &nbsp;We weren't connected nor even completely GUI yet. &nbsp;Those who&nbsp;<em>were</em> connecting most frequently were often doing so through large, expensive and frequently&nbsp;outdated systems which had been a <em>really&nbsp;</em>big investment years before.</p>

			<p>Because of this, what the line mode browser <em>definitely did&nbsp;</em>was to allow Tim and others to show the people who&nbsp;<em>would </em>start&nbsp;writing the modern browsers with GUIs and increasingly recognizable features in short order and keep a small but steady stream of new potential enthusiasts checking it out. &nbsp;Sadly perhaps, another thing it did was to omit the&nbsp;<em>authoring</em> piece that was present on the NeXT machine and set in motion a trend where people perceived&nbsp;the Web as a way to&nbsp;<em>consume</em> rather than publish and contribute and likely spurned a greater focus on authoring HTML. &nbsp;"Sadly Perhaps," but then again, perhaps that's precisely what was necessary in order for it to mature anyway. &nbsp;It's hard to say in retrospect.</p>

			<p>With a few new enthusiasts,&nbsp;in 1991 he created&nbsp;a mailing list:&nbsp;<a href="http://ksi.cpsc.ucalgary.ca/archives/WWW-TALK/www-talk-1991.index.html" target="_blank">www-talk</a>.&nbsp;&nbsp;For&nbsp;a while a very, <em>very</em> small but steadily growing group of people discussed the early "Web" they were trying to build. &nbsp;As more people came into the group&nbsp;they wanted more and different&nbsp;things - it should be more like HyTime, links should really work differently, it should actually be SGML rather than just "inspired by" or "look like" it and so on.</p>

			<p>What happened next just keeps getting more interesting. You can read about it in <a href="/blog/Brief-ish-History-of-The-Web-Part-3.html">Part III: The Early Web</a>...</p>
		</section>
	</section>

	<p class="thanksTo">Many thanks to folks who slogged through and proofread this dry post for me: @mattur @simonstl and @sundress.</p>


]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[A Brief(ish) History of the Web Universe - Part I: The Pre-Web]]></title>
        <id>https://bkardell.com/blog/Brief-ish-History-of-The-Web-Part-1.html</id>
        <link href="https://bkardell.com/blog/Brief-ish-History-of-The-Web-Part-1.html">
        </link>
        <updated>2015-11-22T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[
	There are a couple of posts that I've been wanting to write, but in each of them I keep finding myself wanting to talk about historical context.  Explaining it in place turns out to be too hard and I've been unable to find a resource that unifies that bits I want to talk about.  I've decided, then, that it might be easier then to write this history separately, mostly so that I can refer back to it.  So here it is, "A Brief(ish) History of the Web Universe" aka "The Boring Posts" in a few parts.  No themes, no punch, just history that I hope I can use to help explain where my own perspectives on a whole bunch of things draw from...]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">A Brief(ish) History of the Web Universe - Part I: The Pre-Web</h1>
	<p class="segue">
	There are a couple of posts that I've been wanting to write, but in each of them I keep finding myself wanting to talk about historical context.  Explaining it in place turns out to be too hard and I've been unable to find a resource that unifies that bits I want to talk about.  I've decided, then, that it might be easier then to write this history separately, mostly so that I can refer back to it.  So here it is, "A Brief(ish) History of the Web Universe" aka "The Boring Posts" in a few parts.  No themes, no punch, just history that I hope I can use to help explain where my own perspectives on a whole bunch of things draw from...</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Background</h2>
		<p>Businesses, knowledge, government and correspondence  were, for literally hundreds of years, built on paper documents.   How did we get from that world to this?  And how has that world, and our path, helped shape this one?  I'm particularly interested in the question of whether some of those implications are good or bad - what we can learn from the past in order to improve on our future or understand our present.  So how <em>did </em>we get here from there?</p>

		<p>Arguably the first important step was industrialization.  This changed the game in transforming the <em>size</em> of challenges and created new needs for efficiency.  This gave rise to the need for increasing agreement beginning with standards around physical manufacture - first locally, and then nationally around 1916.  World War II placed intense pressures and funded huge research budgets and international cooperation.  A whole lot of important things shook out in the 1940s and each developed kind of independently. I won't go into them much here except to note a few key points to help set the mental stage of what the world was like going into the story.</p>

		<p>The word "computer" in anything resembling really modern terms wasn't even a thing until 1946.</p>

		<div class="captioned-image p-attached p-attached-left share-image" style="margin-top:0">
			<img src="https://briankardell.files.wordpress.com/2015/11/102618640-03-01.jpg?w=300" alt=""> The First Digital Computer - ENIAC "For a decade, until a 1955 lightning strike, ENIAC may have run more calculations than all mankind had done up to that point." from computerhistory.org
		</div>

		<p>In 1947 ISO, the International Standards Organization, was founded.  That same year, the transistor was invented at Bell Labs.  In the late 1940's the Berlin Airlift transported over 2.3 million tons of food, fuel and supplies by developing a "standard form" document could be transmitted over just about any medium - including, for example, by telegraph.  Later this basic technique would become "EDI" (<a href="https://en.wikipedia.org/wiki/Electronic_data_interchange" target="_blank">Electronic Data Interchange</a>) and become the standard for commercial shipping and trade at scale, but It required very tight agreement and coordination on standard business documents and processes.</p>


		<p>Transistors revolutionized things, but the silicone chips which really began the revolution weren't yet a thing.  Intel, who pioneered and popularized it wouldn't even be founded until 1968.</p>

		<p>During this interim few decades, the number of people <em>exposed to the idea of </em>computers began, very slowly to to expand - and that gets pretty interesting because we start to see some interesting forks in the road...</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">1960's Interchange, SGML and HyperStuff</h2>
		<p>In the mid 1960's Ted Nelson noted the flaw with the historical paper model:</p>

		<blockquote>Systems of paper have grave limitations for either organizing or presenting ideas. A book is never perfectly suited to the reader; one reader is bored, another confused by the same pages. No system of paper-- book or programmed text-- can adapt very far to the interests or needs of a particular reader or student.</blockquote>

		<p>He imagined a very new possibility with computers, first in scholarly papers and then in books. He imagined this as an aid to authors as well which he explained evolve a work from random notes to outlines to advanced works.  He had a big vision.  In his description, he coined three important terms: Hypertext, Hypermedia (originally Hyperfilm) and Hyperlink.  For years, the terms Hypertext and Hypermedia would cause some problems. Some (including it seems to me Nelson) considered media as part of the text because it was serialized and others considered text as a subset of media) -- But this was all way ahead of its time. While it was going down, the price-point and capabilities just weren't really there. As he described in the same paper.</p>


		<blockquote>
			<p class="p1">The costs are now down considerably. A small computer with mass memory and video-type display now costs $37,000;</p>
		</blockquote>

		<p>Another big aspect of his idea was unifying some underlying systems about files.  Early computers just didn't agree on anything.  There weren't standard chipsets much less standard file types, programs, protocols, etc.</p>


		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">Markup</h3>
			<p>In 1969, in this early world of incompatibility, three men at IBM (Goldfarb, Mosher and Lorie) worked on the idea of using markup documents to allow machines to trade and deal with a simple understanding of "documents" upon which they could specialize understanding, storage, retrieval or processing.  It was called <a href="https://en.wikipedia.org/wiki/IBM_Generalized_Markup_Language" target="_blank">GML</a> after their initials, but later "Generalized Markup Language".  It wasn't especially efficient.  It had nothing to do with HyperAnything nor even EDI in a technical sense.  But it <em>was</em> comparatively easy to get enough rough agreement in order and flexible enough to make things actually work in order to achieve real things.  For example, you could send a GML document to a printer and define separately how precisely it would print.  Here's what it looked like:</p>
			<code-format type="css"><pre>:h1.Chapter 1:  Introduction
   :p.GML supported hierarchical containers, such as
   :ol
   :li.Ordered lists (like this one),
   :li.Unordered lists, and
   :li.Definition lists
   :eol.
   as well as simple structures.
   :p.Markup minimization (later generalized and formalized in SGML),
   allowed the end-tags to be omitted for the "h1" and "p" elements.</pre></code-format>

   			<p>But GML was actually a script - the tags indicated macros which could be implemented differently.  Over time, GML would inspire a lot, get pretty complicated, philosophical about declarative nature and eventually become SGML (<a href="https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language" target="_blank">Standard Generalized Markup Language</a>).  This would continue growing in popularity - especially in the print industry.</p>
   		</section>
   		<section class="sectioning">
   			<h3 class="contextual-heading" style="font-size: NaNrem;">The changing landscape</h3>
			<p>For the next decade, computers got faster, cheaper, and smaller and more popular in business, science and academia and these all matured and evolved on their own.</p>

			<p>Networks were arising too and the need for standardization there seemed obvious.  For about 10 years there was an attempt to create a standard network stack in international committees, but it was cumbersome, complex and not really getting there.  Then, late in this process, Vint Cerf left the committee.  He led work focused on rough consensus and running code for the protocol and, in very short order, the basic Internet was born.</p>

			<p>Around this same time, a hypertext system based on Nelson's ideas, called "Guide" was created at Carnegie Mellon University for Unix workstations.</p>
		</section>

	</section>
	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Rise of the Computers</h2>
		<p>In the 1980's Macs and PCs, while still expensive, were finally becoming affordable enough that some regular people could hope to purchase them.</p>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">Return of the HyperStuff</h3>
			<p><a href="https://en.wikipedia.org/wiki/Guide_(hypertext)" target="_blank">Guide</a> was commercially sold by, ported by to the Mac and PC by, and later <em>very much improved</em> on by a company called OWL (Office Workstations Limited) led by a man named Ian Ritchie.  It introduced one of the first real hypertext systems to desktops in 1985.  In 1986 Guide won a British Computer Society award. Remember "Guide" and "Ian Ritchie" because they're going to come back up.</p>

			<div class="captioned-image p-attached p-attached-left" style="margin-top:0">
				<img class=" size-full wp-image-1340 alignleft" src="https://briankardell.files.wordpress.com/2015/11/hcard1-1.png" alt="">Another two years later people were really starting to take notice of "HyperText" (and beginning to get a little over-generalized with the term - frequently this was really becoming "HyperMedia").  In 1987, an application called "<a href="https://www.youtube.com/watch?v=EMFscTOazS0">HyperCard</a>" was introduced and the authors convinced Apple to give it away free for all Mac users.  It was kind of a game changer.
			</div>

			<p>HyperCard was a lot like Guide in many ways but with a few important details we'll come back to.  The world of HyperCards was built of "decks" - each deck a stack of "cards" full of GUI: forms, animations, information and interactions which could be linked together and scripted to do all sorts of useful things.  Cards had an innate "order" and could link to and play other media which would - the state of things in a card/deck was achieved through scripting.  They were bitmap based in presentation and cleverly scalable.</p>

			<hr style="visibility: hidden">

			<div class="captioned-image p-attached p-attached-right">
				<img class="" src="http://www.fentonia.com/bio/mmdir.gif" alt=""> Screenshot of VideoWorks and the "score"
			</div>

			<p>That same year, in 1987, a product called VideoWorks by a company named Macromind was released.  In fact, if you got a Mac, you saw it because it was used to create the interactive guided tour that shipped with it.   You could purchase it for your own authorship.</p>

			<p>One interesting aspect of VideoWorks was its emphasis on time.  Time is kind of an important quality of non-static <em>media</em>, so if you're interested in the superset of hypermedia, you need the concept of time.  Thus, the makers of VideoWorks included a timeline upon which things were 'scored'.  With this HyperMedia, authors could allow a user to move back and forth in the score at will.  This was kind of slick, it made sense to a lot of people and it caught on.  Their product later became "Director" and it became a staple for producing high-end, wow'ing multimedia content on the desktop, CD-ROMs for kiosks and so on.</p>

			<p>By the late 1980's, OWL's Guide had really come to focus on the PC version.  Hypercard was Free on the Mac and as it's creator Ian Ritchie would say later...</p>

			<blockquote>You can compete on a lot of things, but it's hard to compete with free...</blockquote>


			<section class="sectioning">
				<h4 class="contextual-heading" style="font-size: NaNrem;">The emergence of an increasingly fuzzy line...</h4>
				<p>Note that most of these existing systems of this time actually dealt, in a way, with hyper<em>media </em>in the sense that they didn't draw so closely to this fundamental primitive idea based on paper.  <em>All of these could be scripted and and you might imagine: Applications were a natural outcropping.   </em>The smash game Myst was actually just a really nice and super advanced HyperCard stack!
			</p>
		</section>
	</section>

	<section class="sectioning">
		<h3 class="contextual-heading" style="font-size: NaNrem;">The Stage is Set...</h3>
		<p>The Internet was there.  It was available - in use even, but it was pretty basic and kind of cumbersome.  Many people who used the internet perhaps didn't even realize what the internet really was - they were doing so through an online service like Compuserve or Prodigy.</p>

		<p>But once again, as new doors were opened, some saw new promise.</p>

		<section class="sectioning">
			<h4 class="contextual-heading" style="font-size: NaNrem;">The Early 1990s</h4>
			<p>I've already mentioned that SGML had really nothing at first to do with HyperMedia, but here's where it comes back in.  The mindset around HyperCard was stacks and cards.  The mindset around VideoWorks/Director was Video.  The mindset of OWL was documents.  SGML was a mature thing and having something to do with SGML was kind of a business advantage.</p>

			<p><em>Guide had SGML-based documents</em>.  More than that, it called these "Hypertext Documents" and their SGML definition was called "HyperText Markup Language" (which they abbreviated HML) and it could deliver them <em>over networks</em>.  Wow.  Just WOW, right?  Have you even <em>heard</em> the term "Web" yet?  No.</p>

			<p>But wait - there's more!  Looking at what else was going on, OWL had much advanced Guide on the PC and by now it had integrated sound and video and advanced scripting ability too.  While it was "based" on documents, it was so much more.  What's more, while all of this was possible, it was hidden from the <em>average</em> author - it had a really nice GUI that allowed both creation and use. That it was SGML underneath was, to many, a minor point or even a mystery.</p>
		</section>
	</section>

	<section class="sectioning">
		<h3 class="contextual-heading" style="font-size: NaNrem;">Web Conception</h3>
		<p><em>This</em> is the world into which HTML was conceived.  I say conceived rather than "born" or "built" because Tim had been working out his idea for a few years and refining it.  He talked about it to anyone who would listen about a global, decentralized, read-write system that would really change the Internet.  He had worked out the idea of an identifier, a markup language and a protocol but that was about it.</p>

		<p><em>And here's the really interesting bit:  He didn't really want to develop it, he wanted someone else to.</em>  As Tim has explained it several times...</p>

		<p></p><blockquote>There were several commercial hypertext editors and I thought we could just add some internet code, so that the hypertext documents could then be sent over the internet. I thought the companies engaged in the then fringe field of hypertext would immediately grasp the possibilities of the web.</blockquote><p></p>

		<div class="captioned-image p-attached p-attached-left" style="margin-top:0">
			<img src="https://briankardell.files.wordpress.com/2015/11/screen-shot-2015-11-22-at-1-18-55-pm.png?w=300" alt="">Screenshot of OWL's Guide in 1990
		</div>

		<p>Remember OWL and Guide? Tim thought they would be the perfect vehicle, they were his first choice.  So, in November 1990, when Ian Ritchie took to a trade show in Versaille to <a href="https://www.youtube.com/watch?v=noOrW6u-JF4" target="_blank">show off Guide's HyperMedia</a>, Tim approached him and tried hard to convince him to make OWL the browser of the Web.  However, as Tim notes <em>"Unfortunately, their reaction was quite the opposite..."  </em></p>

		<p>Note that nearly all of the applications discussed thus far, including OWL, were commercial endeavors.  In 1986, authors who wanted to use OWL to publish bought a license for about $500 and then viewers licensed readers for about $100.  To keep this in perspective, in adjusted dollars this is roughly $1,063 for writers and $204 for readers.  This is just how software was done, but it's kind of different from the open source ethos of the Internet.  A lot of people initially assumed that making browsers would be a profitable endeavor.  In fact, later Mark Andreeson <em>would</em> make a fortune on the name Netscape in part because there was an assumption that people would buy it.  It was, after all, a killer app.</p>

		<p>It's pretty interesting to imagine where we would be now if Ritchie had been able to see it.  What would it have been like with OWL's capabilities as a <em>starting point, </em>and what impact the commercial nature of the product might have had on the Web's history and ability to catch on.   Hard to say.</p>

		<p>However, with this rejection (and other's like it) , Tim realized</p>

		<blockquote>...it seemed that explaining the vision of the web was exceedingly difficult without a web browser in hand, people had to be able to grasp the web in full, which meant imagining a whole world populated with websites and browsers. It was a lot to ask.</blockquote>

		<p>He was going to have to build something in order to convince people.  Indeed, Ian Ritchie would later give a <a href="https://www.ted.com/talks/ian_ritchie_the_day_i_turned_down_tim_berners_lee?language=en" target="_blank">Ted Talk </a>about this in which he admits that two years later when he saw Mosaic he realized "yep, that's it" - he'd missed it.</p>
	</section>
	<section class="sectioning">
		<h3 class="contextual-heading" style="font-size: NaNrem;">A Final Sidebar...</h3>
		<div class="captioned-image p-attached p-attached-left" style="margin-top:0">
			<img src="https://briankardell.files.wordpress.com/2015/11/hqdefault-1.jpg?w=300" alt=""> PenPoint Tablet in 1991
		</div>

		<p>At very nearly the same time something that was neither HyperStuff nor SGML nor Internet related entered the picture.   It was called "PenPoint".  Chances are pretty good that you've never heard of it and it's probably going to be hard to see how, but it will play importantly into the story later.  PenPoint was, in 1991, a tablet computer with a stylus and gesture support and vector graphics.</p>

		<p>Think about what you just read for a a moment and let it sink in.</p>

		<p>If you've never seen PenPoint, you should check out <a href="https://www.youtube.com/watch?v=x0XE08BjQDQ" target="_blank">this video from 1991</a> because it's kind of amazing.   And here's what it has to do with our story: It failed.  It was awesomely ahead of its time and it just... failed.  <em>But not before an application was developed for it called "SmartSketch FutureSplash" (remember the name)</em> - a vector based drawing tool which would have been kind of sweet for that device in 1991.</p>

		<p>I explain in <a href="/blog/Brief-ish-History-of-The-Web-Part-2.html">Part II: Time</a> how this plays very importantly into the story.</p>
	</section>

	<p class="thanksTo">Many thanks to folks who slogged through and proofread this dry post for me: @mattur @simonstl and @sundress.</p>


</section>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Reflections on Engineering]]></title>
        <id>https://bkardell.com/blog/Reflections-On-Engineering.html</id>
        <link href="https://bkardell.com/blog/Reflections-On-Engineering.html">
        </link>
        <updated>2015-06-20T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[Very early in my career, I was lucky enough to stumble on Web development before it really became a “thing” and landed an apprenticeship (and later job) in a new, small experimental arm of an established consulting firm which primarily worked on embedded systems. I was employee #2 of this new effort and we worked in an attic loft. Nearly all of my experience before this was from books and pure experimentation/willpower to accomplish something. I worked there for about a year, mostly by myself churning out code in somewhat typical fashion: Someone said “make it look like this picture” or “this stuff needs to come from a database” and that was pretty much it. I worked too hard, I was usually scared to death I'd never be able to figure out that one new technology that each project introduced me to and quite often it was just struggle to finish and make something work.]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Reflections on Engineering</h1>
	<p class="segue">Very early in my career, I was lucky enough to stumble on Web development before it really became a “thing” and landed an apprenticeship (and later job) in a new, small experimental arm of an established consulting firm which primarily worked on embedded systems. I was employee #2 of this new effort and we worked in an attic loft. Nearly all of my experience before this was from books and pure experimentation/willpower to accomplish something. I worked there for about a year, mostly by myself churning out code in somewhat typical fashion: Someone said “make it look like this picture” or “this stuff needs to come from a database” and that was pretty much it. I worked too hard, I was usually scared to death I'd never be able to figure out that one new technology that each project introduced me to and quite often it was just struggle to finish and make something work.</p>

	<p>I was learning a lot about APIs and the languages I was working with, but very little about how to do my job. If this sounds confusing to you, you're not alone: I've been writing software professionally for about 20 years and I've worked on a lot of teams with a wide array of people and initially nearly all of them hold the position that that is my whole job. So, let me explain the counterpoint and how I came to hold this idea about what my job really is.</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">My First Lesson...</h2>
		<p>About a year into my first job, an opportunity came up for a project that the boss didn't want to pass up: A former client with a startup who had gotten into some trouble with a deadline had heard we were doing this sort of thing now. Success would likely mean more work — but it was considerably over our heads. It dealt with some ideas for which there were only two books we could find and it seemed at the time like pretty high-end nerd stuff. We'd be working with the author of those books directly. The deadlines looked clearly impossible even if it were something we'd understood well. Still, the boss signed the contract on faith and almost immediately we lost the only other employee we had — it was just me.</p>

		<p>So the boss negotiated with an old partner who had left the company to come back and help out. His name was George and, actually, he was the one that recommended me for the position in the first place. He was friendly and quiet — a lanky guy with beard and glasses, a seasoned engineer who was great with C but he knew nothing about the Web. He came back on one condition: He was running the team — no questions or pressure or status inquiries from the boss. It seemed strange to me coming from this quiet and very amiable guy.</p>

		<p>On the first day, we had a meeting. I brought a thick printout of 4 .asp pages — each tens of thousands of lines of vbscript that represented 4 pages in their application that they had nearly completed. They said “use these as a guide and do these other 6 pages in the next 2 months — we'll do the rest”. They had a virtual army of people banging away on keyboards because in 2 months they had to ship something like 40 “pages” (their application) and in the past 3 months they had completed just the 4.</p>

		<p>“Let’s go over these and I can explain what I've already figured out…” I said.</p>

		<p>“No, tell me how a Web page works” he replied. I gave some quick explanation of HTML documents and elements and tried to move on.</p>

		<p><em>“No, but tell me how it works.”</em></p>

		<p>After much back and forth for a couple of hours I said “ok, are you ready to get started?” He cocked his head to the side, “What do you mean? We are started.”</p>

		<p>Literally all day long we drew diagrams on the board and discussed urls, query strings, HTTP methods, their relation to pages and state and HTML elements, frames, JavaScript, .asp and on and on.</p>

		<p>That night I didn’t sleep. I pondered over those printouts, I made notes. I edited code and tested my understanding of it (usually to ill effect). I did math involving the number of people typing, the lines of code, the work cut out for us and how much it cost us to have lost an entire day talking.</p>

		<p>The next day I felt a little better: All I needed was some progress then surely I’d settle down. But that day too, we talked — we talked about OLAP and SQL and COM and how you'd use them with .asp and IIS and HTTP. How the server was communicating and what we painting on the screen. Where was the state and so on. Every so often the boss would peek in and look worried and George would quickly dismiss him.</p>

		<p>On day 4 I had something of a meltdown: “<em>This is killing my career</em>,” I thought. I confronted him “George, I don't know what’s going on here. Maybe you can afford to do this, but I have to pay my rent — I work here day in and day out. That guy pays my salary and this contract will pay us both and give us more work. We've nothing to show and we're closing in on a significant fraction of the time we have which was already too short. By the end of next week, we have to have one of these done. The boss wants to see progress. The client wants to see progress. My job is to write this code, not to help you feel like you're learning or have interesting conversations. I don't know what happened between the two of you, but you need to get past it — I can't let some power trip or revenge take me down like this.”</p>


		<p>George was quiet. </p>

		<p>He took a deep breath through his nose and looked thoughtful about my comments. He reached out to the table and slowly opened a box of chocolate covered cherries that was sitting there, unwrapped it and popped it into his mouth and shook his head. He didn't look angry. He didn't look frustrated or guilty. Instead, he looked more the way a grandfather might look just before he passed down some sage wisdom — just trying to figure out how to explain. I’ll try to summarize some of the wisest words that ultimately came...</p>


		<blockquote><p>Any monkey can write code, it doesn't always turn out well. Why do you think I am here? I’m not the only engineer in town — you have others right here. Your boss is a skilled engineer and just next door you could get two guys at half the price. I'll tell you why: I'm here because this project is in trouble. Coding as fast as you can won’t work, and your boss knows that I won’t do that. </p>
		<p>Imagine that we did. Even if we didn't encounter problem after problem with code we didn't fully understand — working 15 hours a day odds are still about 99% that we'd fail. Who would that serve? We'd be battered and broken — not us. Would it make your boss happy that you came up short? Not likely. Would it make his client happy that he failed to ship? Would you get follow-on work? Not a chance.</p>
		<p>That’s our job Brian — successfully shipping something that actually meets their needs. It involves programming — hopefully good programming — but the programming and the lines of code isn't what the client wants, it’s the end result. They have to ship. This is make or break for them. You think I'm somehow not taking it seriously but I am: I want them to succeed, that’s all I want. That’s what your boss understands, and why he had the faith to bring me on. So I'm asking you to trust me — we're going to get this done and give them what they really want — the thing they really need to be done. Trust me, the rest will take care of itself.</p></blockquote>

		<p>Over the course of the next 2 weeks it was slow — we completed one page. It was a tiny fraction of the amount of code it had taken them. It seemed like a minor win, but I was still full of dread: We were behind. It took a week and a half to complete the next one, a lot of that was readjusting some earlier assumptions that turned out to be wrong, but the code actually got smaller. The last 4 fell like dominoes in just a few days and we were done — early. Each one was really easy to craft and hardly took any code at all.</p>

		<p>When we synced up with the main team they confessed that they were way behind. They were impressed — despite having all of those people they'd completed only 10 and they were more than a little worried about their quality. Could we do a few more? In the end, in fact, the lion’s share of the total work was done by our team (mostly George too because as it turned out, I had planned a vacation thinking we were done) in an amazingly short time.</p>

		<p>Everyone was happy. I learned an incredible amount of engineering which has continued to help me throughout the years. George was a great teacher. But the real value I took away was much bigger and more abstract than this.</p>

		<p><em>The end goal is to help the client be successful.</em></p>

		<p>George wasn't religiously following engineering practices because some study had shown that over time it would lower maintenance cost or something abstract. Of course, he employed good principles which helped with that, but — he wanted to ship. That’s what everyone wanted. He was simply using whatever powers he had at his disposal to solve the right problems rather than the wrong ones.</p>

		<p>I, my boss, and even the client mistakenly understood the problem to be “how do we measure and knock down units of work to do variants of what someone clumsily hacked together before they really understood the problem” . George was able to see the greater issue. Originally, their product shipped on time with two completely different approaches inside — that’s not great engineering, in fact, it’s terrible. George never tried to tell them they should do otherwise — he simply showed them a better way, he delivered and optimized everyone’s happiness. If they had any sense, they went back and learned the right lessons.</p>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">On my own...</h3>
			<p>Over the years I've frequently been in situations where I've had to apply these lessons. It’s not always easy and sometimes the hardest part is the fact that under a lot of pressure, no one can see the forest for the trees. No one wants to hear you — you can frequently be misunderstood as shooting for unaffordable perfection or just “difficult” even if that is pretty clearly not the case. But let me share just one of many stories about how this matters in a very real way — and why it’s worth caring and having the integrity to focus on the non-programming bits.</p>

			<p>Several years ago I was contracted by a large company for 6 months to complete a simple task: They had a number of systems which were written in Java or .NET. After years of discussion and planning they had timetables and budgets and a directive to convert all of their existing .NET applications to Java. I was hired to do one. They practiced a waterfall methodology and had already spent tons in codifying the requirements and analysis of the existing system and so on. More or less a straight port. They wanted me to potentially suggest a few minor UI tweaks since I was pretty good with JavaScript and CSS, but otherwise straightforward. I spent my first two weeks reading requirements, looking at code, trying to get set up and run through the existing system and so on. At the end of all of this, I had a nagging problem: I still had no idea what this system was actually for and I couldn't even get it to do simple things without crashing — even the one in production.</p>

			<p>At beginning of the third week I was really torn. I just didn't feel like I understood the problem. I could very easily “port” the NET code to Java more or less class for class, but how could I be sure I was doing it right — how could I test it? How could I suggest UI enhancements if I didn't understand what I was enhancing? I honestly couldn't afford to lose this job by pissing someone off, I'd just bought a house and my car died — things were going badly and I was stretched far beyond my limits. Part of me wanted to come to work, do the conversion and take the paycheck and hope. The other part of me won that day though as I remembered George’s words and I walked into my boss’ office and asked him for a moment of his time. I explained all this and asked if perhaps he could point me to some actual users of the system who could just let me observe how they used it for an hour or so so that I could actually understand the job I was trying to accomplish — not the programming, the actual thing the program was supposed to do: The intent. After a while, to his credit, he agreed and he sent a few of us, not just me.</p>

			<p>Afterward, we met again to compare notes and, without fail the experience was universal: They don’t use it.</p>

			<p><em>Wait...What?</em></p>

			<p><em>Why?</em></p>

			<p>It’s pretty simple actually: It doesn't work for what it is designed for — and it wasn't designed to do what they actually need. So instead, they do all these other crazy things with other systems… They each do it their own way — but they're all just solving the same problems on their own. What’s more, it’s not that involved — just clumsy.</p>

			<p>So, in the end — the budget to convert a useless system from one language to another was applied toward the valuable task of just writing the (much, much simpler) system that they actually needed in the ‘right’ language in the first place. I'd helped them not just to be successful but to understand what success meant in the first place: The real problem wasn't just “we have an application written in a language we don't want to maintain anymore” it was “we have a useless application and we never actually solved the problems that needed solving in the first place”.</p>
		</section>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">In short...</h3>
			<p>
				Many of us, and those we work with would frequently like to imagine that our job is just programming. It’s easy to forget that, and while yes, you have that rare skill — your real job is in making the project successful. It’s that same quality of solving problems that occasionally gives you an insight that others can’t have. What someone is asking you for is frequently abstract, it often lacks an understanding of the medium and that means various choices incur significantly more cost than others. It’s quite possible (at least in my experience) that with just a little cooperation and effort you can adjust expectations, correct problems with deadlines and budgets and just generally increase the overall happiness of everyone. It doesn't always work — sometimes people will misunderstand your position or even be frustrated by it. But, after ~20 years of doing this, I can honestly say that in the end my results have been overwhelmingly positive. In the end, people tend to come around and frequently those who most misunderstood initially have later come to be some of the best partners.
			</p>

			<p>
				I think my friend Mark Nottingham summed it up well recently on Twitter. I’m not sure he meant precisely this, maybe I just see this as a nice summary because it’s on my mind, but I like it regardless…
			</p>

			<div style="width: 100%; margin-top: 3rem; ">
				<div style="width: 50%; margin: auto">
					<blockquote class="twitter-tweet" data-lang="en><p lang=" en"="" dir="ltr">Eventually, you figure out that the code itself doesn't matter for shit; its effect on the world around you is what matters.<p></p>— Mark Nottingham (@mnot) <a href="https://twitter.com/mnot/status/612084738988314624">June 20, 2015</a></blockquote>
				</div>
			</div>

		<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
		</section>



</section>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Friendly Fire: The Fog of DOM]]></title>
        <id>https://bkardell.com/blog/FriendlyFire.html</id>
        <link href="https://bkardell.com/blog/FriendlyFire.html">
        </link>
        <updated>2015-01-14T05:00:00.000Z</updated>
        <summary type="html"><![CDATA[Any military is comprised of individuals, grouped into successively larger units.  While all of these units are striving for a single overarching goal, they don’t share consciousness and so, regardless of how well trained they are or how much intelligence they have, there is an inevitable amount of uncertainty which is impossible to remove.  This concept is sometimes termed “The Fog of War” and one very unfortunate result is that sometimes same-side damage is caused by an ally.  This is often referred to as “Friendly Fire” or “Blue on Blue”.  In this post, I’ll explain how these same concepts apply in the DOM and talk about how we can avoid danger..]]></summary>
        <content type="html"><![CDATA[
  <h1 class="contextual-heading" style="font-size: NaNrem;">Friendly Fire: The Fog of DOM</h1>
<p class="segue">Any military is comprised of individuals, grouped into successively larger units.  While all of these units are striving for a single overarching goal, they don’t share consciousness and so, regardless of how well trained they are or how much intelligence they have, there is an inevitable amount of uncertainty which is impossible to remove.  This concept is sometimes termed “The Fog of War” and one very unfortunate result is that sometimes same-side damage is caused by an ally.  This is often referred to as “Friendly Fire” or “Blue on Blue”.  In this post, I’ll explain how these same concepts apply in the DOM and talk about how we can avoid danger..</p>

<p>
Any large company tends to organize things a bit like a military – individuals in units of units cooperating toward a common goal. If they’re using something like a CMS, one team might define some general layouts for reuse.  Another team creating content and still other teams creating reusable/shared ‘widgets’ which are all assembled together (often dynamically) to create a whole page.
</p><p>

</p><p>
One instance of this might look like the figure below:
</p>
<figure>
  <img src="/media/friendly-fire-skeleton.png" alt="">
<figcaption>
A common layout containing a company-wide standard header, main content with social sharing cuttons, an aside/secondary content with shared 'widgets' and footer.
</figcaption>
</figure>

<p>
What’s interesting about this is that, at an observable level, only the third-party social sharing buttons are not created and maintained by the company itself and need to be treated as a potentially hostile actor.  All of the other pieces are allies in the task of presenting and managing the DOM and any distinction in how they are created, organized and maintained is, at some level, artificial and purely organizational.  Anyone who has worked in this sort of model will have experienced “The Fog of DOM“.  That is, preventing accidental violence against your allies is really hard – it’s simply too easy to accidentally select and operate on elements that aren’t “yours“.  Specifically, it’s not a security concern, it’s a cooperation/coordination concern: The fact that all operate on the same DOM and make use of selectors means that unless there is perfect coordination, even careful use of a selector in a page can easily harm components and vice versa: Friendly fire.
</p>

<p>What’s perhaps most surprising is that you don’t actually need a large organization to experience this problem yourself, you just have to want to reuse code that you aren’t developing all at once.</p>

<section class="sectioning">
   <h2 class="contextual-heading" style="font-size: NaNrem;">Why is it so damned hard?</h2>
   <p>
Primarily, I think that the answer has a lot to do with how the Web has evolved.  First, there was just markup and so this wouldn’t have been much of a problem even if these approaches/large teams existed way back then.  Then came JavaScript which had its own default global issues, but at least you could scope your code. Then came real DOM and we could start doing some interesting things.  CSS’s aim was to allow you to write rules that allowed you to make broad, sweeping statements like “All paragraphs should have a 1em margin” and then override with more specific statements like “All paragraphs inside a section with the class `suggestions` should have a 2em left margin.”  Within the context of what we were doing, this was clearly useful and over time we’ve used selectors to identify elements in JavaScript as well and our projects continued to get bigger, more complex and more ambitious.</p>

<p>Now, while there are some actions I can take to prevent my component from affecting the page that hosts it, it’s incredibly hard to prevent the outer page from accidentally selecting/impacting elements inside components.  One mistake on either end could spell problems and since they are maintained separately, by different teams, keeping them constantly in check involves an incredible degree of coordination and in the end any shortcomings in coordination usually mean investigation, hackery and guesswork to resolve.</p>

<p>Note again:  This isn’t about security.  I’m not concerned that my co-workers could steal my data, it’s their data too.  My users are their users, my company is their company.  We are allies.  It just needs to be plausible for us to easily collaborate and work together toward a common goal without a high chance of hurting our collaborators.  It still needs to be possible from the hosting page to say “Yes, I mean all buttons should be blue”, it’s just that it shouldn’t be the only (nor necessarily the default) position because it means it’s impossibly easy to harm your allies.</p>

<p>In short:  What the current design means for us, in many cases, is that it’s incredibly hard to “say what you mean” in such a way that it’s likely to avoid the most basic kinds of friendly fire. We have gobs and gobs of selectors stated as document-wide rules which become implausibly hard to reason about.  This makes them hard to write and debug.  Most sites today have hundreds of selectors, many have thousands – any of which could, theoretically apply in many many permutations.  So even if you manage to “get it right” for the time being, when you do have something that suddenly causes unexpected pain (and you will), it’s even more difficult to find out what’s causing it and why because it requires resolving all of those conflicts by resolving the rules in your head without creating others.</p>
</section>

<section class="sectioning">
  <h2 class="contextual-heading" style="font-size: NaNrem;">Is it “fixable”?</h2>
<p>So, is it plausible to imagine a better future?  Is it possible to “fix” this problem, or at least make it very markedly better without completely re-inventing things?  There have been numerous proposals to do so over the years, all of them failed to gain enough traction to cross the finish line.  There were efforts in XBL in the early 2000’s, proposals to <a href="https://lists.w3.org/Archives/Public/www-style/2005Jul/0307.html">allow externally linked CSS mounted/scoped to an element in 2005</a>,  and what would become known as “scoped CSS” is discussed and in drafts in 2006.  This proposal was actually eventually implemented in Chrome behind a flag <a href="https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/R1x18ZLS5qQ">and then removed</a>.  Removed in part it doesn’t answer all of the questions that another proposal, Shadow DOM did.</p>

<p>We seem to tend to shift back and forth between answers too ambitious or too minimal, and once again, there’s a struggle with agreement.  And so, there’s an effort to step back and see if there is something less ambitious but that we actually can get agreement on. Currently there’s a debate about it going on pulling in two possible directions:  On one side is a group which posits that this is something that should be handled by CSS, on the other is a group which argues that it shouldn’t.  I am in the latter camp, and I’d like to explain why.</p>

<p>Key to both proposals is “isolation” – some kind of boundary at which authors can safely talk and reason about things ‘within a part of a tree’ without implying things outside that part unless they explicitly intend to do so.</p>

<section class="sectioning">
  <h3 class="contextual-heading" style="font-size: NaNrem;">OPTION A: “HANDLE IT WITH CSS”</h3>
<p>This approach suggests that something, perhaps <a href="https://lists.w3.org/Archives/Public/www-style/2015Jan/0175.html">a new @rule could be used to identify ‘isolation points’ via selectors</a> and that subsequent rules could identify an isolation point for which they were relevant.  In fact, however, I believe this creates more questions and problems than it does answers and actually increases the authors’ cognitive load.  This raises some interesting follow up questions for me:</p>

<ul>
  <li>Since selectors operate off the whole document, what if I specify that both .foo and .bar should be isolated (and my rules are in that order), and a .bar occurs inside a .foo?</li>
  <li>Is it isolated as part of the .bar isolation, or only the .foo isolation?</li>
  <li>Imagining I successfully identified an element as being isolated – would rules loaded or specified inside that element (by <code tag-esc="">link</code>&gt; or <code tag-esc="">style</code> or <code tag-esc="">script</code>) be scoped to that element automatically?</li>
  <li>Combine the above to questions and it seems that any answers inevitably create a radically new concept in CSS that affects how selector matching is done. While @rules are indeed ‘different’ by nature, at least historically they don’t seem to raise these kinds of issues.  If the new @rule ignores all boundaries to create a new isolation, it does so without any kind of combinator explaining that and it means that the default thing is still sort of an act of violence and you just have to manage avoiding harm through coordination.  If it doesn’t then within your ‘component’ (whether it is a true Web Component or not) you have something conceptually very new and it’s possible to ‘lose’ isolation by something as simple as a class change which seems to largely describe the situation we’re in today.</li>
  <li>What about the non-CSS end of things?  JavaScript uses selectors too, and has the same kinds of friendly fire issues.  With CSS at least I have dev tools to analyze what rules are in play. When I use a selector via querySelectorAll or something will it be context dependent?  If it uses the same selector matching as CSS, this is a new kind of problem.  It’s never been possible for CSS to affect what kinds of selectors match in DOM, and since it is not reflected in the DOM tree, understanding why this matches or doesn’t requires explanation.  If matching works differently in JavaScript, well, that is kind of confusing and leaves an important part of the problem unchanged.</li>
  <li>Would this be readable or writable or deletable through JavaScript?  In other words, could JavaScript create an isolation boundary – are we explaining and exposing magic or creating new magic? If they aren’t creatable through JavaScript, it feels like we are going in the wrong direction and even if they aren’t, they’re based on selectors.  In other words, there is a backdoor into it because they are very easily mutable.  This is either new vector for friendly fire or just a continuation of the one we have depending on how you look at it – either way it seems bad.</li>
  <li>It’s abstract rules.  As I said, at a certain point, it becomes incredibly hard to reason about rules and their permutations – especially when they are super mutable as anything defined by selectors would inherently be.  The bigger the variance and the more you attempt to break up the work, the harder it is to manage them, and when a problem does happen – how will you debug and understand it?</li>
</ul>
</section>
<section class="sectioning">
  <h3 class="contextual-heading" style="font-size: NaNrem;">OPTION B: A NEW DOM CONCEPT</h3>
  <p>The DOM is built of nodes with parent and child pointers.  Pretty much everything about selector matching is already built on this concept. If you can imagine a new kind of Node which simply connected a subtree with links that aren’t parent/child, this is a kind of a game-changer. For purposes here, let’s just call it a “MountNode” to avoid conflation with all the bits of Shadow DOM which is essentially this plus more.  Imagine that you’d connect this new MountNode to a hostElement and it would contain a mounted subtree.  Instead of the MountNode being just another child of the hostElement then, it is linked through the hostElement’s .mountPoint property instead.  And instead of the MountNode having a .parentElement, it has a link back through the .hostElement property.  Just something simple like this gets you some interesting effects and offers advantages that none of the other historic approaches (except Shadow DOM) provided:</p>

  <ul>
    <li>Everything that authors understand about trees more or less remains intact, with the slight caveat that there is a new kind of Node (not Element).</li>
    <li>DOM inspectors can show this (see Chrome’s representation of “Shadow Root”) and you can easily explain what’s going on.  All of the selector APIs (JavaScript and CSS) work the same way.</li>
    <li>A mount isn’t linked with parent/child nodes so all existing matching schemes work pretty much “as is” without change because they use parent/child traversal.</li>
    <li>Its intuitive then to create a combinator in CSS which allows you to select the mount explicitly because that’s just what combinators do today, tell you what to consider during the tree-walking.</li>
    <li>It’s minimal “new magic”.  We don’t create new things where CSS affects DOM, we don’t raise questions about matching or mutability of boundaries – it’s just a new, foundational piece of DOM that in all other respects works just the way it always has and allows us to experiment with and build higher-level answers.</li>
  </ul>
  <p>
This last point is especially important to me.  Is it possible to involve CSS and answer all of the questions in a sane way?  To be entirely honest, I don’t know.  What I do know, however, is that today this would involve a lot of speculation, decisions and bikeshedding.  I think this is better vetted in the community – and that any standards org is just as likely (maybe more) to get it wrong as they are to get it right.  Small improvements can have outsized impacts and provide a grounds upon which we can continue to “build” an explainable and layered platform, so I lean toward one that starts low and imperative, with DOM and provides a tool that can be used to solve both the stylistic and imperative ends of it.</p>

<p>What do you think?  Share your thoughts at www-style@w3.org.</p>
<p class="thanksTo">
Many thanks to all my friends who proofread this at some phase of evolution over the past several weeks and helped me (hopefully) give it fair and thoughtful treatment: Chris Wilson, Sylvain Galineau, Brendan Eich, François Remy, Léonie Watson and Coralie Mercier.</p></section></section>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[What Would Bruce Lee Do? The Tao of the Extensible Web.]]></title>
        <id>https://bkardell.com/blog/Tao-Of-The-Extensible-Web.html</id>
        <link href="https://bkardell.com/blog/Tao-Of-The-Extensible-Web.html">
        </link>
        <updated>2014-10-07T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[Recently I participated in a panel on The Standards Process and the Extensible Web Manifesto at Edge Conf. &nbsp;While ours was the very last session of the day (you can watch the video here), nearly every topic that day called out some mention of the Extensible Web Manifesto. &nbsp;Privately,&nbsp;there were still&nbsp;plenty&nbsp;of people I met between sessions who privately said “So, what exactly is this Manifesto&nbsp;thing I keep hearing about, tell me more…”. &nbsp;and my day was filled with discussions at all levels about how exactly we should apply its words&nbsp;in practice or&nbsp;what exactly we meant by x - or specifically what we want to change about standards.  Given this, I thought&nbsp;it worth a post to share my own personal thoughts, and say some of the things I didn't have an opportunity to say on the panel. &nbsp; I'll begin in the obvious place: &nbsp;Bruce Lee.]]></summary>
        <content type="html"><![CDATA[
	
	
	<div id="downloadsPrefs">
		<p style="font-size: 1.5rem">Note from the author...</p>
		<p>My posts frequently (like this one) have a 'theme' and tend to use a number of images for visual flourish. Personally, I like it that way, I find it more engaging and I prefer for people to read it that way.  However, for users on a metered or slow connection, downloading unnecessary images is, well, unnecessary, potentially costly and kind of rude.  Just to be polite to my users, I offer the ability for you to opt out of 'optional' images if the total size of viewing the page would exceed a budget I have currently defined as 200k...
		</p>
		<p><label>Show me all the images when I read <input type="checkbox" id="download-all-images-pref" checked=""></label></p>
		<p><label>Don't ask me again on this device <input type="checkbox" id="download-all-images-pref-save"></label></p>
		<p><button id="setDownloadPrefs">Dismiss</button></p>
	</div>
	
	<h1 class="contextual-heading" style="font-size: NaNrem;">What Would Bruce Lee Do? The Tao of the Extensible Web.</h1>
	<div class="captioned-image p-attached p-attached-right optional">
		<img data-src="/media/bruce-lee-absorb-useful.jpg" alt="Absorb What is Useful, Reject what is useless - Bruce Lee">
	</div>
	<p class="segue">Recently I participated in a panel on The Standards Process and the Extensible Web Manifesto at <a href="http://edgeconf.com/" target="_blank">Edge Conf</a>. &nbsp;While ours was the very last session of the day (you can watch the video <a href="https://www.youtube.com/watch?v=vl4q0Q9ucIs" target="_blank">here</a>), nearly every topic that day called out some mention of the <a href="http://extensiblewebmanifesto.org/" target="_blank">Extensible Web Manifesto</a>. &nbsp;Privately,&nbsp;there were still&nbsp;plenty&nbsp;of people I met between sessions who privately said “So, what exactly is this Manifesto&nbsp;thing I keep hearing about, tell me more…”. &nbsp;and my day was filled with discussions at all levels about how exactly we should apply its words&nbsp;in practice or&nbsp;what exactly we meant by x - or specifically what we want to change about standards.  Given this, I thought&nbsp;it worth a post to share my own personal thoughts, and say some of the things I didn't have an opportunity to say on the panel. &nbsp; I'll begin in the obvious place: &nbsp;Bruce Lee.</p>

	<hr style="margin: 1rem; visibility: hidden">
	<div class="captioned-image optional p-attached p-attached-left">
		<img data-src="/media/bruce-lee-wwbd.png" alt="">
		What Would Bruce Lee Do? T-shirt from partyonshirts.com who totally agrees with me (I think, they didn't actually say it, but I suspect it).
	</div>

	<p>Let's&nbsp;talk about Bruce Lee. &nbsp;Chances are pretty good that you've heard of him from his film work and pop-culture status, but it's (slightly at least) less commonly known that he was more than just an exceptional martial artist: &nbsp;He was a trained philosopher and deep thinker - and he did something&nbsp;<em>really&nbsp;</em>new: &nbsp;He questioned the status quo of traditional martial arts. &nbsp;He published&nbsp;a book entitled "The Tao of Jeet Kune Do" and&nbsp;laid out an entirely new approach to fighting. &nbsp;He taught, trained and fought in a way unlike anyone before him.</p>


	<p style="clear: right"><em>He kicked ass in precisely&nbsp;the same way that standards don't.</em>, and It started&nbsp;by being both intelligent and gutsy enough to make some observations...</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">There are values in principles, but nothing is too holy to be questioned...</h2>
		<div class="captioned-image optional share-image p-attached p-attached-right">
			<img data-src="/media/bruce-lee-obey-principles.jpg" alt="Obey the principles without being bound by them - Bruce Lee">
			You know, all I keep hearing is "the fight took too long," "too&nbsp;much tradition,&nbsp;too much&nbsp;classical mess, too many fixed positions and Wing Chun". You know everything that's wrong, so fix it.&nbsp;- Linda Lee's character to Bruce in "Dragon: The Bruce Lee Story" (a fictional, but inspiring scene)
		</div>

		<p>Ok, so we all agree that standards are painful to develop and have sometimes gone very wrong. &nbsp;From the outside they look, at times, almost comically inefficient, illogical or even self-defeating. &nbsp;Many comments in our panel were about this in some form: &nbsp;<em>Too much classical mess - too much Wing Chun</em>.</p>

		<p style="clear: left">Bruce Lee saw through the strict rules of forms to what they were trying to accomplish, and he said "yeah, but that&nbsp;could be better- what about this instead"... and&nbsp;opponents fell.</p>

		<p>Likewise, standards bodies and processes are not a religion. &nbsp;Sometimes process is just process - it can be in the way, unproductive - even&nbsp;harmful if it isn't serving its true&nbsp;purpose. &nbsp;There are no&nbsp;holy texts (including the Manifesto itself) and there should be no blind faith in them: &nbsp;We are thinking, rational people. &nbsp;The Manifesto lays out guiding principles, with what we hope is a well rationed incentive, not absolutes. &nbsp;<em>Ideological absolutes suck, if you ask me, and Bruce's approach makes me think he'd agree.</em></p>

		<p>The Manifesto is pretty short though, it begs follow-on and one recurrent theme was that many people at the conference seemed interested in discussing what they perceived to be contradiction in that we have not redirected absolutely everything toward the absolute lowest primitives possible (and for others, a fear that we would). &nbsp;I'd like to explain my own perspective:</p>


		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">It is often more important to ask the question than it is to answer it perfectly.</h3>

			<div class="captioned-image optional p-attached p-attached-left">
				<img data-src="/media/bruce-lee-goal-not-always-meant-to-be-reached.jpeg" alt="A Goal is not always meant to be reached, it often serves simply as something to aim at - Bruce Lee">
			</div>

			<p>Again, the Manifesto&nbsp;lays&nbsp;out <em>principles to strive for, not laws</em>:&nbsp;Avoid large, deep sinks of high-level decisions which involve many new abstractions and eliminate the possibility of competition&nbsp;and innovation - we have finite resources and this is not a good use of them.&nbsp;Favor lower level APIs&nbsp;that <em>allow</em> these things to occur instead - they will, and try to help explain existing features. &nbsp;<em>Where to draw the line between pragmatism and perfection is debatable, and that's ok - we don't have to have all of the perfect answers right now, and that's good, because we don't.</em></p>

			<div class="captioned-image optional p-attached p-attached-right">
				<img data-src="/media/bruce-lee-too-much-time-thinking.png" alt="If you spend too much time thinking about a thing, you'll never get it done - Bruce Lee">
			</div>


			<p>Paralysis is bad. &nbsp;Perfect, as they say, can be&nbsp;the enemy of good: &nbsp;Progress matters and 'perfect' is actually a non-option because it's an optimization problem that involves many things, including an ever changing environment. &nbsp;Realize that&nbsp;there are many kinds of advantage that have historically trumped theoretical purity<em> every time</em>&nbsp;- the technically best answer has never, to the best of my knowledge 'won' - and shipping <em>something</em> is definitely way up there in terms of things you need to succeed. More importantly, do what we can to avoid bad.&nbsp;At some <em>very basic&nbsp;</em>level, all the Manifesto is really saying is: &nbsp;"Hey standards bodies -- Let's find ways to manage risk and complexity, to work efficiently and use data for the really big choices".</p>

			<p>In my mind, the W3C TAG has done a great job of attempting to redirect spec authors, <em>without paralyzing progress,&nbsp;</em>toward asking the right questions: "Is this at an <em>appropriately</em> low level?", "If it isn't quite at the bottom, <em>does it look like we can get there from here</em> - or is it what's here too high-level and overly complicated with magic to be explained?", "Can we explain existing magic with this?" and, "Is it consistent in the platform so that authors can re-apply common lessons and reasoning"?</p>

			<p>I'm sure the there are some who would disagree, but in the end, I think that&nbsp;<a href="https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html" target="_blank">Web Audio API</a>&nbsp;is a nice&nbsp;example of this kind of pragmatism at play. &nbsp;There are things that we know already: &nbsp;We've have an <code tag-esc="">audio</code> tag, for example, for a while. We have&nbsp;a collected&nbsp;cases which should be plausible, but currently aren't. &nbsp;The Web Audio API tries to address this at a considerably lower level, but <em>definitely</em> not the lowest one possible. &nbsp;<em>However...&nbsp;</em>It has been purposely planned and reviewed to make sure that it gives good answers to the above questions. &nbsp;While it's possible that this could lead to something unexpected beneath, we've done a lot to mitigate that risk and admitted that we don't have all of the information we need to make good choices there yet. &nbsp;It was built with the idea that it will have further low-level fleshing out and that we think we know enough about it to say that we can use it to explain the mechanics of the audio tag with it. &nbsp;We got the initial spec and now, nearly immediately, they've begun work on the next&nbsp;steps. &nbsp;This has the advantage of steady progress, drawing a boundary around the problem and gives a lot of developers new tools with which they'll help ask the right questions and through use, imagine new use cases which feed into a better process. &nbsp;It gives us tools that we need so that efforts&nbsp;like <a href="https://github.com/dglazkov/html-as-custom-elements" target="_blank">HTML as Custom Elements</a>&nbsp;can begin to contribute in helping to explain the higher level feature. &nbsp;The real danger is only in stopping the progressive work.</p>

			<p>Similarly, it was asked&nbsp;by someone whether&nbsp;<a href="http://www.w3.org/TR/beacon/#sec-sendBeacon-method" target="_blank">Beacon</a><em>&nbsp;"</em>flies in the face of the Extensible Web Manifesto" because it could be described by still further low level primitives (it might be possible to implement with Service Workers, for example). &nbsp;Again, I'd like to argue that in fact, it doesn't. &nbsp;It's always been <em>plausible</em>, but prohibitively cumbersome to achieve roughly the same effect - this is why <a href="https://developers.whatwg.org/links.html#ping" target="_blank">HTML added a declarative&nbsp;<code>ping</code> attribute to links</a>: &nbsp;Simple use cases should be simple and declarative - the problem isn't that high-level, declarative things&nbsp;exist, we <em>want those - </em>the Manifesto is explicit about this --&nbsp;the problem is in how we go about identifying them. &nbsp;Because this is a really common case that's been around for a long time - we already <em>have</em> a lot of good data on that. &nbsp;As it happens, ping wasn't implemented by some browsers, but they were interested in sendBeacon, which - hooray - can actually be used to describe what ping does, and maybe polyfill it too! &nbsp;It's simple, constrained, concise - and it's getting implemented. &nbsp;It's enough for new experimentation and it's also different enough from what you typically do with other network level APIs that maybe it's fine that it have no further explanation. &nbsp;If you read my posts, you know that I like to make the analogy of evolution, and so I'll point to something similar in the natural world: &nbsp;This may simply be a case of convergent evolution - differently adapted&nbsp;DNA that has a similar-looking effect, but share none of the primitives you might think, and that too can actually be ok.</p>



			<p>The important part isn't that we achieve perfection as much as that we ask the questions, avoid bad mistakes and make good progress that we can iterate on: <em>Everyone actually shipping something that serves real needs and isn't actively bad is actually a killer feature.</em></p>
		</section>


		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">The Non-Option</h3>

			<div class="captioned-image optional p-attached p-attached-left">
				<img data-src="/media/bruce-lee-defeat-state-of-mind.jpg" alt="Defeat is a state of mind; no one is ever defeated until defeat has been accepted as a reality - Bruce Lee">
			</div>

			<p>Bruce had a lot excellent quotes about the pitfalls of aiming too low or defeating yourself.</p>

			<p style="clear:right">It's easy to look at the very hard challenges ahead of us to distill the cumbersome sky-castles we've built into sensible layers and fundamentals and just say "too hard" or "we can't because explaining it locks out our ability to improve performance".</p>

			<p>Simultaneously, one of the most urgent needs is that we fill the gaps - if the Web lacks features that exist in native, we're losing. Developers don't want to make that choice, but we force them to.</p>

			<p>We're doing best when we are balancing both ends of this equation to move ever forward.</p>

			<p>Don't give up. &nbsp;It's going to be hard but we can easily defeat ourselves before we ever get started if we're not careful. &nbsp;We can't accept that - we need to convince ourselves that it's a non-option, because it is. &nbsp;If we don't do the hard work, we won't adapt - and eventually this inability will be the downfall of the Web as a competitive platform.</p>
		</section>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">Jump in the Fire</h3>
			<p>Good things happen when we ship early and ship often while focusing this way. &nbsp;As we provide lower-level features we'll see co-evolution with what's happening in the developer community, this data can help us make intelligent choices - lots of hard choices have been made, we can see what's accepted, we can see new use cases.</p>

			<p>Some have&nbsp;made the case - to me at least -&nbsp;that we shouldn't try applying any of this to standards until we&nbsp;have everything laid out with very precise rules about what to apply when and where. &nbsp;I disagree. &nbsp;Sometimes, the&nbsp;only way to figure some of it out is to jump in, have the discussions and do some work.</p>

			<div class="captioned-image optional">
				<img data-src="/media/bruce-lee-jump-in-water.jpg" alt="If you want to learn to swim, jump in the water. On dry land no frame of mind is ever going to help you." -="" bruce="" lee"="">
			</div>

			<p>Standards processes and even bodies themselves have evolved over time, and we should continue to adapt where we see things that aren't working. &nbsp;It won't be perfect - reality never is -- it's messy, and that's&nbsp;ok..</p>

		</section>

	</section>

	<p class="thanksTo">Very special thanks to Brendan Eich and Bruce Lawson for kindly reviewing and providing useful thoughts, commentary and corrections ❤..</p>

]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[A Web for the Next Century]]></title>
        <id>https://bkardell.com/blog/A-Web-For-The-Next-Century.html</id>
        <link href="https://bkardell.com/blog/A-Web-For-The-Next-Century.html">
        </link>
        <updated>2013-10-08T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[If you've read any of the numerous articles about The Extensible Web or heard about it in conference presentations, or seen The Extensible Web Manifesto you've likely seen (or heard) three phrases repeated: "Explain the magic," "fundamental primitives" and "evolution of the platform". I thought it might be worth (another) piece explaining why&nbsp;I think&nbsp;these are at the heart of it all...]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">A Web for the Next Century</h1>
	<div id="scripture">
		<strong>The Web Platform</strong><br>
		Chapter 1.
		<div style="white-space: pre-wrap">
1. In the beginning, Tim created the Web.
2: And the platform was without form, and void; and confusion was upon the face of the Internet. And the mind of Tim moved upon the face of the problem.
3: And Tim said, Let there be a new protocol: and there was HTTP.
4: And Tim saw the protocol, that it was good: and he divided the network by domains and subdomains.
5: And he called the network the World Wide Web.
6: And Tim said, Let there be a browser for viewing pages delivered by this Web that they might be viewed.
7. And it was so.
8: And Tim separated the structure of the content from its style.
9: And the structured content he called HTML and the means of styling he called CSS. And he saw that it was good.
10. And Tim said, let us describe this structured content in the form of a tree and make it scriptable, and it was so.
11. And from the dust of the Interwebs were created developers, whom he gave dominion over the platform.
		</div>
		
	</div>

	<p class="segue">If you've <a href="http://yehudakatz.com/2013/05/21/extend-the-web-forward/" target="_blank">read</a> <a href="http://www.creativebloq.com/net/creative-bloq-welcomes-readers-net-magazine-9134344?ns_campaign=mobile-yml&amp;ns_mchannel=mobile-site&amp;ns_source=net&amp;ns_linkname=0&amp;ns_fee=0" target="_blank">any</a> of <a href="http://www.webdirections.org/blog/towards-an-extensible-web/" target="_blank">the</a> <a href="http://domenic.me/2013/06/10/explaining-away-the-webs-magic/" target="_blank">numerous</a> <a href="http://css-tricks.com/an-intro-to-hitch-js-and-the-extensible-web/" target="_blank">articles</a> <a href="http://smus.com/installable-webapps/" target="_blank">about</a> <a href="http://blog.mediumequalsmessage.com/moving-the-web-forward-together" target="_blank">The</a> <a href="http://infrequently.org/2013/07/why-javascript/" target="_blank">Extensible</a> <a href="http://domenic.me/2013/10/07/the-extensible-web/" target="_blank">Web</a> or heard about it in conference presentations, or seen The <a title="The Extensible Web Manifesto" href="http://extensiblewebmanifesto.org" target="_blank">Extensible Web Manifesto</a> you've likely seen (or heard) three phrases repeated: "Explain the magic," "fundamental primitives" and "evolution of the platform". I thought it might be worth (another) piece explaining why&nbsp;<strong>I think</strong>&nbsp;these are at the heart of it all...</p>


	<p>For thousands of years the commonly accepted answer to the question ”where did dolphins come from” (or sharks or giraffes or people) was essentially that they were specially created in their current form, by a deity as part of a complex and perfect plan. &nbsp;Almost all cultures had some kind of creation myth to explain the complex, high level things they couldn't understand.</p>

	<p>Turns out that this very simplified view was wrong (as is much of the cute creation myth I've created for the Web Platform) and I'd like to use this metaphor a bit to explain...</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Creation and Evolution: Concrete and Abstract</h2>
		<p>It's certainly clear that Sir Tim's particular mix of ideas became the dominant paradigm: &nbsp;We don't spend a lot of time talking about SGML or Gopher.</p>

		<p>It seems straightforward enough to think of the mix of ideas that made up the original Web as being evolutionary raw materials and to think of users as providing some kind of fitness function in which it became the dominant species/paradigm, but that is&nbsp;is a pretty abstract thing and misses a subtle, but I think important distinction.</p>

		<p><em>The Web Platform/Web browsers are not an idea, they are now a concrete thing.</em> &nbsp;The initial creation of the Web was act of special creation - engineering that introduced not just new ideas, but new software and infrastructure. &nbsp;The&nbsp;Web is probably the most grand effort in the history of mankind - browsers as a technology outstrip any operating system or virtual machine in terms of ubiquity and they &nbsp;are increasingly capable systems. &nbsp;There are many new systems with concrete ideas to supplant the Web browser and replace it with something new. &nbsp;People are asking themselves: &nbsp;Is it even&nbsp;<em>possible&nbsp;</em>&nbsp;for the Web to hang on? &nbsp;<em>Replacing it is no easy task: technically or socially -&nbsp;</em>This is a huge advantage to the Web. &nbsp;So how do we make it <em>thrive</em>? &nbsp;Not just today, but years from now?</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Some more history...</h2>
		<p>In Tim's original creation, HTTP supported only GET; In HTML there were no forms, no images, no separate idea of style. &nbsp;There was no DOM or async requests - as - indeed there was no script. Style was a pretty loosely defined thing - there wasn't much of it, and it was mostly 'separated' more by accident than by purpose.- CSS wasn't a thing. &nbsp;There was just GET me that very simple HTML document markup which is mediocre at displaying text - and display it - when I give you a URL and make sure there is this special concept of a "link".</p>

		<p><em>This is at the heart of what we have today, but it is not nearly all of it: &nbsp;What we have today has become an advanced <em>Platform</em> - so how did we get here? &nbsp;Interestingly, there are two roads we've followed at different times - and it is worth contrasting them.</em></p>

		<p>In some cases, we've gone off and created entirely new high level ideas like CSS or AppCache which were, well, magic. &nbsp;That is, they did very, very complex things and provided a high-level, declarative API which was highly designed to solve very specific use-cases. &nbsp;And at other times (like DOM, XMLHttpRequest and CSSOM) we have&nbsp;<em>explained some of the underlying magic&nbsp;</em>by taking some of those high-level APIs and providing some imperative APIs.</p>

		<p>Looking at those lists, it seems to me that were it not for those small efforts to <em>explain some of the magic</em>, the Web would already be lost by now.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Creating a Platform for the Next 100 Years</h2>
		<p>The&nbsp;real strength of life itself is derived from the fact that it is&nbsp;<em>not</em>&nbsp;specifically designed to perfectly fill a very niche, but because complex pressures a high level judge <em>relatively minor variance at a low level&nbsp;</em>and this simple process&nbsp;inevitably yields the spread of things that are&nbsp;<em>highly adaptive and able to survive changes in the complex pressures.</em></p>

		<p>Sir Tim Berners-Lee couldn't have forseen iPhones and Retina displays, and had he been able to account for them in his original designs, the environment itself (that is, users who choose to use or author for the Web) would likely have rejected it. &nbsp; Such are the complex pressures changing our system and we could learn something from nature and from the history of technology here: &nbsp;Perfectly designed things are often not the same as "really widely used" things and either can be really inflexible to change.</p>

		<p>Explaining the magic means digging away at the capabilities that underly this amazing system and describing their relationships to one another to add adaptability (extensibility). &nbsp; At the bottom are a number of necessary and fundamental primitives that only the platform (the browser, generally) can provide. &nbsp;When we think about adding something new, let's try to explain it "all the way down" until we reach a fundamental primitive and then work up.</p>

		<p>All of this allows for small&nbsp;<em>mutations - new things which can compete for a niche in the very real world -</em>&nbsp;and unlike academic and closed committees can&nbsp;help create new, high-level abstractions based on real, verified shared need and acceptance and shared understanding. &nbsp;In other words, we will have a Platform which, like life itself, is highly adaptive and able to survive complex changes in pressures and last beyond any of our lifetimes.</p>
	</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dropping the F-Bomb on Web Standards]]></title>
        <id>https://bkardell.com/blog/Dropping-The-F-Bomb-On-Standards.html</id>
        <link href="https://bkardell.com/blog/Dropping-The-F-Bomb-On-Standards.html">
        </link>
        <updated>2013-05-17T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[In 2012, Mirriam-Webster's dictionary added a&nbsp;definition for the F-Bomb. &nbsp;Why? &nbsp;Was it because some elite Mirriam-Webster working group d-wonk committee decided it was necessary to mint a "steamy new word"? &nbsp;No, rather, because it is a well-established part of the common vernacular of the English language. There are&nbsp;occurrences&nbsp;of it going all the way back to 1988. &nbsp;Not every slang term someone makes up will get into the dictionary. The Oxford English Dictionary has a&nbsp;vault full of millions of words that currently do not make the cut. &nbsp;Many never catch on. &nbsp;Some die out quickly and others change shape as they spread, that is what etymology is all about. &nbsp;Some stagnate and maintain distinct and valuable regional meanings, and that is fine, but they aren't part of the standard language. &nbsp;The ones that are ultimately widely understood and eventually become commonly used are accepted and codified into the dictionary. Some words even become extinct. &nbsp;In other words, the process of word standardization is&nbsp;evolutionary.]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">Dropping the F-Bomb on Web Standards</h1>
	<div class="captioned-image p-attached p-attached-left" style="margin-top: 1rem;">
		<img src="https://briankardell.files.wordpress.com/2013/05/small_57466134.jpg" alt="a photo of a dictionary page">
		 <div>photo credit: <a href="http://www.flickr.com/photos/wiccked/57466134/">wiccked</a> via <a href="http://photopin.com">photopin</a> <a href="http://creativecommons.org/licenses/by-nc-nd/2.0/">cc</a></div>
	</div>
	<p class="segue">In 2012, Mirriam-Webster's dictionary added a&nbsp;<a href="http://www.merriam-webster.com/dictionary/f-bomb" target="_blank">definition for the F-Bomb</a>. &nbsp;Why? &nbsp;Was it because some elite Mirriam-Webster working group d-wonk committee decided it was necessary to mint a "steamy new word"? &nbsp;No, rather, because it is a well-established part of the common vernacular of the English language. There are&nbsp;occurrences&nbsp;of it going all the way back to 1988. &nbsp;Not every slang term someone makes up will get into the dictionary. The Oxford English Dictionary has a&nbsp;<a href="http://www.telegraph.co.uk/news/newstopics/howaboutthat/7926646/Secret-vault-of-words-rejected-by-the-Oxford-English-Dictionary-uncovered.html" target="_blank">vault full of millions of words that currently do not make the cut</a>. &nbsp;Many never catch on. &nbsp;Some die out quickly and others change shape as they spread, that is what etymology is all about. &nbsp;Some stagnate and maintain distinct and valuable regional meanings, and that is fine, but they aren't part of the standard language. &nbsp;The ones that are ultimately widely understood and eventually become commonly used are accepted and codified into the dictionary. Some words even become extinct. &nbsp;In other words, the process of word standardization is&nbsp;<strong><em>evolutionary.</em></strong></p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">What's this got to do with Web Standards?</h2>
		<p>There are actually many similarities between a dictionary which codifies and specifies the English language and a Web standard, but today the two work in nearly opposite ways*.</p>

		<p>I didn’t come up with the dictionary metaphor (I dont know who did first).  I first heard Alex Russell mention it in <a href="http://infrequently.org/11/fronteers/fronteers.html#1" target="_blank">2011 in a Fronteers talk</a> while I was trying my best to find a way to describe it succinctly myself and it really struck a chord with me.  It very simply illustrates in a way that is easily understood, not just the problem itself, but some excellent/proven solutions that we can use to solve them:  What we really need is a way to develop the slang of the Web and, as it catches on,  potentially mutates or dies, eventually have a way to recognize that, pick it up and codify it into the standards dictionary.</p>

		<span style="font-size:x-small;">*&nbsp;Some attempts at seeing what people are doing outside of Web standards has happened, but for the most part, the real work of creation happens in a committee and the &nbsp; dominance or extinction happens by browser vendors (who also dominate the committees). &nbsp;This has, so far, left us with APIs that are often less than what we want, general slowness in rate of change and lots of other undesirable qualities for developers.</span>

		<section class="sectioning">
			<h3 class="contextual-heading" style="font-size: NaNrem;">A Path for Natural Platform Evolution</h3>
			<div class="captioned-image p-attached p-attached-left" style="margin-top: 1rem;">
				<img src="https://briankardell.files.wordpress.com/2013/05/small_81671961.jpg" alt="a photo of a lego charles darwin">
				 <div>photo credit: <a href="http://www.flickr.com/photos/wiccked/57466134/">wiccked</a> via <a href="http://photopin.com">photopin</a> <a href="http://creativecommons.org/licenses/by-nc-nd/2.0/">cc</a></div>
			</div>

			<p>Yehuda Katz and Alex Russell gave an excellent&nbsp;<a href="http://f.cl.ly/items/2L0a0B0R130G3u0k0b1y/Layering.pdf" target="_blank">presentation</a>&nbsp;on the importance of Layering at the first W3C Technical Architecture Group F2F recently. &nbsp;As you can see from the&nbsp;<a href="http://lists.w3.org/Archives/Public/www-tag/2013Apr/0026.html" target="_blank">minutes</a>, they returned on to this idea again with some positive/open responses from other member including questions and observations that further illustrate the language-link from Sir Tim Berners-Lee who seemed to express a lot of interest in parts.</p>

			<p>It&nbsp;is critical to have competition/mutations and a population to evolve a platform - it is important to the long term health of the Web that we be<em>&nbsp;able&nbsp;to evolve the slang of the Web&nbsp;(not just specify and release)</em>. &nbsp;Yehuda called this a "Path for Natural Platform Evolution".</p>

			<section class="sectioning">
				<h4 class="contextual-heading" style="font-size: NaNrem;">What's in it for me? &nbsp;What do I have to do?</h4>
				<p>If you have ever participated in the open standards lists you know: &nbsp;Most people aren't&nbsp;<em>that</em>&nbsp;committed to bettering something that might make their lives easier years from now. &nbsp; They have a job to do. &nbsp; Within a month or two of following any list, you will begin to recognize the same small group of people who really contribute at that level. &nbsp;It's not that the general public is&nbsp;<em>unwilling</em>&nbsp;to contribute, it's just really difficult to do and they don't actually get anything out of it now. &nbsp;This is distinctly different from words in a language - it's&nbsp;<strong>very&nbsp;</strong>easy (and cheap) to pick up words that you find useful or descriptive and use them in your everyday parlance, on Facebook or Twitter. &nbsp;You get something out of it when you find something becomes much easier to describe or maybe even makes you sound a little smarter or hipper than you might be without them. &nbsp;Web standards on the other hand are kind of the opposite of that at the moment.</p>
			</section>

			<section class="sectioning">
				<h4 class="contextual-heading" style="font-size: NaNrem;">Cheap ways to help</h4>
				<ol>
					<li><strong>Collect the slang: &nbsp;</strong>One very cheap way that you can help if you have chrome is to install&nbsp;<a href="https://chrome.google.com/webstore/detail/meaningless/gmmhpelpfhlofjjolcegdddjadkmincn" target="_blank">Meaningless</a>&nbsp;and help collect anonymous statistics about the elements and approaches used in sites that you visit - this helps inform what slang is actually picking up and which is mostly just theory or fad. &nbsp;What benefit do you, personally, get out of it right now? &nbsp;Actually none, but it's so easy, why not help :)</li>

					<li><span style="color:#000000;font-weight:bold;font-style:inherit;line-height:1.625;">Provide the environment, use the slang: &nbsp;</span><em>Prollyfills</em>&nbsp;(which I write about a lot) are to standards as slang is to words in the dictionary - they are essentially proposals that we hope catch on. &nbsp;Using them right now actually does<strong>&nbsp;</strong>deliver value and it can be pretty cheap to try them out and provide some feedback. &nbsp;If you're&nbsp;very<strong>&nbsp;</strong>interested, join the Extensible Web Community group (see prollyfills link above) and help out - it's open and you can do so in any way you like, and at your own pace. &nbsp;You can comment, show us examples/use cases, contribute new ideas, or help create tests - or just help promote some proposal you really like.</li>
				</ol>
			</section>

			<section class="sectioning">
				<h4 class="contextual-heading" style="font-size: NaNrem;">Missing Links...</h4>
				<p>
					Unfortunately this will only take us so far with the Web platform as it is today. &nbsp;As Yehuda and Alex explained in their TAG presentation - it is hard to impossible to prollyfill some things in order for us to develop this slang in the real world: The platform doesn't contain the right layers for people to step in and tweak/develop just one piece. &nbsp;The only ones capable of doing this are browser vendors. &nbsp;The architecture is lacking.
				</p>

				<p>Thus, today, developers write increasingly complex JavaScript: Re-implementing in order to emulate things that are already natively implemented in the browser just to make a single piece work a little better.</p>

				<p>In order to fix this problem, we need to fix the gaps in the platform. &nbsp;Some of this will take a while. &nbsp;Luckily we have some good people working on it. &nbsp;We've elected some good guys to the W3C Technical Architecture Group, both the membership and private encouragement we have gotten in the W3C Extensible Web Community Group have been encouraging &nbsp;and there are spec authors like Tab Atkins who are<a href="http://www.xanthir.com/b4N80" target="_blank"> helping to open new doors</a> to make things like this more possible in places where they are currently very hard.</p>
			</section>
		</section>
	</section>
	<section id="related-articles" class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Related Articles</h2>
		<ul>
			<li><a href="https://extensiblewebmanifesto.org">The Extensible Web Manifesto</a></li>
			<li><a href="http://infrequently.org/2012/04/bedrock/" target="_blank">Bedrock</a> (infrequently.org)</li>
			<li><a href="http://infrequently.org/2012/04/hoisted-from-the-comments/">Hoisted from the Comments </a>(infrequently.org)</li>
			<li><a href="http://smus.com/how-the-web-should-work/">How the Web Should Work</a> (smus.com)</li>
		</ul>
	</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Off With Their Heads: Disband the W3C?]]></title>
        <id>https://bkardell.com/blog/Off-With-Their-Heads.html</id>
        <link href="https://bkardell.com/blog/Off-With-Their-Heads.html">
        </link>
        <updated>2013-04-23T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[Just a few days ago, Matthew Butterick presented a talk entited "The Bomb in the Garden" at TYPO in San Francisco (poor title timing given recent events in Boston). In it, he concludes "the misery exists because of the W3C—the World Wide Web Consortium... So, respectfully, but quite seriously, I suggest: let’s Disband the W3C". Ultimately he suggests that "...the alternative is a web that’s organized entirely as a set of open-source software projects.]]></summary>
        <content type="html"><![CDATA[
	
	<h1 class="contextual-heading" style="font-size: NaNrem;">Off With Their Heads: Disband the W3C?</h1>
	<div class="captioned-image p-attached p-attached-left">
		<img src="/media/Tenniel_red_queen_with_alice.jpg" alt="Tenniel illustration of red queen with alice">
	</div>
	<p class="segue">Just a few days ago, Matthew Butterick presented a talk entited "<a href="http://unitscale.com/mb/bomb-in-the-garden/" target="_blank">The Bomb in the Garden</a>" at TYPO in San Francisco (poor title timing given recent events in Boston). In it, he concludes "<em>the misery exists because of the W3C—the World Wide Web Consortium... So, respectfully, but quite seriously, I suggest: let’s Disband the W3C</em>". Ultimately he suggests that ".<em>..the alternative is a web that’s organized entirely as a set of open-source software projects.</em></p>

	<p style="font-weight: bolder;">In his recent talk/post, Matthew Butterick raises several points:</p>
	<ul>
		<li><span style="font-style:inherit;line-height:1.625;">It takes a really long time for standards to reach Recommendation Status ("the Web is 20 years old)</span></li>
		<li>The W3C doesn't enforce standards</li>
		<li>Browser vendors eventually implement the same standards differently</li>
		<li>We fill pages with hacks and black magic to make it work</li>
		<li>Ultimately, what we wind up with still isn't nearly good enough</li>
		<li>There is no good revenue model</li>
		<li>Newspaper and magazine sites all look roughly the same and are somewhat 'low design'.</li>
	</ul>

	<p>His presentation is definitely interesting and worth a read/view. In general, if you have been working on the Web a long time, you will probably experience at least some moments where you can completely relate to what he is saying.</p>

	<p>Still, it seems a little Red Queen/over-the-top to me so I hope you'll humor a little Alice in Wonderland themed commentary...</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Why is a Raven Like a Writing Desk?</h2>
		<p>Michael Smith (@sideshowbarker to some) replied with some thoughts on it on the W3C Blog with a post entiteled "<a style="font-style:inherit;line-height:1.625;" href="http://www.w3.org/QA/2013/04/getting_agreements_is_hard_som.html" target="_blank">Getting agreements is hard (some thoughts on Matthew Butterick’s “The Bomb in the Garden” talk at TYPO San Francisco</a><span style="font-style:inherit;line-height:1.625;">)" in which he points out in short, bullet-list form, several problems with Butterick's statements about how W3C is misportrayed. The post is short enough and already bulleted so I won't summarize here, instead I encourage you to go have a read yourself. &nbsp;He&nbsp;closes up with the point that "Nowhere in Matthew Butterick’s talk is there a&nbsp;<em>real</em>&nbsp;proposal for how we could get agreements any quicker or easier or less painfully than we do now by following the current standards-development process." (emphasis mine).</span>
		</p>

		<p>Indeed, the open source projects mentioned by Butterick are about as much like standards as a raven is like a writing desk and, in my opinion, to replace a standards body with a vague "bunch of open source projects" would send us down a nasty rabbit hole (or through the looking glass) into a confusing and disorienting world: Curiouser and curiouser.</p>

		<blockquote class="alice">“Would you tell me, please, which way I ought to go from here?"<br>
"That depends a good deal on where you want to get to."<br>
"I don't much care where –"<br>
"Then it doesn't matter which way you go.”
<div>―&nbsp;<a href="http://www.goodreads.com/author/show/8164.Lewis_Carroll">Lewis Carroll</a>,&nbsp;<em><a href="http://www.goodreads.com/work/quotes/2933712">Alice in Wonderland</a></em></div>
		</blockquote>

		<p>Still, I don't think Butterick really means it quite so literally. &nbsp;After all, &nbsp;he&nbsp;holds up PDF as an ISO standard that "just works" and ISO is anything but an open source project 'like Wordpress'. &nbsp;In fact, PDF and ISO could have some of the same challenges laid against them. For example, from the ISO website:</p>

		<blockquote>
			<div style="font-weight: bolder;">Are ISO standards mandatory?</div>
	ISO standards are voluntary. ISO is a non-governmental organization and it has no power to enforce the implementation of the standards it develops.
		</blockquote>

		<p>It seems to me that ISO and W3C have a whole lot more in common than they differ IMO: &nbsp;Standards are proposed by stakeholders, they go before technical committees, they have mailing lists and working groups, they have to reach&nbsp;consensus, etc. &nbsp;Most of this is stated in Michael's post. &nbsp;Additionally though, all PDF readers are not alike either: Different readers have different level of support for reflow and there is a separate thing called "PDF/A" which extends the standard (they aren't the only ones) and adds DRM (make it expensive?).&nbsp;&nbsp;Some readers/authors can accept links to places outside the file, some can't. &nbsp;Some can contain comments added by reviewers or markings, others can't. &nbsp; Etc.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">You used to be much more..."muchier."</h2>
		<p>I think that instead, Butterick is simply (over) expressing his frustration and loss of hope in the W3C: &nbsp;"They've lost their "muchness". &nbsp;You know what? &nbsp;It&nbsp;<em>really does <strong>suck</strong> that we have experienced all of this pain, a</em>nd to be honest, Butterick's technical examples aren't even scratching the surface. &nbsp;After 20 years, you really really think we'd be a little further along.</p>

		<blockquote class="alice">“I can't go back to yesterday because I was a different person then.”
<div>―&nbsp;<a href="http://www.goodreads.com/author/show/8164.Lewis_Carroll">Lewis Carroll</a>,&nbsp;<em><a href="http://www.goodreads.com/work/quotes/2933712">Alice in Wonderland</a></em></div></blockquote>

		<p>A lot of the pain we've experienced has taken place due to really big detour in the history of Internet standards: The ones we really use and care about were basically sort of put on hold and efforts mostly put toward a "something else". &nbsp;Precisely which something else would have made the Web super awesome is a little fuzzy, but whatever it was you could bet that it would have contained at least one of the letters "x" "m" or "l" and have contained lots of "&lt;" and "&gt;"'s. &nbsp;The browser maker with the largest market share disbanded their team and another major one split up. &nbsp;It got so contentious at one point that the WHATWG was established to carry on the specs that the W3C were abandoning.</p>
	</section>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Re-muchifying...</h2>
		<p>While we can't go back and fix that now, the question is: &nbsp;Can we prevent the problems from happening again and work together to make the Web a better place? &nbsp;I think we can.</p>

		<blockquote class="alice">“Why, sometimes I've believed as many as six impossible things before breakfast.”
<div>―&nbsp;<a href="http://www.goodreads.com/author/show/8164.Lewis_Carroll">Lewis Carroll</a>,&nbsp;<em><a href="http://www.goodreads.com/work/quotes/2933712">Alice in Wonderland</a></em></div></blockquote>

		<p>The W3C is an established standards body with a great infrastructure and all of the members you'd really need to make something happen. &nbsp;Mozilla CTO Brendan Eich had <a href="http://brendaneich.com/2004/06/the-non-world-non-wide-non-web/" target="_blank">some good advice in 2004</a>:</p>

		<blockquote>What matters to web content authors is user agent market share. The way to crack that nut is not to encourage a few government and big company “easy marks” to go off on a new&nbsp;<em>de-jure</em>&nbsp;standards bender. That will only add to the mix of formats hiding behind firewalls and threatening to leak onto the Internet.</blockquote>

		<p>More has happened to drive Web standards and browser development/interoperability forward in the past 2-3 years than happened in the 6-7 years combined and more is queued up than I can even wrap my head around. &nbsp;We have lots of new powers in HTML and lots of new APIs in the DOM and CSS. &nbsp;We have efforts like <a href="http://testthewebforward.org/" target="_blank">Test the Web Forward</a>&nbsp;uncovering problems with interoperability and nearly all browsers becoming&nbsp;<em>evergreen</em> - pushing out improvements and fixes all the time. &nbsp;We also managed to get some great reformers elected to the W3C Technical Architecture Group recently who are presenting some great ideas and partnership and cooperation between W3C and other standards bodies like ECMA/TC-39 (also making excellent progress) are beginning. &nbsp; I believe that we can all win with community&nbsp;participation&nbsp;and evolution through ideas like <strike><a href="http://www.prollyfill.org" target="_blank">prollyfill.org</a></strike> (<span class="edit">edit: unfortunately we lost that domain to a speculator, but <a href="https://extensiblewebmanifesto.org">The Extensble Web Manifesto</a> came out of this, and <a href="https://chapters.io">chapters.io</a> and <a href="https://wicg.io">wicg.io</a> now play the respective roles it was advocating</span>)&nbsp;which is trying to team up the community with standards groups and implementers to create a more nimble and natural process based on evolutionary and open ideas... Perhaps that might sound like a marriage of open source ideas and standards that Matthew Butterick would be more happy with... Maybe I should send him an email.</p>

		<p>So what do you think?</p>

		<blockquote class="alice">“Do you think I've gone round the bend?"<br>
"I'm afraid so. You're mad, bonkers, completely off your head. But I'll tell you a secret. All the best people are.”
		<div>―&nbsp;<a href="http://www.goodreads.com/author/show/8164.Lewis_Carroll">Lewis Carroll</a>,&nbsp;<em><a href="http://www.goodreads.com/work/quotes/2933712">Alice in Wonderland</a></em></div></blockquote>

	</section>





]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[(Really) classy CSS]]></title>
        <id>https://bkardell.com/blog/Really-Classy-CSS.html</id>
        <link href="https://bkardell.com/blog/Really-Classy-CSS.html">
        </link>
        <updated>2012-05-11T04:00:00.000Z</updated>
        <summary type="html"><![CDATA[When CSS was conceived, the basic vision was that HTML should provide structure and semantics while CSS would providing styling via rules based on selectors describing (or selecting) what to style.  In an ideal world, Web pages could be authored by one group of people independently of the visual needs and then another group (designers) could go and write CSS to style it up.  The biggest problem in achieving this ideal was that HTML had such a small number of tags without any real obvious way to add enough semantics to actually accomplish this.  Thus, two things were added very early on:  The humble div and span tags in HTML and the .class in CSS  - the general idea being that the authors of a tree of markup could (quite independently of style concerns) build generic structures and pepper their markup with semantics via classes and ids.]]></summary>
        <content type="html"><![CDATA[
	<h1 class="contextual-heading" style="font-size: NaNrem;">(Really) classy CSS</h1>
	<p class="segue">When CSS was conceived, the basic vision was that HTML should provide structure and semantics while CSS would providing styling via rules based on selectors describing (or selecting) what to style.  In an ideal world, Web pages could be authored by one group of people independently of the visual needs and then another group (designers) could go and write CSS to style it up.  The biggest problem in achieving this ideal was that HTML had such a small number of tags without any real obvious way to add enough semantics to actually accomplish this.  Thus, two things were added very early on:  The humble <code tag-esc="">div</code> and <code tag-esc="">span</code> tags in HTML and the .class in CSS  - the general idea being that the authors of a tree of markup could (quite independently of style concerns) build generic structures and pepper their markup with semantics via classes and ids.</p>

	<section class="sectioning">
		<h2 class="contextual-heading" style="font-size: NaNrem;">Theory vs Reality</h2>

		<p>In practice, there have been a relatively few cases (like WordPress blogs, for example) where things are simple and standard enough this has worked out "pretty well" and a whole lot more where that is actually not the common experience.  Generally speaking, markup is not created independently of design and changes to design often dictate changes to markup.  Even the attaching and management of classes are changes to markup and if they happen purely to achieve design, well, that's less than desirable.  There have been lots of blogs and articles written over the years about the problems that this created and the creation of new terms like "classitis" and "divitis" to describe their negative impact.</p>

		<p>Still, that was what could get done initially and it was a lot better than what we had prior to it.  Considerably more important, however, is that this was never meant to be the end game - even by the people who created it.  HTML drove forward, creating some new tags and work began on an XML dialect which promised all kinds of things, while CSS followed up almost immediate with CSS 2/2.1 and began CSS 3 (the first draft was published in August 1999, only 3 months after 2.1 went to REC status).  But then, a lot of confusion happened and for a long time, things were pretty stagnant.</p>

		<h2 class="contextual-heading" style="font-size: NaNrem;">Solutions</h2>
		<p>The solutions to this are pretty clear, and it's arguable just by looking at the history of drafts and discussions that everyone knows what needs to be done about it:  HTML authors need more semantic abilities (new tags help and so do things like data-* attributes), CSS needs new concepts (regions and generated content for example) and more powerful selectors.   The good news is, things are moving again, though not as quickly as many of us would like...</p>

		<p>My friend, and co-author of Hitch, Clint Hill has been posting some good articles about Hitch over on our blog about how Hitch helps with this last part by allowing authors of CSS to use an expanded set of selectors (Hitch provides a selector plugin model, just like jQuery) right in their CSS, affording them with more expressive powers.</p>

		<p>I'll let you <a href="https://hitchjs.wordpress.com/2012/05/11/content-based-css-math/" target="_blank">read the article</a> yourself, but the gist of of it is about a set of selectors for selecting elements based on the numerical qualities of your attributes.  For example, the :-math-greaterthan(attr, number) filter allows you to write CSS like this:</p>

		<code-format type="css">
			<pre>/* Let's visually call out players who achieve this... */
.player:-math-greaterthan(data-score, 100000){
    font-weight: bold;
}</pre>
		</code-format>


		<h2 class="contextual-heading" style="font-size: NaNrem;">Rationale...</h2>

		<p>Here's a bit more on the theory behind this selector and how it is relevant to the above.</p>

	    <ol>
	    	<li>The proposal certainly isn't to throw away .class, merely to use it more "as envisioned" in terms described above. If, indeed, you recognized semantic meaning in your tree and maintain it as a class for reasons other than styling - that's great. In our example above, however, it's definitely possible that that is not the case. <em>Clearly there is semantic meaning to the number, but whether a designer decides to attach some arbitrary styling to that or not shouldn't require changes to the tree. This approach allow the appropriate technology to handle the appropriate concerns. From the perspective of a CSS author: You use the classes you have when they are there, and have the expressive power to style things that are purely visual when they are not.</em> The alternative of scattering presentation logic throughout your php or jsp (or whatever) and your javascript to maintain a class in some of these cases is considerably less desirable.</li>

	    	<li>CSS has had attribute selectors for a long time which allow you to select attribute values that are contained with in, exactly equal to, start with or end with values expressed in your selector. There have long been conversations, even tentative plans to further expand attribute selectors to something with more "regExp" power, there have even been plans for a :content pseudo-class which would allow the same thing with textual content - but it's all string based currently. Attribute selectors already support data-* attributes. Literally all that is added is the ability to write rules that consider something numerically rather than textually.</li>

	    	<li>CSS has rich support for algebraic expressions as they relate to structures (children, characters, etc) in the tree and will soon add a calc() function. Again, it makes sense if you think about it that CSS should have appropriate power to do what is required in order to achieve styling without mucking with the tree...</li>
	    </ol>

	    <p>All of this seems considerably inline with the goals and existing approaches of CSS to me and it seems logical to me, but I'd like to hear what you think...</p>

	    <p>Hitch is a new, open source project <a href="https://github.com/bkardell/Hitch/" target="_blank">hosted on github</a> which we think has a lot of potential.  Check out <a href="http://www.hitchjs.com">http://www.hitchjs.com</a> and the articles on the <a href="https://hitchjs.wordpress.com/">Hitch Blog</a>...  Let us know what you think and share your comments, we'd love to hear from you and have a conversation.</p>

	</section>
]]></content>
    </entry>
</feed>