<html lang="en" resource-type="blogpost"><head>  
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="view-transition" content="same-origin"> 

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@briankardell">
    <meta name="twitter:creator" content="@briankardell">
    <meta name="twitter:title" content="Canvas and the Evolution of Platform">
    <meta name="twitter:description" content="There is a lot more that I think is exciting about OffscreenCanvas that I could fit in my last post...">
    <meta name="twitter:image" content="https://km.support.apple.com/library/content/dam/edam/applecare/images/en_US/osx/mavs_dashboard.png">
    <!-- meta name="monetization" content="$ilp.uphold.com/kKU4GXiRwhnf " -->
     
    <link rel="alternate" type="application/rss+xml" href="https://bkardell.com/blog/feed.rss" title="bkardell.com/blog rss feed">
    <title>Canvas and the Evolution of Platform</title> 
    <style>/*!
 * Web Fonts from Fontspring.com
 *
 * All OpenType features and all extended glyphs have been removed.
 * Fully installable fonts can be purchased at https://www.fontspring.com
 *
 * The fonts included in this stylesheet are subject to the End User License you purchased
 * from Fontspring. The fonts are protected under domestic and international trademark and 
 * copyright law. You are prohibited from modifying, reverse engineering, duplicating, or
 * distributing this font software.
 *
 * (c) 2010-2023 Fontspring
 *
 *
 *
 *
 * The fonts included are copyrighted by the vendor listed below.
 *
 * Vendor:      Horizon Type
 * License URL: https://www.fontspring.com/licenses/horizon-type/webfont
 *
 *
 */

@font-face {
    font-family: 'acherus_militant_1_-_light.otf';
    src: url('/acherus_militant_1_-_light.otf-webfont.woff2') format('woff2'),
         url('/acherus_militant_1_-_light.otf-webfont.woff') format('woff');
    font-weight: normal;
    font-style: normal;

}


.captioned-image {
    background-color: #eaeaea;
    display: block;
    overflow: hidden;
    padding: 1rem;
    text-align: center;
    font-style: italic;
}

.captioned-image.p-attached {
    width: 40%;
    display: inline-block;
    margin: 0 1rem 2rem 1rem;
}

section > .captioned-image.p-attached {
    margin-top: 1.5rem; /* correct for heading size*/
}

 pre { overflow-x: auto }

.captioned-image.p-attached.p-attached-left {
    float: left;
}

.captioned-image.p-attached.p-attached-right {
    float: right;
}

.captioned-image.p-attached + * + * {
    clear: both;
    margin-top: 2rem;
}


.captioned-image img, .captioned-image video {
    display: block;
    max-width: 100%;
    margin: 0 auto 1em auto;
}
.source {
    font-style: italic;
}
body {
    display: grid;
    grid-template-columns: 25rem auto;
    font-size: 1.1rem;
    font-family: 'acherus_militant_1_-_light.otf';
    font-weight: 400;
    font-size: 1.25rem;
    line-height: 1.625;
    margin: 0;
    background-color: rgb(249, 246, 246);
}
h1 { margin: 0.5rem; }
code-format {
    border-left: 0.5rem solid rgba(123,115,209,0.35);
    display: block;
    padding: 0.5rem;
    margin-bottom: 1rem;
}

contextual-heading {
    display: block;
    margin-top: 2rem;
}

h1, [aria-level="1"] {
    color: black;
    font-size: 1.45rem;
}

h2, [aria-level="2"] {
    color: black;
    font-size: 1.35rem;
}

h3, [aria-level="3"] {
    color: black;
    font-size: 1.25rem;
}

h4, [aria-level="4"] {
    color: black;
    font-size: 1.2rem;
}

h5, h6, [aria-level="5"], [aria-level="6"] {
    color: black;
    font-size: 1.2rem;
    font-weight: bolder;
}

.posted-on {
    font-style: italic;
    font-size: 0.8rem; 
    text-align: right;
    margin-bottom: 1rem;
}

ul, li {
    margin: 0.5rem;
    text-align: left;
}

.authorinfo {
    height: 100%;
    padding-top: 1rem;
    padding-right: 0;
    background-color: #fbf5e9; 
    display: block;
    background-image: linear-gradient(to right, #c7cccc, #dde0e8 );
    border-right-width: 1px;
    border-right-style: dotted;
}

.tagline {
    font-style: italic;
    text-align: center;
}
 
[tag-esc] {
    color: maroon;
    font-family: Courier, "Lucida Console", monospace;
}

[tag-esc]::before {
    content: '<';
}

[tag-esc]::after {
    content: '>';
}

main {
    min-width: 50%;
    width: 80%;
    padding: 1rem;
}
header .title {
    background-color: rgba(123,115,209,0.35);
    padding: 0.3rem;
    padding-left: 0.25rem;
    font-weight: bolder;
    font-size: 1rem;
    border-left: 1rem solid #999298;
}

header .profile {
    width: 50%;
    margin: 1rem 25%;
}

header .title + nav {
    font-size: 0.9rem;
}

header .blurb {
    font-size: 0.9rem;
    text-align: center;
}
header .name {
    text-align: center;
    font-size: xx-large;
}
.segue {
    font-style: italic;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
}

#aboutMeToggle {
    display: none;
}


:where(pre:has(code[class*="language"])) {
    display: block;
    background-color: black; 
    padding: 0.5rem;
}

code[class*="language"] {
    min-width: fit-content;
}

spicy-sections:not([affordance]) > h2 {
  clip: rect(0 0 0 0);
  clip-path: inset(50%);
  height: 1px;
  overflow: hidden;
  position: absolute;
  white-space: nowrap;
  width: 1px;
}

main article { max-width: 100em; margin: auto; }
/* this needs rethinking, it wants a selector like 'not flow content' */
article>*:not(contextual-heading,a), section>*:not(contextual-heading,a) {
    margin-left: 0.45rem;
}

blockquote {
  font-family: serif;
  background: #f9f9f9;
  border-left: 10px solid #ccc;
  margin: 1.5em 10px;
  padding: 0.5em 10px;
}
blockquote:before {
  color: #ccc;
  content: open-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-right: 0.25em;
  vertical-align: -0.4em;
}

blockquote:after {
  color: #ccc;
  content: close-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-left: 0.25em;
  vertical-align: -0.4em;
}
 

@media (max-width: 800px){
    body {
        grid-template-columns: 1fr;
    }
    .authorinfo {
        height: auto;
        border-bottom: 1px solid #afafff;
        padding-top:  0;
    } 

    main { width: 95%; margin: 0 auto;}

    .captioned-image.p-attached {
        width: 100%;
        margin: 1rem 0;
    }

    .captioned-image.p-attached.p-attached-left,
    .captioned-image.p-attached.p-attached-right {
        float: none;
    }

    #aboutMeToggle {
        display: block;
        background-color: #675e5e;
        color: white;
        padding: 0.25rem;
        padding-left: 0.5rem;
        border-left: 1rem solid black;
    }

    header li { display: inline; margin-left: -0.5em; }
    header .blurb li::after { content: '; '; }
    header  nav li {
        display: inline-block;
        margin-left: 0.35rem;
        margin-right: 0.35rem;
    }
    header .title {
        width: 100%;
    }
    main li .source { display: block; }

} 

spicy-sections {
    --const-mq-affordances:
      [screen and (min-width: 600px) ] collapse |
      [screen and (min-width: 801px) ] tab-bar
    ;
    display: block;
}

spicy-sections.authorinfo {
    --const-mq-affordances:
      [screen and (max-width: 801px) ] collapse
    ;
}


spicy-sections.single {
    --const-mq-affordances:
      [screen ] collapse 
;
}

[role="tab"] {
    margin-right:  1.5rem;
}


</style>
    <style> 
      .captioned-image { font-size: 0.9rem; }
      .thanksTo { font-style: italic; font-size: 0.8rem; }
    </style>
    <script>
      var activateOptional = function (media) {
        var source = media.getAttribute('data-src'),
            temp,
            container = media.parentElement;

          if (media.nextSibling && media.nextSibling.matches) {
            if (media.nextSibling.matches('.clickToSee')) {
              media.parentElement.removeChild(media.nextSibling);
            }
          }
 
          if (media.tagName === 'VIDEO') {
            temp = document.createElement('video')
            temp.setAttribute('autoplay','')
            temp.setAttribute('controls','')
            temp.setAttribute('loop','')
            temp.innerHTML = '<source src="' + source + '.webm" type="video/webm">'
                    + '<source src="' + source + '.mp4" type="video/mp4">';
            media.parentElement.replaceChild(temp, media);
            setTimeout(function () {
              temp.play()
            }, 0);
          } else {
            media.src = media.getAttribute('data-src');
          }

          container.classList.add('active');
      }
    </script>
  </head>
  <body>
    <spicy-sections class="authorinfo">
<h2 id="aboutMeToggle" defaults-on-match="">Author Information</h2>
  
<header>
    <div class="name">
        Brian Kardell
    </div>
    <img class="profile" src="/profile.jpg" alt="">
    <div class="tagline"><a href="/">Betterifying the Web</a></div>
    <div class="blurb">
        <ul>
            <li>Developer Advocate at Igalia</li>
            <li>Original Co-author/Co-signer of The Extensible Web Manifesto</li>
            <li>Co-Founder/Chair, W3C Extensible Web CG</li>
            <li>Member, W3C (OpenJS Foundation)</li>
            <li>Co-author of HitchJS</li>
            <li>Blogger</li>
            <li>Art, Science &amp; History Lover</li>
            <li>Standards Geek</li>
        </ul>
    </div>
    <div class="title">Follow Me On...</div>
    <nav>
        <ul>
            <li><a rel="me" href="https://briankardell.wordpress.com">Wordpress</a></li>
            <li><a rel="me" href="https://medium.com/@briankardell">Medium</a></li>
            <li><a rel="me" href="https://twitter.com/briankardell">Twitter</a></li>
            <li><a rel="me" href="https://github.com/bkardell/">Github</a></li>
            <li><a rel="me" href="https://toot.cafe/@bkardell">Mastodon</a></li>
            <li><a rel="me" href="https://bsky.app/profile/bkardell.com">Bluesky</a></li>
            <li><a rel="me" href="https://codepen.io/bkardell">Codepen</a></li>
            <li><a rel="me" href="https://www.linkedin.com/in/brian-kardell-08a4264">LinkedIn</a></li>
            <li><a rel="me" href="https://www.instagram.com/kardellbrian">Instagram (for
art)</a></li>
            <li><a rel="me" href="http://fineartamerica.com/profiles/brian-kardell?">Fine Art
America (art for sale)</a></li>
        </ul>
    </nav>
</header> 
</spicy-sections>
<script>
  /*
    You're probably wondering "Do I need to write this?""
    "Is this part of it?"  No... If you're interested tho - 
    Custom elements have a FOUC/PE gap 
    (see https://github.com/whatwg/html/issues/6231).
    This is a slightly better experience: It 
    will be hidden _if JS is enabled_, and 
    will be shown as it is defined, 
    or after 1 sec, whichever is first.
  */
  let ss = document.createElement("style");

  ss.innerHTML = `html:not(.lldelay) :not(:defined) { visibility: hidden; }`;
  document.head.appendChild(ss);

  setTimeout(() => {
    document.documentElement.classList.add("lldelay");
  }, 1000);
</script>
    <main><div class="posted-on">Posted on null</div><article class="sectioning">
    <h1 class="contextual-heading">Canvas and the Evolution of Platform</h1>
    <p class="segue">There is a lot more that I think is exciting about <code>OffscreenCanvas</code> that I could fit in my last post...</p>

    <p>I recently published a post explaining how <code>OffscreenCanvas</code> is important and interesting, in very practical ways, to far more users than most developers probably imagine. However, there's a bigger story here too, I think, about the evolution of the platform itself.  I recently gave a talk at <a href="https://webdirections.org/code/">Web Directions: Code</a> which went into a whole lot of this (below), but I thought I'd like to put some of it down in blog form too.</p>

    <video src="https://videos.igalia.com/conferences/Web%20Directions%20Code%202021/Brian_Kardell_-_The_Evolution_of_the_Web_and_OffscreenCanvas.webm"></video>

    <h2>Missing Layers</h2>
    <p>Shortly after publishing the Extensible Web Manifesto, Alex Russell, Yehuda Katz and I <a href="https://www.smashingmagazine.com/2013/11/laying-the-groundwork-for-extensibility/">co-authored a piece for smashing magazine</a>, trying to explain a little better what it was (and wasn't) about.</p>

    <p>In it, we pointed out that the web was, at the time, made up of a somwhat random collection of APIs, both high level and low (primarily high, then), which usually lacked connections and introduced inconsistencies.  While it was easy to <em>imagine</em> many strata of APIs that described how a higher level feature worked, those APIs didn't actually exist.</p>

    <p>Think about how much is happening to make a simple <code>&lt;img&gt;</code> element work. As just a few examples: It's an element - it presents a specific API.  Things happen when it is inserted into the DOM.  It can reason about <code>srcset</code>, and asynchronously fetch data, stream, decode, work with CSS and ultimately paint on to the screen. It could also magically provide accessible placeholder and failure without your DOM itself changing. At the time we wrote that piece developers could do almost none of that - JavaScript was still developing async concepts, even.</p>

    <p>During the HTML5 era, pretty close to when it took up WebKit - Apple introduced <code>&lt;canvas&gt;</code>, explaining it as ~"an image, with a programatic API drawing surface".  However, it did, nor exposed any of that stuff. In fact, all work done to draw on this surface would even block the main thread.  In practice, any relationship to <code>&lt;img&gt;</code> was mainly conceptual.</p>

    <p>A more ideal web, we argued, was one in which these strata <em>do</em> exist, and parts can be referenced, reused, tweaked and composed - even in creating new high level standards.  This would also allow easier  experiment at the edges, and polyfilling.  It would require less code and clearer paths from experiment to  standardization.</p>

    <h2>Fast Forward</h2>
    <p>The pace of things in standards moves considerably more slowly than most of us are used to.  Bigger shifts can be almost imperceptable.  Thankfully, we can look back after a while and take stock of where we are today compared to where we were then.</p>

    <p>In our piece, we asked people to imagine that there was something that they wanted that was "almost an image".  Perhaps that might be something they imagine would be a small improvement to <code>&lt;img&gt;</code> itself. Perhaps it might just be an idea that has an awfully lot in common with an <code>&lt;img&gt;</code>.  Ideally, we argued, a developer should be able to  experiment with that idea.  They should be able to build it, in a manner that makes it have most of the same great qualities it would have natively.  Ideally, that would be doable without having to reimplement everything.  They should be able to try what they built, share it, and see if it meets needs as well as they imagine (many of my own first takes fall short). Ideally we could plug into the fact that outside of standards, ideas <em>rapidly</em> evolve an as people share experiments, they are tested, forked, remixed and improved.  And, ideally, all of this would make it very easy to standardize successful things because they would inherently be 'close to the platform'.</p>

    <p>Of course, at the time, absolutely none of this was true.</p>

    <p>So let's take an example:  Panning an zooming an image.  On the web, an image can be embedded in a page, or it can be opened on its own.  You can pan and zoom the page itself, but not an image.  It seems pretty obvious to me that there is a common problem here.  Every shopping site in the world wants you to be able to see detailed images somehow 'inline'.  Artists, photographers and museums often have something similiar. If you squint at it a bit, there are other use cases like maps and schematics views, or even datavis which seem similar.  If we wanted to explore some standardization here, what would it look like?</p>

    <p>To be honest, I don't know. This isn't a proposed solution, but today 

    it would be very easy to standardize the results because it would be very close to the platform.  But at the time, none of this was true.</p>





    -------------left off here---------------

      We tried to explain the impossibly bad choices you'd be left 





    <h2>An image element, kinda</h2>

    

   

    <p>In our piece, we held up several examples of why this mattered.  One that I think is interesting and easy enough to think about is: Imagine that you wanted something

    </p><h2>Fast Forward</h2>


      magine that you had an idea for something awfully <em>like</em> an <code>img</code>, but just a little different. This sort of thing happens all the time.  You'd like to build out a solution and share it, hoping to show that it was a good idea and worth standardizing.  How would you go about doing that?<p></p>

    <p>In stark contrast to almost everything that came before it, other than how to put <em>an element</em> into the DOM, <code>&lt;canvas&gt;</code> wasn't high level at all. In fact, - it <em>required</em> JavaScript and it <em>only</em> provided a low level API.</p>

    <p>Over the years people have developed increasingly amazing things with <code>&lt;canvas&gt;</code>.  That's unsurprising - and incorporated into even more complex ideas.</p>

    <p>However, a disconnect with abilities that exist within the platform means that even practically close problems begin kind of far from their platform cousins, and quickly drift further and further.  Re-integrating ideas into the platform is considerably hard.  Photoshop in the browser exists, complex mapping applications in the browser exist

      there's often no neat way to get something that far from their platform cousins back into standards.

      they just get further and further from their platform cousins.


    </p><p>One of the things I remember being highlighted here was using it in MacOS dashboard widgets.</p>

    <img src="https://km.support.apple.com/library/content/dam/edam/applecare/images/en_US/osx/mavs_dashboard.png">



   

  
  
  <p>At the time we wrote that article, the answer was pretty abysmal.  We had several high and low-level APIs that we could potentially attempt to abuse, but in the end it wouldn't be very good in just about any respect.  It would often require mountains of JavaScript, many times just to provide a very rough approximation of something the browser could already do, and do better. <code>XMLHTTPRequest</code> was, ultimately, not a lot like how images fetch their data. The canvas on which it would paint was main thread blocking. If more elements were necessary, script would inevitably muck with the users' DOM tree and create other problems.  And so on.</p>

  <p>All of these things also mean the 'proposed idea' requires a whole lot of squinting and interpretation.</p>

  <p>But maybe that sounds like it's academic.  Do developers really even have needs that are "almost an  <code>&lt;img&gt;</code>"?</p>

  <p>A lot has happened since then which I think we can use to illustrate.,



    The platform had thusfar mainly presented things in disconnected either/or fashion.  There were a number of very high level things, and there were a smaller number of lower level things.


    Sometimes there was a low level API, more often, a high level one.  But ideally, there would be some architecture connecting it all - an extensible one.  Having such a thing would enable us to 


  </p><section>
    <h2>The canvas context was unique...</h2>

    <p>ASounds cool, but... for what? 
    </p>

    <p>One of the things I remember being highlighted here was using it in MacOS dashboard widgets.</p>

    <img src="https://km.support.apple.com/library/content/dam/edam/applecare/images/en_US/osx/mavs_dashboard.png">

    <p>Perhaps one of the more interesting things about canvas was that it in stark contrast to almost everything that came before it, other than how to put <em>an element</em> into the DOM, it wasn't high level at all. In fact, - it <em>required</em> JavaScript. It <em>only</em> provided a low level API.  In fact, it provded no only a low-level for drawing on with shapes and paths, but even a low-low-level API (where you could get or set actual pixels). It didn't have narrow use cases at all either.</p>
  </section>

  <section>
    <h2>Paving the cowpaths and paying down tech debt</h2>
    
   
     and needed to pay some some attention to it and lay good groundwork for the future.<p></p>

    <p><code>&lt;canvas&gt;</code> was an illustration we used. That's because while you can <em>imagine</em> the sort of relationship with <code>&lt;img&gt;</code> as described in its introduction, it didn't exactly exist. In fact, while one probably imagined many strata of architecture empowering an <code>&lt;img&gt;</code>'s magic (fetching, decoding, painting pixels on a canvas, etc), it wasn't clear that really existed at all. From the outside, in fact, there appeared to be many inconsistencies. If such an architecture <em>did</em> exist, it was certainly unavailable to developers. This, we explained, was probably not great for the future.</p>

    <p></p>

    <p>Even during the authoring of that document, we tried to be very clear that that wasn't the idea.  </p>
  </section>

    <p>But I think what is even more interesting here is actually beneath the surface...</p>

    <p>My friend and co-worker at Igalia <a href="https://twitter.com/cwiiis">Chris Lord</a> has been working on <code>OffscreenCanvas</code> in WebKit. While you might not be thinking of this day to day, there are a tiny (and historically not growing) number of companies in the world who (voluntarily) make whole browser engines.  At the same time, there are whole world of people asking for different things.  What gets done (or doesn't) is ultimately in large part a function of this fact.

     has to give priority or else they can't get done - that's pretty hard to do because there are a million things asking for priority, and only a few companies who make browser engines.</p>  


    <p>Another thing that excites me is how Igalia is getting this work done and the impacts it has.</p>

    <p>Lots of good people in the web community are constantly pushing us to please pay attention to people who don't have expensive phones. However, not only is this not working out so well - it is really only scratching the surface of it.</p>

    <section class="sectioning">
      <h2 class="contextual-heading">For whom the bell tolls</h2>
     Cheap tablets also abound, for example.  But, far more than that: embedded devices are <em>everywhere</em>! Game consoles, the TVs they play on, the cable boxes and streaming devices that are hooked up to them: <em>All of them</em> are embedded hardware, and most of those are presenting interfaces with web rendering engines.  Wow!  And <em>those are just the ones that are probably in front of your face as you sit on the livingroom couch</em>.<p></p>

    <p>Walk into a modern kitchen and you'll find more: Smart appliances from refrigerators to stoves to cooking devices... Same thing.  </p>

    <p>Travel somewhere, you'll find web engine based interfaces in just about every form of transportation these days: Infotainment systems in cars, airplanes, trains and vehicle dashboards too.</p>

    <p>While you're looking out the window in transit, you'll see some more in digital signage. You'll find them in the stores you visit in point of sale systems, kiosks, at gas pumps - I mean, they are <em>literally everywhere</em>.</p>

    <p>For that one <em>maybe powerful</em> device you call a "phone" and look at a bunch during the day, you probably encounter half a dozen or more (and growing) embedded systems using web tech. And, with a few rare exceptions, they are almost universally underpowered, and replaced really slowly.</p>

    <p>Ask not for whom the hardware is slow - it is for you!</p>

    <p>Plenty of things which are at least usefully functional on a higher-end device can quickly drop the framerate (and resposiveness to user input) all the way down to ~1ps on some of these devices.</p>

    <p>More interestingly still - many of those devices are <em>precisely</em> the ones that really <em>want</em> the ability to make splashy visualization with canvas and SVG.</p>

    <p>Our work on <code>OffscreenCanvas</code> at Igalia helped create new priotitization pressures and diversified investments through things like cable boxes and cooking devices.  Lots of our tests that bog those systems down to near 1ps now run a fluid 60fps... And they make things better for <em>all of these devices</em> along the way.</p>

    <p>I think that's <em>hella</em> cool.</p>
  </section>
 
  <section class="sectioning">
    <h2 class="contextual-heading">Paying down Web Tech Debt</h2>

    <p>Here's <em>another</em> reason it excites me:  S
    </p><p>While I don't know that we've created a system that literally makes Apple's introduction <em>true</em>, there have been <em>lots</em> of developments and improvements to this story to make the web platform actually <em>have</em> some kind of stata of architecture that authors can understand, plug into, hack and extend - and the arrival of <code>OffscreenCanvas</code> is just the latest and greatest addition..  </p>

    <p>There are potentially many things that are <em>like</em> an <code>&lt;img&gt;</code> in some ways, and a myriad of ideas that could extend this or borrow features  I'm excited that this allows us to entertain lot of interesting experiments that we can rapidly share, compare, critique, break down, recompose nd reassemble in order to find  some really great ideas which a lot of people (and a diverse number of businesses) could support... And very importantly, it can share all fo the same platform "stuff" because it didn't have to reinvent the entire stack beneath it, making for much easier cow-paths to pave and create standards out of.</p>

    <p>What will they be? I don't know yet! I have some ideas, of course:  New patterns for data visualizations and rendering controls, for sure.  Some new ideas for image manipulation tools feel almost certain.  Perhaps customized image elements with register-able image decoders?  Perhaps ideas that integrate new concepts of panning and zooming an actual bitmap, potentially loading higher resolution one?</p>

    <figure class="captioned-image">  
      <iframe style="height: 644px" width="1145" height="644" src="https://www.youtube.com/embed/huLhOQM7pVA" title="YouTube video player" frameborder="0" allowfullscreen=""></iframe>
      <figcaption>An example of a progressively enhanced, independently pan-and-zoomable image which can lazily load higer-def image in action.</figcaption>
    </figure>

    <p>Or, maybe whole elements that manage the stitching together together of <em>many</em> tiles of a larger, and partially loaded conceptual image - like the technique used in mapping. </p>

    <p>Providing these new abilities unlocks all kinds of potential and my own imagination is limited. </p>

    <p>I can't wait to see what ideas develop here!</p>
  </section>

</article></main>
 
   
  <script>
    //import { MediaAffordancesElement } from "./MediaAffordancesElement.js";
    class MediaAffordancesElement extends HTMLElement {
      constructor() {
        super();
        // todo: this should be a private field
        this.__matching = new Set()
        this.mqls = [];
        this.observers = [];

        this.supportedAffordances = new Set();
      }

      observeAffordanceChange(cb) {
        this.observers.push(cb);
      }

      notifyChange() {
        let intersection = new Set();
        for (let elem of this.__matching) {
          if (this.supportedAffordances.has(elem)) {
            intersection.add(elem);
          }
        }

        if (this.__matching.size > 0) {
          this.setAttribute("mq-matched", [...this.__matching].join(" "));
        } else {
          this.removeAttribute("mq-matched");
        }
        let arr =  [...intersection]
        let affordance = arr[arr.length - 1];
        if (affordance) {
          this.setAttribute("affordance", affordance);
        } else {
          this.removeAttribute("affordance");
        }
        this.observers.forEach(cb => {
          cb(intersection, this.__matching);
        });
      }

      static get observedAttributes() {
        return ["mq-affordances"];
      }

      connectedCallback() {
        let newValue = getComputedStyle(this).getPropertyValue(
          "--const-mq-affordances"
        );
        this.connectListeners(newValue);
      }

      connectListeners(newValue = "") {
        if (newValue.trim().length === 0) {
          return;
        }
        
        newValue.split("|").forEach(segment => {
          let mq = segment.trim().match(/\[([^\]]*)/)[1];
          let names = segment
            .replace(`[${mq}]`, "")
            .trim()
            .split(" ");
          let mql = window.matchMedia(mq);
          let mqh = evt => {
            names.forEach(name => {
              this.__matching[mql.matches ? "add" : "delete"](name);
            });

            this.notifyChange();
          };
          mqh();
          mql.addEventListener("change", mqh);
          this.mqls.push(mql);
        }, this);
      }

      attributeChangedCallback(name, oldValue, newValue) {
        this.connectListeners(newValue);
      }
    }

    //-----------------------------------------------------

    (function() {
      let lastUId = 0;
      let nextUId = () => {
        return `cp${++lastUId}`;
      };

      let getLabels = regionset => {
        return [...regionset.children].filter(el => /^H\d$/.test(el.tagName));
      };

      let getContentEls = regionset => {
        return [...regionset.children].filter(el => !/^H\d$/.test(el.tagName));
      };

      let ensureId = el => {
        el.id = el.id || nextUId();
        return el.id;
      };

      let getDisclosureButton = label => {
        return label.shadowRoot.querySelector("button");
      };

     
      let style = document.createElement('style')
      style.innerHTML = `
          
        :where(spicy-sections > [affordance*="collapse"])::before { 
          content: ' ';
          display: inline-block;
          width: 0.5em;
          height: 0.75em;
          margin: 0 0.4em 0 0;
          transform: rotate(90deg);
          background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='10px' height='10px' viewBox='0 0 270 240' enable-background='new 0 0 270 240' xml:space='preserve'%3e%3cpolygon fill='black' points='5,235 135,10 265,235 '/%3e%3c/svg%3e ");
          background-size: 100% 100%;
        } 

        :where(spicy-sections > [affordance*="collapse"][aria-expanded="true"])::before, 
        :where(spicy-sections > [affordance*="collapse"][aria-expanded="true"])::after {
          transform: rotate(180deg);
        }
      `
      document.head.prepend(style)
      
      const template = `
            <style>
              :root {
                font-size: 1rem;
              }

              :host([hidden]),
              ::slotted([hidden]) {
                display: none;
              }
              
              ::slotted(h1),
              ::slotted(h2),
              ::slotted(h3),
              ::slotted(h4),
              ::slotted(h5),
              ::slotted(h6) {
                 margin-right: 1rem;
              }
              
              tab-bar ::slotted([tabindex="0"]) {
                border-bottom: 1px solid blue;
              }
              
              tab-list { 
                display: flex; 
                overflow: hidden;
                white-space: nowrap;
              }
            </style>
            <tab-bar part="tab-bar">
              <!-- The region/tablist should have a  label -->
              <tab-list part="tab-list" role="tablist"
              ><slot name="tabListSlot"></slot></tab-list>
            </tab-bar>
            <content part="content-panels">
              <slot default></slot>
            </content>
        `;

      class RegionSet extends MediaAffordancesElement {
        __defaults;
        __tabListEl;

        // tabs and exclusive collapses should have the same affordance object?
        __affordanceConf = {
          collapse: {
            // can take a condition to force, check-like
            toggle: (label, condition) => {
              let state =
                typeof condition === "boolean"
                  ? condition
                  : !label.affordanceState.expanded;
              let contentEl = label.nextElementSibling;
              label.affordanceState.expanded = state;
              label.affordanceState.nonExclusiveExpanded = state;
              label.setAttribute("aria-expanded", state);
              if (state) {
                label.setAttribute("expanded", "");
                contentEl.style.display = "block";
              } else {
                label.removeAttribute("expanded");
                contentEl.style.display = "none";
              }
            }
          },
          "exclusive-collapse": {
            // ignores condition, radio-like
            toggle: label => {
              let labels = getLabels(label.parentElement);
              let siblings = labels.filter(c => c !== label);
              let index = labels.findIndex(c => c === label);

              siblings.forEach((sibLabel, i) => {
                let relatedContent = sibLabel.nextElementSibling;
                sibLabel.tabIndex = -1;
                relatedContent.style.display = "none";
                label.setAttribute("aria-expanded", "false");
                sibLabel.affordanceState.exclusiveExpanded = false;
              });
              label.tabIndex = 0;
              //nope - todo, fix/remove this?
              label.parentElement.affordanceState.exclusiveSelection.index = index;
              label.nextElementSibling.style.display = "block";
              label.setAttribute("aria-expanded", "true");
              label.affordanceState.exclusiveExpanded = true;
              label.focus();
            }
          },
          "tab-bar": {
            // ignores condition, radio-like
            toggle: label => {
              let labels = getLabels(label.parentElement);
              let siblings = labels.filter(c => c !== label);
              let index = labels.findIndex(c => c === label);

              siblings.forEach((sibLabel, i) => {
                let relatedContent = sibLabel.nextElementSibling;
                sibLabel.tabIndex = -1;
                relatedContent.style.display = "none";
                sibLabel.setAttribute("aria-expanded", "false");
                sibLabel.affordanceState.exclusiveExpanded = false;
              });
              label.tabIndex = 0;
              label.parentElement.affordanceState.exclusiveSelection.index = index;
              label.nextElementSibling.style.display = "block";
              label.setAttribute("aria-expanded", "true");
              label.affordanceState.exclusiveExpanded = true;
              label.focus();
            }
          }
        };
        __setSize = (labelEls, contentEls) => {
          this.__size = Math.min(labelEls.length, contentEls.length);

          if (labelEls.length !== this.__size) {
            console.warn("mismatch in tab-set label/content pairs...");
          }

          labelEls.forEach((labelEl, i) => {
            let contentEl = contentEls[i];
            if (!labelEl.initialized) {
              labelEl.initialized = true; // todo: this used to be shadow, do i need it?
              let defs = this.__defaults.defaultActive;

              // this assumes it is about collapses
              labelEl.affordanceState = {
                expanded: defs.includes(labelEl),
                active: false,
                // activate in the current mode
                activate: () => {
                  if (this.affordanceState.current) {
                    this.__affordanceConf[this.affordanceState.current].toggle(
                      labelEl
                    );
                  }
                }
              };

              let defaultExclusive =
                defs.length === 0 ? labelEls[0] : defs[defs.length - 1];

              this.affordanceState.exclusiveSelection.index = labelEls.indexOf(
                defaultExclusive
              );
            }
            labelEl.setMode = mode => {
              if (mode === "non-exclusive") {
                let isExpanded = labelEl.affordanceState.expanded;
                labelEl.setAttribute("affordance", "collapse");
                labelEl.setAttribute("tabindex", "0");
                labelEl.setAttribute("aria-controls", contentEl.id);
                labelEl.setAttribute("role", "button");
                labelEl.setAttribute("aria-expanded", isExpanded);
                labelEl.nextElementSibling.style.display = isExpanded
                  ? "block"
                  : "none";
              } else if (mode === "exclusive") {
                let isExpanded =
                  labelEls.indexOf(labelEl) ===
                  this.affordanceState.exclusiveSelection.index;
                labelEl.setAttribute("affordance", "collapse");
                labelEl.setAttribute("tabindex", isExpanded ? 0 : -1);
                labelEl.setAttribute("role", "button");
                labelEl.setAttribute("aria-expanded", isExpanded);
                labelEl.setAttribute("aria-controls", contentEl.id);
                labelEl.nextElementSibling.style.display = isExpanded
                  ? "block"
                  : "none";
              } else {
                labelEl.removeAttribute("tabIndex");
                labelEl.removeAttribute("affordance");
                labelEl.removeAttribute("aria-expanded");
                labelEl.removeAttribute("role");
              }
            };
          });
        };

        __projectTabBar = () => {
          this.__removeProjections();
          getLabels(this).forEach((tabSource, i) => {
            let selected = false,
              tabIndex = -1,
              display = "none";

            tabSource.setMode();
            tabSource.slot = "tabListSlot";
            tabSource.setAttribute("role", "tab");
            let tabId = ensureId(tabSource);
            let contentSource = tabSource.nextElementSibling;
            contentSource.tabIndex = 0;
            tabSource.setAttribute("aria-controls", ensureId(contentSource));
            contentSource.setAttribute("role", "tabpanel");
            contentSource.setAttribute("aria-labelledby", tabSource.id);
            if (i === this.affordanceState.exclusiveSelection.index) {
              tabIndex = 0;
              selected = true;
              display = "block";
            }
            tabSource.setAttribute("aria-selected", selected);
            tabSource.tabIndex = tabIndex;
            contentSource.style.display = display;

            // TODO: aria-orientation :(
          });
        };

        __projectCollapses = exclusive => {
          // TODO - remove projections and... ??
          this.__removeProjections();
          getLabels(this).forEach(label => {
            label.setMode(exclusive ? "exclusive" : "non-exclusive");
          });
        };

        __removeProjections = () => {
          [...this.children].forEach(child => {
            child.removeAttribute("slot");
            child.removeAttribute("affordance")
            child.removeAttribute("role");
            child.removeAttribute("aria-selected");
            child.removeAttribute("aria-controls");
            child.removeAttribute("tabindex");
            child.removeAttribute("aria-expanded")
            child.style.display = "block";
          });
        };

        // matching pairs
        __size = 0;

        __configure = () => {
          ///hmmm

          this.__setSize(getLabels(this), getContentEls(this));

          if (this.affordanceState.current === "tab-bar") {
            this.affordanceState.currentMode = "exclusive";
            this.__projectTabBar();
          } else if (this.affordanceState.current === "collapse") {
            this.affordanceState.currentMode = "non-exclusive";
            this.__projectCollapses();
          } else if (this.affordanceState.current === "exclusive-collapse") {
            this.affordanceState.currentMode = "exclusive";
            this.__projectCollapses(true);
          } else {
            this.affordanceState.currentMode = undefined;
            this.__removeProjections();
          }

          let specifiedIndex = this.activeTabIndex || 0;
          // TODO: hmm, these are DOM changes, we could cache them
          let labelEls = getLabels(this);
          let contentEls = getContentEls(this);

          for (let i = 0; i < this.__size; i++) {
            let label = labelEls[i];
            // probably add one handler that decides
            if (!label._inited) {
              label.addEventListener("click", evt => {
                evt.target.affordanceState.activate();
              });
              label._inited = true;
            }
          }
        };
        
        __childListObserver = new MutationObserver(mutationList => {
          // we have to wire up new elements
          let labelEls = getLabels(this);
          let contentEls = getContentEls(this);

          // what if there is a mismatch?
          this.__setSize(labelEls, contentEls);
          this.__configure();
        });

        __tabset;

        affordanceState = {
          exclusiveSelection: { index: undefined },
          current: undefined,
          currentMode: undefined,
          getLabels: () => {
            return getLabels(this);
          }
        };

        /*
          Wires up suppored affordances...
        */
        constructor() {
          super();
          this.supportedAffordances.add("tab-bar");
          this.supportedAffordances.add("collapse");
          this.supportedAffordances.add("exclusive-collapse");

          this.observeAffordanceChange((matching, all) => {
            if (!this.__defaults) {
              this.__defaults = {
                onMatch: this.hasAttribute("defaults-on-match"),
                defaultActive: getLabels(this).filter(l =>
                  l.hasAttribute("default-activate")
                )
              };
            }
            this.affordanceState.current = this.getAttribute("affordance");
            this.__configure();
          });

          this.attachShadow({ mode: "open" });
          this.shadowRoot.innerHTML = template;
     
          this.__tabListEl = this.shadowRoot.querySelector("tab-list");
          this.addEventListener(
            "keydown",
            evt => {
              let labels = getLabels(this);
              let size = labels.length;
              let cur = this.affordanceState.exclusiveSelection.index;
              let prev = cur === 0 ? size - 1 : cur - 1;
              let next = cur === size - 1 ? 0 : cur + 1;

              if (
                this.affordanceState.current === "tab-bar" ||
                this.affordanceState.current === "exclusive-collapse"
              ) { 
                if (evt.keyCode == 37 || evt.keyCode == 38) {
                  labels[prev].affordanceState.activate();
                } else if (evt.keyCode == 39 || evt.keyCode == 40) {
                  labels[next].affordanceState.activate();
                }
              } else if (evt.keyCode == 32 && this.affordanceState.current === 'collapse') {
                evt.preventDefault()
              }
            },
            false
          );
          this.addEventListener(
            "keyup", 
            evt => {
              if (evt.keyCode == 32 && this.affordanceState.current === 'collapse') {
                evt.target.closest('[affordance]').affordanceState.activate()
                evt.preventDefault()
              }
            })
        }

        connectedCallback() {
          super.connectedCallback();

          //TODO: check whether there is a hash/handle selection
          
          // If you append a fragment with a pair, it should work
          this.__childListObserver.observe(this, { childList: true });
        }
      }
      customElements.define("spicy-sections", RegionSet);
    })();
    </script>
  <script>
    Array.prototype.slice.call(document.querySelectorAll('.optional [data-src]')).forEach(function (optional) {
      var prefs = window.localStorage.downloadsPrefs,
          clickToSee;
      if (prefs === 'true') {
        activateOptional(optional);
      } else {
        clickToSee = document.createElement('div');
        clickToSee.classList.add('clickToSee')
        clickToSee.innerHTML = '<button>Click to see media</button>';
        clickToSee.style.textAlign = 'center';
        clickToSee.style.border = 'none';
        optional.parentElement.insertBefore(clickToSee, optional.nextSibling);
        clickToSee.firstElementChild.addEventListener('click', function () {
          activateOptional(optional);
        })
      }

    })
  </script>

</body></html>