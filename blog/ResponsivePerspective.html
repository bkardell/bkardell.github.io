<html lang="en" resource-type="blogpost"><head> 
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@briankardell">
    <meta name="twitter:creator" content="@briankardell">
    <meta name="twitter:title" content="Responsive Perspective">
    <meta name="twitter:description" content="If you've ever made anything resposive, you probably experienced something like this:  You learn about Media Queries.  You try them.  Ah beautiful.  But very quickly, you wonder &quot;o">
    
    <meta name="monetization" content="$ilp.uphold.com/kKU4GXiRwhnf ">

    <link rel="alternate" type="application/rss+xml" href="https://bkardell.com/blog/feed.rss" title="bkardell.com/blog rss feed">
    <title>Responsive Perspective</title> 
    <style>.captioned-image {
    background-color: #eaeaea;
    display: block;
    overflow: hidden;
    padding: 1rem;
    text-align: center;
    font-style: italic;
}

.captioned-image.p-attached {
    width: 40%;
    display: inline-block;
    margin: 0 1rem 2rem 1rem;
}

section > .captioned-image.p-attached {
    margin-top: 1.5rem; /* correct for heading size*/
}

 pre { overflow-x: auto }

.captioned-image.p-attached.p-attached-left {
    float: left;
}

.captioned-image.p-attached.p-attached-right {
    float: right;
}

.captioned-image.p-attached + * + * {
    clear: both;
    margin-top: 2rem;
}


.captioned-image img, .captioned-image video {
    display: block;
    max-width: 100%;
    margin: 0 auto 1em auto;
}
.source {
    font-style: italic;
}
body {
    display: flex;
    font: 1em "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-weight: 400;
    line-height: 1.625;
}
h1 { margin: 0.5rem; }
code-format {
    border-left: 0.5rem solid rgba(123,115,209,0.35);
    display: block;
    padding: 0.5rem;
    margin-bottom: 1rem;
}

contextual-heading {
    display: block;
    margin-top: 2rem;
}

[aria-level="1"] {
    color: #43686b;
    font-size: 1.45rem;
}
[aria-level="2"] {
    color: #856363;
    font-size: 1.35rem;
}
[aria-level="3"] {
    color: #856363;
    font-size: 1.25rem;
}
[aria-level="4"] {
    color: #856363;
    font-size: 1.2rem;
}
[aria-level="5"], [aria-level="6"] {
    color: #667496;
    font-size: 1.1rem;
    font-weight: bolder;
}
.posted-on {
    font-style: italic;
    font-size: 0.8rem;
    text-align: right;
    margin-bottom: 1rem;
}

ul, li {
    margin: 0.5rem;
    text-align: left;
}
header {
    padding-top: 1rem;
    padding-right: 2rem;
    background-color: #fbf5e9;
}
.tagline {
    font-style: italic;
    text-align: center;
}

[tag-esc] {
    color: maroon;
    font-family: Courier, "Lucida Console", monospace;
}

[tag-esc]::before {
    content: '<';
}

[tag-esc]::after {
    content: '>';
}

main {
    min-width: 50%;
    width: 80%;
    padding: 1rem;
}
header .title {
    background-color: rgba(123,115,209,0.35);
    padding: 0.3rem;
    padding-left: 0.25rem;
    font-weight: bolder;
    font-size: 0.9rem;
    border-left: 1rem solid #999298;
}

header .profile {
    width: 50%;
    margin: 1rem 25%;
}

header .title + nav {
    font-size: 0.9rem;
}

header .blurb {
    font-size: 0.75rem;
    text-align: center;
}
header .name {
    text-align: center;
    font-size: xx-large;
}
.segue {
    font-style: italic;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
}

#aboutMeToggle {
    display: none;
}

[for="aboutMeToggle"] {
    display: none;
}

main article { max-width: 100em; margin: auto; }
/* this needs rethinking, it wants a selector like 'not flow content' */
article>*:not(contextual-heading,a), section>*:not(contextual-heading,a) {
    margin-left: 0.45rem;
}

blockquote {
  font-family: serif;
  background: #f9f9f9;
  border-left: 10px solid #ccc;
  margin: 1.5em 10px;
  padding: 0.5em 10px;
}
blockquote:before {
  color: #ccc;
  content: open-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-right: 0.25em;
  vertical-align: -0.4em;
}

blockquote:after {
  color: #ccc;
  content: close-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-left: 0.25em;
  vertical-align: -0.4em;
}


@media (max-width: 800px){
    body {
        flex-direction: column;
    }
    header {
        border-bottom: 1px solid #afafff;
    }

    .captioned-image.p-attached {
        width: 100%;
        margin: 1rem 0;
    }

    .captioned-image.p-attached.p-attached-left,
    .captioned-image.p-attached.p-attached-right {
        float: none;
    }

    [for="aboutMeToggle"] {
        background-color: #675e5e;
        color: white;
        padding: 0.25rem;
        padding-left: 0.5rem;
        display: block;
        border-left: 1rem solid black;
    }
    #aboutMeToggle:focus + [for="aboutMeToggle"]{
        outline: 4px solid #c6ddf2;
    }

    #aboutMeToggle:checked ~ header {
        display: none;
    }

    header li { display: inline; margin-left: -0.5em; }
    header .blurb li::after { content: '; '; }
    header  nav li {
        display: inline-block;
        margin-left: 0.35rem;
        margin-right: 0.35rem;
    }
    header .title {
        width: 100%;
    }
    main li .source { display: block; }

}</style>
    <style>
      .captioned-image { font-size: 0.9rem; }
      .thanksTo { font-style: italic; font-size: 0.8rem; }
    </style>
    <script>
      var activateOptional = function (media) {
        var source = media.getAttribute('data-src'),
            temp,
            container = media.parentElement;

          if (media.nextSibling && media.nextSibling.matches) {
            if (media.nextSibling.matches('.clickToSee')) {
              media.parentElement.removeChild(media.nextSibling);
            }
          }
 
          if (media.tagName === 'VIDEO') {
            temp = document.createElement('video')
            temp.setAttribute('autoplay','')
            temp.setAttribute('controls','')
            temp.setAttribute('loop','')
            temp.innerHTML = '<source src="' + source + '.webm" type="video/webm">'
                    + '<source src="' + source + '.mp4" type="video/mp4">';
            media.parentElement.replaceChild(temp, media);
            setTimeout(function () {
              temp.play()
            }, 0);
          } else {
            media.src = media.getAttribute('data-src');
          }

          container.classList.add('active');
      }
    </script>
  </head>
  <body>
    <input id="aboutMeToggle" class="sr-only" type="checkbox" checked="">
<label for="aboutMeToggle">Toggle author information</label>
<header>
    <div class="name">
        Brian Kardell
    </div>
    <img class="profile" src="/profile.jpg" alt="">
    <div class="tagline"><a href="/">Betterifying the Web</a></div>
    <div class="blurb">
        <ul>
            <li>Developer Advocate at Igalia</li>
            <li>Original Co-author/Co-signer of The Extensible Web Manifesto</li>
            <li>Co-Founder/Chair, W3C Extensible Web CG</li>
            <li>Member, W3C (The JS Foundation)</li>
            <li>Co-author of HitchJS</li>
            <li>Blogger</li>
            <li>Art, Science &amp; History Lover</li>
            <li>Standards Geek</li>
        </ul>
    </div>
    <div class="title">Follow Me On...</div>
    <nav>
        <ul>
            <li><a rel="me" href="https://briankardell.wordpress.com">Wordpress</a></li>
            <li><a rel="me" href="https://medium.com/@briankardell">Medium</a></li>
            <li><a rel="me" href="https://twitter.com/briankardell">Twitter</a></li>
            <li><a rel="me" href="https://github.com/bkardell/">Github</a></li>
            <li><a rel="me" href="https://codepen.io/bkardell">Codepen</a></li>
            <li><a rel="me" href="https://www.linkedin.com/in/brian-kardell-08a4264">LinkedIn</a></li>
            <li><a rel="me" href="https://www.instagram.com/kardellbrian">Instagram (for
art)</a></li>
            <li><a rel="me" href="http://fineartamerica.com/profiles/brian-kardell?">Fine Art
America (art for sale)</a></li>
        </ul>
    </nav>
</header>
    <main><div class="posted-on">Posted on null</div><article class="sectioning">
    <contextual-heading role="heading" aria-level="1">Responsive Perspective</contextual-heading>
    <p class="segue">
        If you've ever made anything resposive, you probably experienced something like this:  You learn about Media Queries.  You try them.  Ah beautiful.  But very quickly, you wonder "ok, but I don't really care about the <em>viewport</em> here:  How can I make the breakpoint be <em>based on available space?</em>  You discover that you can't.  You write a couple extra media queries that reason about this very specific case we see on the screen and, you're done.  This problem isn't new.  Efforts to standardize some kind of solution to it continue under the banner of "Container Queries" (previously "Element Queries"), and much has been written about it. But... I have some thoughts.
    </p>
    <section class="sectioning">
        <contextual-heading role="heading" aria-level="2">Bias</contextual-heading>
        <p>
            For a lot of us, writing CSS is not a primary part of our day to day job.  We learn it, perhaps simply to understand the technology, or to make a site for our blog or OSS project, or some side consulting work, but it's not our core concern.
        </p>
        <p>
            When that's the case, it's pretty temping to think "<em>Well... that was less pleasant than I would have liked</em>" but ultimately, just move on.  After all, it wasn't really <strong>that</strong> big of a deal... You made it work with just a couple of extra lines of code.  For many of us, it seems, we think that we just have much bigger and more complex fish to fry than worrying about saving a few lines of code.
        </p>
        <p>
            For the last few years, that's been my bias.  I've been hard at work on other things.  More core problems whose solutions lift many boats.  The 'Container Queries' problem, I thought, seemed like more of a minor nuisance.
        </p>
        <p>
            My bias has been formed, in part, because I'm not in charge of the CSS for my company's hundred or so sites, and the person who is is generally pretty stoic about it and keeps me insulated.
        </p>
        <p>
           Very recently, however, this person became unexpectedly temporarily unavailable for an extended period of time and I would have step into their world for a bit. Hey... no problem.
        </p>
    </section>

    <section class="sectioning">
        <contextual-heading role="heading" aria-level="2">What fresh hell?</contextual-heading>
        <p>
            I'm given a demo showing a new design element that will be used in several systems and how it should respond.  Luckily, this one is pretty simple, it's not even interactive.  I have no accessibility concerns.  We devise a simple receipe of HTML.  I don't really even need to make a component out of this.  Really, all that falls to me is to write somce CSS for its inclusion in our many systems.
        </p>

        <p>
            Now... We don't control the layouts or main CSS of any of those systems - and they run the gambit of variance: Some of them have core HTML and CSS that is a decade old while others are modern and in active development now.
        </p>
        <p>
            Of course, this isn't a new problem - as I said, we deliver shared stuff all the time.  So I turn to look at how they have solved similar problems.
        </p>
        <p>
            And... As I do, all I can think is "<em>What fresh hell is this?</em>"  I am suddenly struck with a new appreciation of the scale of problem.  Each site has to re-figure out the responsive breakpoints for this element with regard to all possible layouts that it can occur in!
        </p>
        <p>
            Wow... They shouldn't even have to <em>know</em> that, in fact, it's one of the reasons for centralizing design elements.  Worse, once it is done, neither side can really change anything without causing a domino effect in which all the things need to be recalculated.
        </p>

        <p>
            So... realistically, this isn't some minor inconveience at all - <em>it's precisely the kind of problem I should've been wanting to solve</em>.  Solving this lifts all boats.
        </p>
    </section>

    <section class="sectioning">
        <contextual-heading role="heading" aria-level="2">So...Where do we stand?</contextual-heading>
        <p>
            Given my new perspective, I was thankful that other people have been working on this problem.  Perhaps there's something there that could help us.  I knew we've got <code>ResizeObserver</code> coming, and that it's even shipping in Chrome. Perhaps I could use that to help make things better!  So, I spend the afternoon reading.  Very quickly, I realize that.. <em>Wow, there's still way too many things to solve here</em>.
        </p>

        <p>
            See... Very, very efficiently observing the resizing of a particular element is only a small part of the actual challenges facing designers here.  If I'm honest, I'd probably even settle for something slightly less than ideal right now in terms of efficiency if it dealt with all of the other problems too.
        </p>

        <p>
            Don't get me wrong, ResizeObservers are excellent.  They will be an important aspect of whatever the ultimate solution:  They will explain the observation magic so that the platform itself makes sense.  That's wonderful.
        </p>
        <p>
            Sadly though, even if we had them everywhere today, they don't do anything to help with the other very hard problems.  <em>How do you express and collect which breakpoints apply to which things?  How do you know which elements to watch?  How do you keep stylistic things in actual CSS?</em>.
        </p>
        <p>
            Fixing these problems involves a lot more primitives, or a lot more tooling, or both.  Further, in some ways, <em>those</em> might actually be harder problems.
        </p>
        <p></p>
    </section>
    <section class="sectioning">
        <contextual-heading role="heading" aria-level="2">But... I need an answer <em>now</em></contextual-heading>

        <p>
            So, I'm faced with two choices: Perpetuate this madness, or find something <em>good enough</em> for now and, hopefully, lift all boats.   Given this, I sat down to think about what a decent answer would even look like.
        </p>


        <p>
           One thing I noted pretty quickly is that where and how to express them seemed like one of the biggest problems.  How do you even begin to resolve this?  Of course, you want to express it in CSS, but without clever coordination, tooling, and lots of complexity - you just can't.  Someday, perhaps we will be able to, but for today, we can't.
        </p>


        <p>

            But all of those seem far less than ideal in the tradeoffs they make. I already have a place where I put my CSS, and a host of problems solved around that.  That's where it should be, really.
        </p>

        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">A subtle, but important shift in thinking</contextual-heading>
            <p>
               But, the more I thought about it, the more I thought "<em>Wait... do I really even need that?</em>".
            </p>
            <p>
                Here's what I mean:  Media Queries are powerful, but they're also kind of a pain in the ass because of that power.  In theory while anyone could lay out an infinite number of breakpoints by any arbitrary criteria, most people, I think, don't. Instead, they use a few standard, predefined breakpoints, frequently systems just expose them as kind of t-shirt sizes (small, medium, large, etc) and, surprisingly, that's enough.
            </p>
            <p>
                This kind of makes sense if you think about it because while viewports could, in theory, be any possible size, we don't create an infinite number of design variants that change display at every pixel.
            </p>
            <p>
                <em>That seemed like a really interesting observation, because that one simple shift in perspective <em>entirely</em> changes the space of the problem.</em>
            </p>
            <section class="sectioning">
                <contextual-heading role="heading" aria-level="4">Revised Perspective #1: Expression</contextual-heading>
                <p>
                    Let's talk about why this shifts the perspective in a big way.  First, if I no longer need to figure out <em>how</em> to express arbitary breakpoints, I don't have to figure out where to put them and how to get them out and interpret them and so on.
                </p>
                <p>
                    This alone creates a <strong>much</strong> easier problem to solve.  All we have to do is reflect some kind of t-shirt size attribute on the element itself based on its available size - for example in a <code>[container-size]</code> attribute.  Using this, we could just write plain old CSS.
                </p>
                <p>
                    If we made a good set of predefined sizes and named them well, then we could also approximate math using nothing more than attribute selectors.  For example <code>[container-size*="large"]</code> could match <code>large</code>, <code>x-large</code> and <code>medium-large</code>, while  <code>[container-size="large"]</code> could express something very specific.  This seemed quite expressive enough to try.
                </p>
        </section>
        <section class="sectioning">
            <contextual-heading role="heading" aria-level="4">Revised Perspective #2: What to monitor?</contextual-heading>
            <p>
                All of the current proposals do this in CSS, as such, tying an arbitrary selector to the arbitrary breakpoint.  Even in those proposals, authors would still want to be very careful about what elements they attach size monitoring to.
            </p>
            <p>
                However, I'd like to suggest that, again, this shift changes the space of the problem:  As we no longer need to tie elements to arbitrary breakpoints, we really only need one hook: The one that says "<em>This is a resposive container</em>".
            </p>

            <p>
                Now, we could use <code>MutationObserver</code> to watch all of the things that are added to or removed from the DOM that match this class, but that introduces kind of a lot of challeges: Most of the checks are just cost with no value.  We don't know when the MutationObserver got added, so we have to write extra code to deal with that, etc.
            </p>
            <p>
                That's kind of frustrating.  But, there is a perfect plugin entry point for knowing when a thing has been added or removed from the DOM which already deals with all of these issues: Custom Elements.
            </p>
            <p>
                If we created a <code>&lt;responsive-container&gt;</code> we would have all of the hooks.  We're almost there.
            </p>
            <p>
                Now, some of you will think "that has no business being in my HTML".  To which I have a few counterpoints:  First, as I said, you would have likely added some hook.  Why <em>can't</em> that hook be an element?  Like a class with no definition, an unknown tag with no definition is similarly benign.  It fact, it seems like this is kind of an ideal use of a Custom Element as Progressive Enhancement.
            </p>
            <p>
                One final point here: Sometimes, you wouldn't even see this.  Why?  Well, in addition to being usable in this simple form, other Custom Elements can simply <em>extend</em> this class and just gain these magical powers.  If someone makes a <code>&lt;x-card&gt;</code>, and <code>class XCardElement extends XResponsiveContainerElement</code>, then it just <em>is</em> a responsive container and no one even has to be the wiser.
            </p>

        </section>
        <section class="sectioning">
            <contextual-heading role="heading" aria-level="4">This is all very doable today</contextual-heading>
            <p>
                So... This is all very doable today, and it seems to me like strikes a lot of good chords.  To be honest, it even makes me wonder if we actually need so much 'more' in the design of a final solution other than better implementations and underlying primitives.
            </p>
            <p>
                I hacked up a version of this and used it in my use cases at work and the results were better than I could have imagined.  Things got <em>so much simpler</em>.
            </p>
            <p>
                I shared these thoughts with a friend because I thought that surely I am missing something critical and there has to be a really significant flaw that I'm just not seeing.  I was happily surprized when they sent me a link to Philip Walton's <a href="https://philipwalton.com/articles/responsive-components-a-solution-to-the-container-queries-problem/">Responsive Components: a Solution to the Container Queries Problem</a>, in which he landed at a shockingly similar approximation.
            </p>
            <p>
                Philip made some different implmentation choices that trade a few different things than mine, and he used classes rather than an attribute.  Nevertheless, we landed in remarkably similar places.  I was very tempted to simply promote his piece, but I thought I had a little more to say - so here are the points I want to highlight.
            </p>
            <ul>
                <li>Maybe there's a chance that, like me, you might not have a true appreciation for the scale and impact of this problem.  If you're more likely to think about 'components' - just think of it like that: At the end of the day, this is a component problem. It's like giving someone a markup receipe for tabs, and then asking each of them to implement the interactivity, and do it accessibly, please.  This shouldn't be different.  The ability to design a responsive 'thing' isn't at all an unreasonable request, it's fundamental.</li>
                <li>Maybe there's a chance that you've been thinking about Container Queries for a long time.  Note how much of the complexity involved with proposed solutions have to do with so much being potentially arbitrary.  Perhaps reading my thoughts as I thought through it myself this can help you look at the problem with different eyes.  Maybe that's useful.</li>
                <li>Finally, I just want to say "Hey... Here's a thing that could make your life easier... Maybe it's worth trying!"  I think this is a fundamentally important extensible web concept.  The technically 'best' solution hardly ever wins, and at the end of the day, we can't know precisely what is the fitness function here... We have to try things and see what it is.  Maybe this is something worth trying as a community.</li>
            </ul>


        </section>
    <!-- p class="thanksTo"></p -->
</section></section></article></main>

  
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-88027178-1', 'auto');
    ga('send', 'pageview');
  </script>

  <script>
    Array.prototype.slice.call(document.querySelectorAll('.optional [data-src]')).forEach(function (optional) {
      var prefs = window.localStorage.downloadsPrefs,
          clickToSee;
      if (prefs === 'true') {
        activateOptional(optional);
      } else {
        clickToSee = document.createElement('div');
        clickToSee.classList.add('clickToSee')
        clickToSee.innerHTML = '<button>Click to see media</button>';
        clickToSee.style.textAlign = 'center';
        clickToSee.style.border = 'none';
        optional.parentElement.insertBefore(clickToSee, optional.nextSibling);
        clickToSee.firstElementChild.addEventListener('click', function () {
          activateOptional(optional);
        })
      }

    })
  </script>

</body></html>