<html lang="en" resource-type="blogpost"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@briankardell">
    <meta name="twitter:creator" content="@briankardell">
    <meta name="twitter:title" content="Responsive Perspective">
    <meta name="twitter:description" content="If you've ever made anything resposive, you probably experienced something like this:  You learn about Media Queries.  You try them.  Ah beautiful.  But very quickly, you wonder &quot;o">
    
    <link rel="alternate" type="application/rss+xml" href="blog/feed.rss" title="bkardell.com/blog rss feed">
    <title>Responsive Perspective</title>
    <style>.captioned-image {
    background-color: #eaeaea;
    display: block;
    overflow: hidden;
    padding: 1rem;
    text-align: center;
    font-style: italic;
}

.captioned-image.p-attached {
    width: 40%;
    display: inline-block;
    margin: 0 1rem 2rem 1rem;
}

section > .captioned-image.p-attached {
    margin-top: 1.5rem; /* correct for heading size*/
}

 pre { overflow-x: auto }

.captioned-image.p-attached.p-attached-left {
    float: left;
}

.captioned-image.p-attached.p-attached-right {
    float: right;
}

.captioned-image.p-attached + * + * {
    clear: both;
    margin-top: 2rem;
}


.captioned-image img, .captioned-image video {
    display: block;
    max-width: 100%;
    margin: 0 auto 1em auto;
}
.source {
    font-style: italic;
}
body {
    display: flex;
    font: 1em "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-weight: 300;
    line-height: 1.625;
}
h1 { margin: 0.5rem; }
code-format {
    border-left: 0.5rem solid rgba(123,115,209,0.35);
    display: block;
    padding: 0.5rem;
    margin-bottom: 1rem;
}

contextual-heading {
    display: block;
    margin-top: 2rem;
}

[aria-level="1"] {
    color: #43686b;
    font-size: 1.45rem;
}
[aria-level="2"] {
    color: #856363;
    font-size: 1.35rem;
}
[aria-level="3"] {
    color: #856363;
    font-size: 1.25rem;
}
[aria-level="4"] {
    color: #856363;
    font-size: 1.2rem;
}
[aria-level="5"], [aria-level="6"] {
    color: #667496;
    font-size: 1.1rem;
    font-weight: bolder;
}
.posted-on {
    font-style: italic;
    font-size: 0.8rem;
    text-align: right;
    margin-bottom: 1rem;
}

ul, li {
    margin: 0.5rem;
    text-align: left;
}
header {
    padding-top: 1rem;
    padding-right: 2rem;
    background-color: #fbf5e9;
}
.tagline {
    font-style: italic;
    text-align: center;
}

[tag-esc] {
    color: maroon;
    font-family: Courier, "Lucida Console", monospace;
}

[tag-esc]::before {
    content: '<';
}

[tag-esc]::after {
    content: '>';
}

main {
    min-width: 50%;
    width: 80%;
    padding: 1rem;
}
header .title {
    background-color: rgba(123,115,209,0.35);
    padding: 0.3rem;
    padding-left: 0.25rem;
    font-weight: bolder;
    font-size: 0.9rem;
    border-left: 1rem solid #999298;
}

header .profile {
    width: 50%;
    margin: 1rem 25%;
}

header .title + nav {
    font-size: 0.9rem;
}

header .blurb {
    font-size: 0.75rem;
    text-align: center;
}
header .name {
    text-align: center;
    font-size: xx-large;
}
.segue {
    font-style: italic;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
}
[for="aboutMeToggle"] {
    display: none;
}
/* this needs rethinking, it wants a selector like 'not flow content' */
article>*:not(contextual-heading,a), section>*:not(contextual-heading,a) {
    margin-left: 0.45rem;
}

blockquote {
  font-family: serif;
  background: #f9f9f9;
  border-left: 10px solid #ccc;
  margin: 1.5em 10px;
  padding: 0.5em 10px;
}
blockquote:before {
  color: #ccc;
  content: open-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-right: 0.25em;
  vertical-align: -0.4em;
}

blockquote:after {
  color: #ccc;
  content: close-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-left: 0.25em;
  vertical-align: -0.4em;
}


@media (max-width: 800px){
    body {
        flex-direction: column;
    }
    header {
        border-bottom: 1px solid #afafff;
    }

    .captioned-image.p-attached {
        width: 100%;
        margin: 1rem 0;
    }

    .captioned-image.p-attached.p-attached-left,
    .captioned-image.p-attached.p-attached-right {
        float: none;
    }

    [for="aboutMeToggle"] {
        background-color: #675e5e;
        color: white;
        padding: 0.25rem;
        padding-left: 0.5rem;
        display: block;
        border-left: 1rem solid black;
    }
    #aboutMeToggle:focus + [for="aboutMeToggle"]{
        outline: 4px solid #c6ddf2;
    }

    #aboutMeToggle:checked ~ header {
        display: none;
    }

    header li { display: inline; margin-left: -0.5em; }
    header .blurb li::after { content: '; '; }
    header  nav li {
        display: inline-block;
        margin-left: 0.35rem;
        margin-right: 0.35rem;
    }
    header .title {
        width: 100%;
    }
    main li .source { display: block; }

}</style>
    <style>
      .captioned-image { font-size: 0.9rem; }
      .thanksTo { font-style: italic; font-size: 0.8rem; }
    </style>
    <script>
      var activateOptional = function (media) {
        var source = media.getAttribute('data-src'),
            temp,
            container = media.parentElement;

          if (media.nextSibling && media.nextSibling.matches) {
            if (media.nextSibling.matches('.clickToSee')) {
              media.parentElement.removeChild(media.nextSibling);
            }
          }

          if (media.tagName === 'VIDEO') {
            temp = document.createElement('video')
            temp.setAttribute('autoplay','')
            temp.setAttribute('controls','')
            temp.setAttribute('loop','')
            temp.innerHTML = '<source src="' + source + '.webm" type="video/webm">'
                    + '<source src="' + source + '.mp4" type="video/mp4">';
            media.parentElement.replaceChild(temp, media);
            setTimeout(function () {
              temp.play()
            }, 0);
          } else {
            media.src = media.getAttribute('data-src');
          }

          container.classList.add('active');
      }
    </script>
  </head>
  <body>
    <input id="aboutMeToggle" class="sr-only" type="checkbox" checked="">
<label for="aboutMeToggle">Toggle author information</label>
<header>
    <div class="name">
        Brian Kardell
    </div>
    <img class="profile" src="/profile.jpg" alt="">
    <div class="tagline"><a href="/">Betterifying the Web</a></div>
    <div class="blurb">
        <ul>
            <li>Sr Front-End Engineer at Apollo Group, Inc</li>
            <li>Original Co-author/Co-signer of The Extensible Web Manifesto</li>
            <li>Co-Founder/Chair, W3C Extensible Web CG</li>
            <li>Member, W3C (The JS Foundation)</li>
            <li>Co-author of HitchJS</li>
            <li>Blogger</li>
            <li>Art, Science &amp; History Lover</li>
            <li>Standards Geek</li>
        </ul>
    </div>
    <div class="title">Follow Me On...</div>
    <nav>
        <ul>
            <li><a rel="me" href="https://briankardell.wordpress.com">Wordpress</a></li>
            <li><a rel="me" href="https://medium.com/@briankardell">Medium</a></li>
            <li><a rel="me" href="https://twitter.com/briankardell">Twitter</a></li>
            <li><a rel="me" href="https://github.com/bkardell/">Github</a></li>
            <li><a rel="me" href="https://codepen.io/bkardell">Codepen</a></li>
            <li><a rel="me" href="https://www.linkedin.com/in/brian-kardell-08a4264">LinkedIn</a></li>
            <li><a rel="me" href="https://www.instagram.com/kardellbrian">Instagram (for
art)</a></li>
            <li><a rel="me" href="http://fineartamerica.com/profiles/brian-kardell?">Fine Art
America (art for sale)</a></li>
        </ul>
    </nav>
</header>
    <main><div class="posted-on">Posted on null</div><article class="sectioning">
    <contextual-heading role="heading" aria-level="1">Responsive Perspective</contextual-heading>
    <p class="segue">
        If you've ever made anything resposive, you probably experienced something like this:  You learn about Media Queries.  You try them.  Ah beautiful.  But very quickly, you wonder "ok, but I don't really care about the <em>viewport</em> here:  How can I make the breakpoint be <em>based on available space?</em>  You discover that you can't.  You write a couple extra media queries that reason about this very specific case we see on the screen and, you're done.  This problem isn't new.  Efforts to standardize some kind of solution to it continue under the banner of "Container Queries" (previously "Element Queries"), and much has been written about it. But... I have some thoughts.
    </p>
    <section class="sectioning">
        <contextual-heading role="heading" aria-level="2">What do you do?</contextual-heading>
        <p>
            I think that most of us who do anything at all with the Web have probably written some CSS and that the situation described in the intro probably portrays a fairly basic, common, shared experience.  For a lot of us, though, this is not a primary part of our day to day job - it's just a thing we 'kind of do', perhaps to understand the technology, or to make our own site, or a site for our OSS project, or some side consulting work.
        </p>
        <p>
            If that descibes you, then when you hit the situation above, it's pretty temping to think "<em>Well... that was less pleasant than I would have liked</em>" but ultimately, just move on.  After all, it wasn't really <strong>that</strong> big of a deal... You made it work with just a couple of extra lines of code.  For many of us, it seems, we just have much bigger and more complex fish to fry than worrying about saving that little extra bit of effort.
        </p>
        <p>
            For the last few years, I've been busy devising shared declarative components or focused on performance, accessibility, user experience and all sorts of other things.  All of these, in my mind, were hard problems with scalable value.  A well designed 'component' designed to be used declaratively, for example, is reusable in many systems and has longevity - even if the actual implementation changes.  Our teams can talk about a thing, and use the same markup, predictable DOM and common CSS, and so on regardless of whether the folks using it are using a Custom Element or an older version of Angular - and our users can have the same experience expectations.  That means you can afford to centralize investments too.  There's a lot of value gained, at a lot of levels.  Similarly, providing some core accessibility features like <em>:focus-visible</em> or <em>inert</em> makes previously difficult situations with no good answers suddenly much simpler, and provides some good answers for everyone that uses them.
        </p>
        <p>
            So... That's sort of how I framed things in my mind: <em>These</em> were things with much value, while the 'Container Queries' was more of a minor nuisance. A big part of that attitude is, no doubt, because I haven't been in charge of our CSS and because the person who is is generally pretty stoic about it, they don't complain.
        </p>
        <p>
            But then something happened that caused me to shift my perspective.  Very recently, this person became unexpectedly temporarily unavailable for an extended period of time and I would have step into their world for a bit. Hey... no problem.
        </p>
    </section>

    <section class="sectioning">
        <contextual-heading role="heading" aria-level="2">What fresh hell?</contextual-heading>
        <p>
            I'm given a demo showing a new markup pattern that will be used in several systems and how it should respond.  Luckily, this one is pretty simple, it's not even interactive.  I have no accessibility concerns.  We don't really even need to make a component out of this, it's just "here's a very very simple receipe of HTML".  Really, all that I have to do is provide the CSS to make it responsive.
        </p>

        <p>
            But.. You just can't.  We don't control the layouts or CSS in any of those systems, all we can do is give them a thing to integrate.  These systems run the gambit of variance, some of them have core HTML and CSS tht is a decade old, others are in active development now.  This isn't a new problem, so I turn to look at how they have solved similar problems.
        </p>
        <p>
            A I can think, as I do so is "<em>What fresh hell is this?</em>"  I am struck with a new appreciation of the scale of problem.  Each site has to re-figure out the responsive breakpoints for this element with regard to all possible layouts that it can occur in.  Neither side can really change anything without causing a domino effect in which all the things need to be redone.  Realistically, this is precisely the <em>kind</em> of problem I want to solve.
        </p>
    </section>

    <section class="sectioning">
        <contextual-heading role="heading" aria-level="2">So...Where do we stand?</contextual-heading>
        <p>
            Given my new perspective, I am thankful that other people have been working on this problem.  Perhaps there's something that could us.  I knew we've got <code>ResizeObserver</code> coming, and that it's even shipping in Chrome. Perhaps I could use them to help make this better.  So, I spend the afternoon reading.  Very quickly, I realize that.. <em>Wow, there's still way too many things to solve here</em>.
        </p>

        <p>
            Very, very efficiently observing the resizing of a particular element is only a small part of the actual challenges facing designers here.  If I'm honest, I'd probably even settle for something slightly less than ideal right now in terms of efficiency if it dealt with all of the other problems too.
        </p>

        <p>
            Don't get me wrong, ResizeObservers are excellent, and ultimately will be an important aspect of the ultimate solution.  They will explain the observation magic involved in whatever we ultimately introduce so that the platform itself makes sense.
        </p>
        <p>
            Sadly though, even if we had them everywhere, they don't do anything to help with the other very hard problems.  <em>How do you express and collect which breakpoints apply to which things?  How do you know which elements to watch?  How do you keep stylistic things in actual CSS?</em>.
        </p>
        <p>
            Fixing these problems involves a lot more primitives, or a lot more tooling, or both.  Further, in some ways, <em>those</em> might actually be harder problems.</p>
        <p></p>
    </section>
    <section class="sectioning">
        <contextual-heading role="heading" aria-level="2">But... I need an answer <em>now</em></contextual-heading>

        <p>
            So, I'm faced with two choices: Perpetuate this madness, or find something <em>good enough</em> for now and, hopefully, lift all boats.   Given this, I sat down to think about what a decent answer would even look like.
        </p>

        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">Expressing Container Breakpoints</contextual-heading>
            <p>
               One thing I noted pretty quickly is that where and how to express them seemed like one of the biggest problems.  How do you even begin to resolve this?  I see solutions that use a script or a template tag or something, and clever ways to 'process' that, but they all seem far less than ideal in the tradeoffs they make. I already have a place where I put my CSS, and a host of problems solved around that.  That's where it should be, really.
            </p>
            <p>
               But, the more I thought about it, the more I thought "<em>Wait... do I really even need that?</em>".
            </p>
            <p>
                I mean, think about it.. Media Queries are powerful, but they're also kind of a pain in the ass because of that power.  In theory while anyone could lay out an infinite number of breakpoints by any arbitrary criteria, most people, I think, don't. Instead, they use a few standard breakpoints.  Some systems just expose them as kind of t-shirt sizes, and, surprisingly, that's enough.
            </p>
            <p>
                 That's really interesting, because that simple shift in perspective totally change the space of the problem!
            </p>
            <p>
                If there's no need to express arbitrary breakpoints, we could simply automatically attach a something to the element in the DOM that lets us know, roughly, "How much space do I have to play with?".
            </p>
            <p>
                Given that, we don't have to parse CSS at all - it's just stuff that works today, and has for eons.  We don't have to make compromises to come up with some crazy notation to express arbitary breakpoints in HTML, or move that stuff into HTML markup either.
            </p>
            <p>
                Wow.  That's a <strong>much</strong> easier problem to solve.  Again, it's potentially a trade in efficiency.  @ rules in CSS (like media queries) shift a whole 'stylesheet' into the mix at once, or remove it in one go.  That's potentially more efficient, but not strictly necessary.
            </p>
            <p>
                Taken a little further, we can perhaps define a number of t-shirt size breakpoints.  If we name them well, and use an attribute rather than a class, then we can also approximate math using nothing more than CSS's powerful attribute selectors which were part of CSS 2.1!
            </p>
            <p>
                For example <code>[container-size*="large"]</code> could match <code>large</code>, <code>x-large</code> and <code>medium-large</code>, while  <code>[container-size="large"]</code> could express something very specific.  This seemed quite expressive enough to try.
            </p>
        </section>
        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">What to monitor?</contextual-heading>
            <p>
                The next big problem to solve is how to figure out how to say "these are the things I need you to monitor in the first place".  All of the current proposals do this in CSS, with an arbitrary selector.
            </p>
            <p>
                However, if I were to express a container query in CSS, I'd still want to be very careful about what I attached it to.  I'll want some kind of hook, maybe a class.  Good old classes.
            </p>
            <p>
                But, again, realize that we've changed the shape of the problem and how much that impacts. We're no longer saying "<em>Please monitor this specific thing for these specific breakpoints</em>".  Now, we're simply saying "<em>Please monitor this thing the same way you do for all of the other responsive containers, and just update the t-shirt size accordingly</em>".
            </p>

            <p>
                So... how many possible 'hooks' do I need?  Well.. Just One.  The one that says "<em>This is a resposive container</em>".
            </p>

            <p>
                Now, we could use <code>MutationObserver</code> to watch all of the things that are added to or removed from the DOM that match this class, but that introduces kind of a lot of challeges: Most of the checks are just cost with no value.  We don't know when the MutationObserver got added, so we have to write extra code to deal with that, etc.
            </p>
            <p>
                That's kind of frustrating.  But, there is a perfect plugin entry point for knowing when a thing has been added or removed from the DOM which already deals with all of these issues: Custom Elements.
            </p>
            <p>
                If we created a <code>&lt;responsive-container&gt;</code> we would have all of the hooks.  We're almost there.
            </p>
            <p>
                Now, some of you will think "that has no business being in my HTML".  To which I have a few counterpoints:  First, as I said, you would have likely added some hook.  Why <em>can't</em> that hook be an element?  Like a class with no definition, an unknown tag with no definition is similarly benign.  It fact, it seems like this is kind of an ideal use of a Custom Element as Progressive Enhancement.
            </p>
            <p>
                One final point here: Sometimes, you wouldn't even see this.  Why?  Well, in addition to being usable in this simple form, other Custom Elements can simply <em>extend</em> this class and just gain these magical powers.  If someone makes a <code>&lt;x-card&gt;</code>, and <code>class XCardElement extends XResponsiveContainerElement</code>, then it just <em>is</em> a responsive container and no one even has to be the wiser.
            </p>
        </section>
        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">This is all very doable today</contextual-heading>
            <p>
                So... This is all very doable today, and it seems to me like strikes a lot of good chords.  To be honest, it even makes me wonder if we actually need so much 'more' in the design of a final solution other than better implementations and underlying primitives.
            </p>
            <p>
                I hacked up a version of this and used it in my use cases at work and the results were better than I could have imagined.  Things got <em>so much simpler</em>.
            </p>
            <p>
                I shared these thoughts with a friend because I thought that surely I am missing something critical and there has to be a really significant flaw that I'm just not seeing.  I was happily surprized when they sent me a link to Philip Walton's <a href="https://philipwalton.com/articles/responsive-components-a-solution-to-the-container-queries-problem/">Responsive Components: a Solution to the Container Queries Problem</a>, in which he landed at a shockingly similar approximation.
            </p>
            <p>
                Philip made some different implmentation choices that trade a few different things than mine, and he used classes rather than an attribute.  Nevertheless, we landed in remarkably similar places.  I was very tempted to simply promote his piece, but I thought I had a little more to say - so here are the points I want to highlight.
            </p>
            <ul>
                <li>Maybe there's a chance that, like me, you might not have a true appreciation for the scale and impact of this problem.  If you're more likely to think about 'components' - just think of it like that: At the end of the day, this is a component problem. It's like giving someone a markup receipe for tabs, and then asking each of them to implement the interactivity, and do it accessibly, please.  This shouldn't be different.  The ability to design a responsive 'thing' isn't at all an unreasonable request, it's fundamental.</li>
                <li>Maybe there's a chance that you've been thinking about Container Queries for a long time.  Note how much of the complexity involved with proposed solutions have to do with so much being potentially arbitrary.  Perhaps reading my thoughts as I thought through it myself this can help you look at the problem with different eyes.  Maybe that's useful.</li>
                <li>Finally, I just to say "Hey... Here's a thing that could make your life easier... Maybe it's worth trying!"  I think this is a fundamentally important extensible web concept.  The technically 'best' solution hardly ever wins, and at the end of the day, we can't know precisely what is the fitness function here... We have to try things and see what it is.  Maybe this is something worth trying as a community.</li>
            </ul>


        </section>
    <!-- p class="thanksTo"></p -->
</section></article></main>

  
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-88027178-1', 'auto');
    ga('send', 'pageview');
  </script>

  <script>
    Array.prototype.slice.call(document.querySelectorAll('.optional [data-src]')).forEach(function (optional) {
      var prefs = window.localStorage.downloadsPrefs,
          clickToSee;
      if (prefs === 'true') {
        activateOptional(optional);
      } else {
        clickToSee = document.createElement('div');
        clickToSee.classList.add('clickToSee')
        clickToSee.innerHTML = '<button>Click to see media</button>';
        clickToSee.style.textAlign = 'center';
        clickToSee.style.border = 'none';
        optional.parentElement.insertBefore(clickToSee, optional.nextSibling);
        clickToSee.firstElementChild.addEventListener('click', function () {
          activateOptional(optional);
        })
      }

    })
  </script>

</body></html>