<html lang="en" resource-type="blogpost"><head>  
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="view-transition" content="same-origin"> 

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@briankardell">
    <meta name="twitter:creator" content="@briankardell">
    <meta name="twitter:title" content="tel:me.about.it.">
    <meta name="twitter:description" content="Let’s talk about protocols. I’ve been repeating most of what is in this post in conversations for a while now, so I thought I should write it down.  They are thoughts around what i">
    
    <!-- meta name="monetization" content="$ilp.uphold.com/kKU4GXiRwhnf " -->
    
    <link rel="alternate" type="application/rss+xml" href="https://bkardell.com/blog/feed.rss" title="bkardell.com/blog rss feed">
    <title>tel:me.about.it.</title> 
    <style>.captioned-image {
    background-color: #eaeaea;
    display: block;
    overflow: hidden;
    padding: 1rem;
    text-align: center;
    font-style: italic;
}

.captioned-image.p-attached {
    width: 40%;
    display: inline-block;
    margin: 0 1rem 2rem 1rem;
}

section > .captioned-image.p-attached {
    margin-top: 1.5rem; /* correct for heading size*/
}

 pre { overflow-x: auto }

.captioned-image.p-attached.p-attached-left {
    float: left;
}

.captioned-image.p-attached.p-attached-right {
    float: right;
}

.captioned-image.p-attached + * + * {
    clear: both;
    margin-top: 2rem;
}


.captioned-image img, .captioned-image video {
    display: block;
    max-width: 100%;
    margin: 0 auto 1em auto;
}
.source {
    font-style: italic;
}
body {
    display: grid;
    grid-template-columns: 25rem auto;
    font: 1.1rem "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-weight: 400;
    line-height: 1.625;
    margin: 0;
}
h1 { margin: 0.5rem; }
code-format {
    border-left: 0.5rem solid rgba(123,115,209,0.35);
    display: block;
    padding: 0.5rem;
    margin-bottom: 1rem;
}

contextual-heading {
    display: block;
    margin-top: 2rem;
}

h1, [aria-level="1"] {
    color: #43686b;
    font-size: 1.45rem;
}

h2, [aria-level="2"] {
    color: #856363;
    font-size: 1.35rem;
}

h3, [aria-level="3"] {
    color: #856363;
    font-size: 1.25rem;
}

h4, [aria-level="4"] {
    color: #856363;
    font-size: 1.2rem;
}

h5, h6, [aria-level="5"], [aria-level="6"] {
    color: #667496;
    font-size: 1.2rem;
    font-weight: bolder;
}

.posted-on {
    font-style: italic;
    font-size: 0.8rem; 
    text-align: right;
    margin-bottom: 1rem;
}

ul, li {
    margin: 0.5rem;
    text-align: left;
}

.authorinfo {
    height: 100%;
    padding-top: 1rem;
    padding-right: 0;
    background-color: #fbf5e9; 
    display: block;
    background-image: linear-gradient(to right, #dde0e8 , #ffffff);
}

.tagline {
    font-style: italic;
    text-align: center;
}

[tag-esc] {
    color: maroon;
    font-family: Courier, "Lucida Console", monospace;
}

[tag-esc]::before {
    content: '<';
}

[tag-esc]::after {
    content: '>';
}

main {
    min-width: 50%;
    width: 80%;
    padding: 1rem;
}
header .title {
    background-color: rgba(123,115,209,0.35);
    padding: 0.3rem;
    padding-left: 0.25rem;
    font-weight: bolder;
    font-size: 1rem;
    border-left: 1rem solid #999298;
}

header .profile {
    width: 50%;
    margin: 1rem 25%;
}

header .title + nav {
    font-size: 0.9rem;
}

header .blurb {
    font-size: 0.9rem;
    text-align: center;
}
header .name {
    text-align: center;
    font-size: xx-large;
}
.segue {
    font-style: italic;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
}

#aboutMeToggle {
    display: none;
}

spicy-sections:not([affordance]) > h2 {
  clip: rect(0 0 0 0);
  clip-path: inset(50%);
  height: 1px;
  overflow: hidden;
  position: absolute;
  white-space: nowrap;
  width: 1px;
}

main article { max-width: 100em; margin: auto; }
/* this needs rethinking, it wants a selector like 'not flow content' */
article>*:not(contextual-heading,a), section>*:not(contextual-heading,a) {
    margin-left: 0.45rem;
}

blockquote {
  font-family: serif;
  background: #f9f9f9;
  border-left: 10px solid #ccc;
  margin: 1.5em 10px;
  padding: 0.5em 10px;
}
blockquote:before {
  color: #ccc;
  content: open-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-right: 0.25em;
  vertical-align: -0.4em;
}

blockquote:after {
  color: #ccc;
  content: close-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-left: 0.25em;
  vertical-align: -0.4em;
}
 

@media (max-width: 800px){
    body {
        grid-template-columns: 1fr;
    }
    .authorinfo {
        height: auto;
        border-bottom: 1px solid #afafff;
        padding-top:  0;
    } 

    main { width: 95%; margin: 0 auto;}

    .captioned-image.p-attached {
        width: 100%;
        margin: 1rem 0;
    }

    .captioned-image.p-attached.p-attached-left,
    .captioned-image.p-attached.p-attached-right {
        float: none;
    }

    #aboutMeToggle {
        display: block;
        background-color: #675e5e;
        color: white;
        padding: 0.25rem;
        padding-left: 0.5rem;
        border-left: 1rem solid black;
    }

    header li { display: inline; margin-left: -0.5em; }
    header .blurb li::after { content: '; '; }
    header  nav li {
        display: inline-block;
        margin-left: 0.35rem;
        margin-right: 0.35rem;
    }
    header .title {
        width: 100%;
    }
    main li .source { display: block; }

} 

spicy-sections {
    --const-mq-affordances:
      [screen and (min-width: 600px) ] collapse |
      [screen and (min-width: 801px) ] tab-bar
    ;
    display: block;
}

spicy-sections.authorinfo {
    --const-mq-affordances:
      [screen and (max-width: 801px) ] collapse
    ;
}


spicy-sections.single {
    --const-mq-affordances:
      [screen ] collapse 
;
}

[role="tab"] {
    margin-right:  1.5rem;
}

</style>
    <style> 
      .captioned-image { font-size: 0.9rem; }
      .thanksTo { font-style: italic; font-size: 0.8rem; }
    </style>
    <script>
      var activateOptional = function (media) {
        var source = media.getAttribute('data-src'),
            temp,
            container = media.parentElement;

          if (media.nextSibling && media.nextSibling.matches) {
            if (media.nextSibling.matches('.clickToSee')) {
              media.parentElement.removeChild(media.nextSibling);
            }
          }
 
          if (media.tagName === 'VIDEO') {
            temp = document.createElement('video')
            temp.setAttribute('autoplay','')
            temp.setAttribute('controls','')
            temp.setAttribute('loop','')
            temp.innerHTML = '<source src="' + source + '.webm" type="video/webm">'
                    + '<source src="' + source + '.mp4" type="video/mp4">';
            media.parentElement.replaceChild(temp, media);
            setTimeout(function () {
              temp.play()
            }, 0);
          } else {
            media.src = media.getAttribute('data-src');
          }

          container.classList.add('active');
      }
    </script>
  </head>
  <body>
    <spicy-sections class="authorinfo">
<h2 id="aboutMeToggle" defaults-on-match="">Author Information</h2>
  
<header>
    <div class="name">
        Brian Kardell
    </div>
    <img class="profile" src="/profile.jpg" alt="">
    <div class="tagline"><a href="/">Betterifying the Web</a></div>
    <div class="blurb">
        <ul>
            <li>Developer Advocate at Igalia</li>
            <li>Original Co-author/Co-signer of The Extensible Web Manifesto</li>
            <li>Co-Founder/Chair, W3C Extensible Web CG</li>
            <li>Member, W3C (OpenJS Foundation)</li>
            <li>Co-author of HitchJS</li>
            <li>Blogger</li>
            <li>Art, Science &amp; History Lover</li>
            <li>Standards Geek</li>
        </ul>
    </div>
    <div class="title">Follow Me On...</div>
    <nav>
        <ul>
            <li><a rel="me" href="https://briankardell.wordpress.com">Wordpress</a></li>
            <li><a rel="me" href="https://medium.com/@briankardell">Medium</a></li>
            <li><a rel="me" href="https://twitter.com/briankardell">Twitter</a></li>
            <li><a rel="me" href="https://github.com/bkardell/">Github</a></li>
            <li><a rel="me" href="https://toot.cafe/@bkardell">Mastodon</a></li>
            <li><a rel="me" href="https://bsky.app/profile/bkardell.com">Bluesky</a></li>
            <li><a rel="me" href="https://codepen.io/bkardell">Codepen</a></li>
            <li><a rel="me" href="https://www.linkedin.com/in/brian-kardell-08a4264">LinkedIn</a></li>
            <li><a rel="me" href="https://www.instagram.com/kardellbrian">Instagram (for
art)</a></li>
            <li><a rel="me" href="http://fineartamerica.com/profiles/brian-kardell?">Fine Art
America (art for sale)</a></li>
        </ul>
    </nav>
</header>
</spicy-sections>
<script>
  /*
    You're probably wondering "Do I need to write this?""
    "Is this part of it?"  No... If you're interested tho - 
    Custom elements have a FOUC/PE gap 
    (see https://github.com/whatwg/html/issues/6231).
    This is a slightly better experience: It 
    will be hidden _if JS is enabled_, and 
    will be shown as it is defined, 
    or after 1 sec, whichever is first.
  */
  let ss = document.createElement("style");

  ss.innerHTML = `html:not(.lldelay) :not(:defined) { visibility: hidden; }`;
  document.head.appendChild(ss);

  setTimeout(() => {
    document.documentElement.classList.add("lldelay");
  }, 1000);
</script>
    <main><div class="posted-on">Posted on null</div><article class="sectioning">
	<h1 class="contextual-heading">tel:me.about.it.</h1>
	<p class="segue">Let’s talk about protocols. I’ve been repeating most of what is in this post in conversations for a while now, so I thought I should write it down.  They are thoughts around what it means to add new protocols to the platform, and how we go about it in practice.  The main extensibility mechanism that we have comes from the HTML5 era: <code>registerProtocolHandler()</code>. In this post I’ll explain where I think that’s kind of OK, where it falls (sometimes very) short, and some things I think we learned along the way. The purpose of this post isn’t to make suggestions, it’s simply to have a look at the space and the things I think we need to keep in mind.</p>


	<p>Most of the URLs we type these days begin with <code>https:</code> - or before that, <code>http:</code>.  We changed the main protocol of the web to be more secure.  It’s not inconceivable we could want to have that level of change again, but there are plenty of things short of that where protocols develop and somehow find their way into the platform.</p>

	<p>A few popular examples from the HTTPArchive data: Over 30% of websites include at least one <code>mailto:</code> link. Almost as many sites include a <code>tel:</code> link. There’s plenty of <a href="https://en.wikipedia.org/wiki/Webcal" target="_blank" rel="noopener"><code>webcal:</code></a> and <a href="https://www.rfc-editor.org/rfc/rfc2806#section-2.3" target="_blank" rel="noopener"><code>fax:</code></a>. <a href="https://en.wikipedia.org/wiki/Geo_URI_scheme" target="_blank" rel="noopener"><code>geo:</code></a> is used on over 20,300 sites. <code>sms:</code> is used on 42,600+ websites. These are just a few examples of protocols that are trying to do something useful.</p>

	<section class="sectioning">
		<h2 class="contextual-heading">Things That Go “Click”</h2>

		<p>When you click a link that has one of those protocol identifiers, the browser says “Do I know how to handle that protocol?”  If the answer is no, it passes responsibility along to the OS.  So, if you have Skype installed, and click on a <code>skype:</code> link, the OS might launch Skype for you.</p>

		<p>Protocol handlers really are just built on the idea that over time, we build web-based services and it should be possible to say that the way to handle them can be by rerouting handling to a domain (say, gmail.com for <code>mailto:</code> links).</p>

		<p>So, for those, things it works… Kind of.</p>

	</section>
	<section class="sectioning">
		<h2 class="contextual-heading">The mistakes we made along the way…</h2>

		<p>On the surface, all of those protocols that turn up in the HTTP Archive data seem like success stories. However, I’d like to tell you why they haven’t been so great, and why we already have better solutions.</p>

		<p>Consider the second most widely used of those, the <code>tel:</code> protocol.  Not because this one is especially bad, but because it is very easy to illustrate many problems in a concise example.</p>

		<p>Before <code>tel:</code>, authors would put some text in their web page, like:</p>

		<p><code>Phone: (555)123-4567</code></p>

		<p>With <code>tel:</code>, authors could now put something like this into their HTML:</p>

		<pre><code class="html hljs"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"tel:123.456.7890"</span>&gt;</span>Call now<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
	</code></pre>

		<p>Yay!  Except, no… wait… That is kind of terrible.</p>

		<p>Sure, for <em>some</em> users, where all of the stars align, that will be a nice convenience.  But there are just <em>way</em> too many cases where this is more of a barrier than a convenience. Let’s look at some of the failure modes of that line of code, starting with the simplest:</p>

		<section class="sectioning">
			<h3 class="contextual-heading">Hidden information</h3>

			<p>Because we’ve made it a link, it’s far too common that authors don’t actually display the phone number.  They <em>assume</em> that the device I’m <em>looking at</em> is the device I want to dial from.  There are many cases where that is not true!</p>

			<p>Perhaps I’m on my office desktop and I want to dial with the handy office <em>phone</em> that is next to me, or the conference system, or even just my cell phone.  Maybe I want to read the number out to someone else, or write it down for later.  Just show me the !@$!@ number!</p>

			<p>This isn’t a problem inherent to the protocol, but it’s still a problem.</p>
		</section>
		<section class="sectioning">
			<h3 class="contextual-heading">Theoretically capable, practically incapable</h3>

			<p>Sometimes a device can be physically capable of dialing out, but currently not have that service available. This happened to me while traveling abroad in 2018, where I was able to use my cell with WiFi but couldn’t dial out (I didn’t have WiFi calling at the time).</p>

			<p>This problem still comes up I use that same 2018 cell phone to control my media in my house, and occasionally to look something up, but since it isn’t on my cell plan, I can’t use any <code>tel:</code> links.</p>
		</section>
		<section class="sectioning">
			<h3 class="contextual-heading">No registered handler at all</h3>

			<p>On some machines, there is no registered <code>tel:</code> protocol handler.  What happens in this case? Unspecified.  Each OS will do something a little different.  For years <a href="https://stackoverflow.com/questions/1164004/how-to-mark-up-phone-numbers" target="_blank" rel="noopener"><code>tel:</code> would often do nothing at all</a> <em>which is very confusing to users</em>.  Some operating systems will, to various degrees, offer to help you find something capable of handling the protocol, but even that can be confusing (see next point).</p>
		</section>
		<section class="sectioning">
			<h3 class="contextual-heading">Registered a Complex Program</h3>

			<p>Some devices will launch a program that’s registered to handle the <code>tel:</code> protocol, <em>even if it can’t currently dial</em>.  There are many examples of this.  Apps like Google Hangouts or Skype were chat programs with some VoIP support. They could dial out if users paid a special recurring fee – but <em>most</em> users didn’t pay that fee.  When those users clicked a link and it launched their chat program, or told them they have to pay to dial, that’s confusing and frustrating.</p>

			<p>In fact, lots of users of those apps just use them for text chat.  Not so long ago, many users on office desktops didn’t have cameras, mics or speakers. If users clicked a <code>tel:</code> link and it launched their <em>chat</em> program and implied that they could pay money to dial out, but actually couldn’t do that: <em>This is very confusing to users</em>.</p>
		</section>
	</section>
	<section class="sectioning">
		<h2 class="contextual-heading">The Un-Protocol…</h2>
		<p>Contrast that with this:  Today, if you use your smartphone and you select some text - regular text - there are some built in ways to assist in order to do smart selection.  That is, work has gone into making it easier for it to recognize that you’re trying to select a phone number or an email, as two examples. And if you select it, the context menu will offer “Call” or “Email”, respectively.</p>

		<p>You know what’s wild? No author had to do anything special at all, and it works even on content written in the 90s.  That’s… Pretty great. That’s not to say markup couldn’t <em>help</em> here, but it gets at whether it needs to  <em>fundamentally</em> be a link.</p>

		<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Share_API" target="_blank" rel="noopener">Web Share API</a> splits things along a similar joint.  It just shares an <em>intent</em> to share some content.  It doesn’t need to know anything about which ways you have to available to share, or reason about things in the current time.  Splitting things this way lets all of the ways to share develop entirely independently.  If new social media comes along, or goes away, or we develop new physical ways of sharing involving USB or Bluetooth or HandWaveyMagicWand - it will all JustWork™.</p>

		<p>Both of these seem to me generally better than many of the protocol based solutions.  I’m not suggesting protocol based solutions are useless, I’m just suggesting that it seems like there is benefit in continuing to question why and how we’re approaching things.</p>
	</section>
</article></main>
 
   
  <script>
    //import { MediaAffordancesElement } from "./MediaAffordancesElement.js";
    class MediaAffordancesElement extends HTMLElement {
      constructor() {
        super();
        // todo: this should be a private field
        this.__matching = new Set()
        this.mqls = [];
        this.observers = [];

        this.supportedAffordances = new Set();
      }

      observeAffordanceChange(cb) {
        this.observers.push(cb);
      }

      notifyChange() {
        let intersection = new Set();
        for (let elem of this.__matching) {
          if (this.supportedAffordances.has(elem)) {
            intersection.add(elem);
          }
        }

        if (this.__matching.size > 0) {
          this.setAttribute("mq-matched", [...this.__matching].join(" "));
        } else {
          this.removeAttribute("mq-matched");
        }
        let arr =  [...intersection]
        let affordance = arr[arr.length - 1];
        if (affordance) {
          this.setAttribute("affordance", affordance);
        } else {
          this.removeAttribute("affordance");
        }
        this.observers.forEach(cb => {
          cb(intersection, this.__matching);
        });
      }

      static get observedAttributes() {
        return ["mq-affordances"];
      }

      connectedCallback() {
        let newValue = getComputedStyle(this).getPropertyValue(
          "--const-mq-affordances"
        );
        this.connectListeners(newValue);
      }

      connectListeners(newValue = "") {
        if (newValue.trim().length === 0) {
          return;
        }
        
        newValue.split("|").forEach(segment => {
          let mq = segment.trim().match(/\[([^\]]*)/)[1];
          let names = segment
            .replace(`[${mq}]`, "")
            .trim()
            .split(" ");
          let mql = window.matchMedia(mq);
          let mqh = evt => {
            names.forEach(name => {
              this.__matching[mql.matches ? "add" : "delete"](name);
            });

            this.notifyChange();
          };
          mqh();
          mql.addEventListener("change", mqh);
          this.mqls.push(mql);
        }, this);
      }

      attributeChangedCallback(name, oldValue, newValue) {
        this.connectListeners(newValue);
      }
    }

    //-----------------------------------------------------

    (function() {
      let lastUId = 0;
      let nextUId = () => {
        return `cp${++lastUId}`;
      };

      let getLabels = regionset => {
        return [...regionset.children].filter(el => /^H\d$/.test(el.tagName));
      };

      let getContentEls = regionset => {
        return [...regionset.children].filter(el => !/^H\d$/.test(el.tagName));
      };

      let ensureId = el => {
        el.id = el.id || nextUId();
        return el.id;
      };

      let getDisclosureButton = label => {
        return label.shadowRoot.querySelector("button");
      };

     
      let style = document.createElement('style')
      style.innerHTML = `
          
        :where(spicy-sections > [affordance*="collapse"])::before { 
          content: ' ';
          display: inline-block;
          width: 0.5em;
          height: 0.75em;
          margin: 0 0.4em 0 0;
          transform: rotate(90deg);
          background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='10px' height='10px' viewBox='0 0 270 240' enable-background='new 0 0 270 240' xml:space='preserve'%3e%3cpolygon fill='black' points='5,235 135,10 265,235 '/%3e%3c/svg%3e ");
          background-size: 100% 100%;
        } 

        :where(spicy-sections > [affordance*="collapse"][aria-expanded="true"])::before, 
        :where(spicy-sections > [affordance*="collapse"][aria-expanded="true"])::after {
          transform: rotate(180deg);
        }
      `
      document.head.prepend(style)
      
      const template = `
            <style>
              :root {
                font-size: 1rem;
              }

              :host([hidden]),
              ::slotted([hidden]) {
                display: none;
              }
              
              ::slotted(h1),
              ::slotted(h2),
              ::slotted(h3),
              ::slotted(h4),
              ::slotted(h5),
              ::slotted(h6) {
                 margin-right: 1rem;
              }
              
              tab-bar ::slotted([tabindex="0"]) {
                border-bottom: 1px solid blue;
              }
              
              tab-list { 
                display: flex; 
                overflow: hidden;
                white-space: nowrap;
              }
            </style>
            <tab-bar part="tab-bar">
              <!-- The region/tablist should have a  label -->
              <tab-list part="tab-list" role="tablist"
              ><slot name="tabListSlot"></slot></tab-list>
            </tab-bar>
            <content part="content-panels">
              <slot default></slot>
            </content>
        `;

      class RegionSet extends MediaAffordancesElement {
        __defaults;
        __tabListEl;

        // tabs and exclusive collapses should have the same affordance object?
        __affordanceConf = {
          collapse: {
            // can take a condition to force, check-like
            toggle: (label, condition) => {
              let state =
                typeof condition === "boolean"
                  ? condition
                  : !label.affordanceState.expanded;
              let contentEl = label.nextElementSibling;
              label.affordanceState.expanded = state;
              label.affordanceState.nonExclusiveExpanded = state;
              label.setAttribute("aria-expanded", state);
              if (state) {
                label.setAttribute("expanded", "");
                contentEl.style.display = "block";
              } else {
                label.removeAttribute("expanded");
                contentEl.style.display = "none";
              }
            }
          },
          "exclusive-collapse": {
            // ignores condition, radio-like
            toggle: label => {
              let labels = getLabels(label.parentElement);
              let siblings = labels.filter(c => c !== label);
              let index = labels.findIndex(c => c === label);

              siblings.forEach((sibLabel, i) => {
                let relatedContent = sibLabel.nextElementSibling;
                sibLabel.tabIndex = -1;
                relatedContent.style.display = "none";
                label.setAttribute("aria-expanded", "false");
                sibLabel.affordanceState.exclusiveExpanded = false;
              });
              label.tabIndex = 0;
              //nope - todo, fix/remove this?
              label.parentElement.affordanceState.exclusiveSelection.index = index;
              label.nextElementSibling.style.display = "block";
              label.setAttribute("aria-expanded", "true");
              label.affordanceState.exclusiveExpanded = true;
              label.focus();
            }
          },
          "tab-bar": {
            // ignores condition, radio-like
            toggle: label => {
              let labels = getLabels(label.parentElement);
              let siblings = labels.filter(c => c !== label);
              let index = labels.findIndex(c => c === label);

              siblings.forEach((sibLabel, i) => {
                let relatedContent = sibLabel.nextElementSibling;
                sibLabel.tabIndex = -1;
                relatedContent.style.display = "none";
                sibLabel.setAttribute("aria-expanded", "false");
                sibLabel.affordanceState.exclusiveExpanded = false;
              });
              label.tabIndex = 0;
              label.parentElement.affordanceState.exclusiveSelection.index = index;
              label.nextElementSibling.style.display = "block";
              label.setAttribute("aria-expanded", "true");
              label.affordanceState.exclusiveExpanded = true;
              label.focus();
            }
          }
        };
        __setSize = (labelEls, contentEls) => {
          this.__size = Math.min(labelEls.length, contentEls.length);

          if (labelEls.length !== this.__size) {
            console.warn("mismatch in tab-set label/content pairs...");
          }

          labelEls.forEach((labelEl, i) => {
            let contentEl = contentEls[i];
            if (!labelEl.initialized) {
              labelEl.initialized = true; // todo: this used to be shadow, do i need it?
              let defs = this.__defaults.defaultActive;

              // this assumes it is about collapses
              labelEl.affordanceState = {
                expanded: defs.includes(labelEl),
                active: false,
                // activate in the current mode
                activate: () => {
                  if (this.affordanceState.current) {
                    this.__affordanceConf[this.affordanceState.current].toggle(
                      labelEl
                    );
                  }
                }
              };

              let defaultExclusive =
                defs.length === 0 ? labelEls[0] : defs[defs.length - 1];

              this.affordanceState.exclusiveSelection.index = labelEls.indexOf(
                defaultExclusive
              );
            }
            labelEl.setMode = mode => {
              if (mode === "non-exclusive") {
                let isExpanded = labelEl.affordanceState.expanded;
                labelEl.setAttribute("affordance", "collapse");
                labelEl.setAttribute("tabindex", "0");
                labelEl.setAttribute("aria-controls", contentEl.id);
                labelEl.setAttribute("role", "button");
                labelEl.setAttribute("aria-expanded", isExpanded);
                labelEl.nextElementSibling.style.display = isExpanded
                  ? "block"
                  : "none";
              } else if (mode === "exclusive") {
                let isExpanded =
                  labelEls.indexOf(labelEl) ===
                  this.affordanceState.exclusiveSelection.index;
                labelEl.setAttribute("affordance", "collapse");
                labelEl.setAttribute("tabindex", isExpanded ? 0 : -1);
                labelEl.setAttribute("role", "button");
                labelEl.setAttribute("aria-expanded", isExpanded);
                labelEl.setAttribute("aria-controls", contentEl.id);
                labelEl.nextElementSibling.style.display = isExpanded
                  ? "block"
                  : "none";
              } else {
                labelEl.removeAttribute("tabIndex");
                labelEl.removeAttribute("affordance");
                labelEl.removeAttribute("aria-expanded");
                labelEl.removeAttribute("role");
              }
            };
          });
        };

        __projectTabBar = () => {
          this.__removeProjections();
          getLabels(this).forEach((tabSource, i) => {
            let selected = false,
              tabIndex = -1,
              display = "none";

            tabSource.setMode();
            tabSource.slot = "tabListSlot";
            tabSource.setAttribute("role", "tab");
            let tabId = ensureId(tabSource);
            let contentSource = tabSource.nextElementSibling;
            contentSource.tabIndex = 0;
            tabSource.setAttribute("aria-controls", ensureId(contentSource));
            contentSource.setAttribute("role", "tabpanel");
            contentSource.setAttribute("aria-labelledby", tabSource.id);
            if (i === this.affordanceState.exclusiveSelection.index) {
              tabIndex = 0;
              selected = true;
              display = "block";
            }
            tabSource.setAttribute("aria-selected", selected);
            tabSource.tabIndex = tabIndex;
            contentSource.style.display = display;

            // TODO: aria-orientation :(
          });
        };

        __projectCollapses = exclusive => {
          // TODO - remove projections and... ??
          this.__removeProjections();
          getLabels(this).forEach(label => {
            label.setMode(exclusive ? "exclusive" : "non-exclusive");
          });
        };

        __removeProjections = () => {
          [...this.children].forEach(child => {
            child.removeAttribute("slot");
            child.removeAttribute("affordance")
            child.removeAttribute("role");
            child.removeAttribute("aria-selected");
            child.removeAttribute("aria-controls");
            child.removeAttribute("tabindex");
            child.removeAttribute("aria-expanded")
            child.style.display = "block";
          });
        };

        // matching pairs
        __size = 0;

        __configure = () => {
          ///hmmm

          this.__setSize(getLabels(this), getContentEls(this));

          if (this.affordanceState.current === "tab-bar") {
            this.affordanceState.currentMode = "exclusive";
            this.__projectTabBar();
          } else if (this.affordanceState.current === "collapse") {
            this.affordanceState.currentMode = "non-exclusive";
            this.__projectCollapses();
          } else if (this.affordanceState.current === "exclusive-collapse") {
            this.affordanceState.currentMode = "exclusive";
            this.__projectCollapses(true);
          } else {
            this.affordanceState.currentMode = undefined;
            this.__removeProjections();
          }

          let specifiedIndex = this.activeTabIndex || 0;
          // TODO: hmm, these are DOM changes, we could cache them
          let labelEls = getLabels(this);
          let contentEls = getContentEls(this);

          for (let i = 0; i < this.__size; i++) {
            let label = labelEls[i];
            // probably add one handler that decides
            if (!label._inited) {
              label.addEventListener("click", evt => {
                evt.target.affordanceState.activate();
              });
              label._inited = true;
            }
          }
        };
        
        __childListObserver = new MutationObserver(mutationList => {
          // we have to wire up new elements
          let labelEls = getLabels(this);
          let contentEls = getContentEls(this);

          // what if there is a mismatch?
          this.__setSize(labelEls, contentEls);
          this.__configure();
        });

        __tabset;

        affordanceState = {
          exclusiveSelection: { index: undefined },
          current: undefined,
          currentMode: undefined,
          getLabels: () => {
            return getLabels(this);
          }
        };

        /*
          Wires up suppored affordances...
        */
        constructor() {
          super();
          this.supportedAffordances.add("tab-bar");
          this.supportedAffordances.add("collapse");
          this.supportedAffordances.add("exclusive-collapse");

          this.observeAffordanceChange((matching, all) => {
            if (!this.__defaults) {
              this.__defaults = {
                onMatch: this.hasAttribute("defaults-on-match"),
                defaultActive: getLabels(this).filter(l =>
                  l.hasAttribute("default-activate")
                )
              };
            }
            this.affordanceState.current = this.getAttribute("affordance");
            this.__configure();
          });

          this.attachShadow({ mode: "open" });
          this.shadowRoot.innerHTML = template;
     
          this.__tabListEl = this.shadowRoot.querySelector("tab-list");
          this.addEventListener(
            "keydown",
            evt => {
              let labels = getLabels(this);
              let size = labels.length;
              let cur = this.affordanceState.exclusiveSelection.index;
              let prev = cur === 0 ? size - 1 : cur - 1;
              let next = cur === size - 1 ? 0 : cur + 1;

              if (
                this.affordanceState.current === "tab-bar" ||
                this.affordanceState.current === "exclusive-collapse"
              ) { 
                if (evt.keyCode == 37 || evt.keyCode == 38) {
                  labels[prev].affordanceState.activate();
                } else if (evt.keyCode == 39 || evt.keyCode == 40) {
                  labels[next].affordanceState.activate();
                }
              } else if (evt.keyCode == 32 && this.affordanceState.current === 'collapse') {
                evt.preventDefault()
              }
            },
            false
          );
          this.addEventListener(
            "keyup", 
            evt => {
              if (evt.keyCode == 32 && this.affordanceState.current === 'collapse') {
                evt.target.closest('[affordance]').affordanceState.activate()
                evt.preventDefault()
              }
            })
        }

        connectedCallback() {
          super.connectedCallback();

          //TODO: check whether there is a hash/handle selection
          
          // If you append a fragment with a pair, it should work
          this.__childListObserver.observe(this, { childList: true });
        }
      }
      customElements.define("spicy-sections", RegionSet);
    })();
    </script>
  <script>
    Array.prototype.slice.call(document.querySelectorAll('.optional [data-src]')).forEach(function (optional) {
      var prefs = window.localStorage.downloadsPrefs,
          clickToSee;
      if (prefs === 'true') {
        activateOptional(optional);
      } else {
        clickToSee = document.createElement('div');
        clickToSee.classList.add('clickToSee')
        clickToSee.innerHTML = '<button>Click to see media</button>';
        clickToSee.style.textAlign = 'center';
        clickToSee.style.border = 'none';
        optional.parentElement.insertBefore(clickToSee, optional.nextSibling);
        clickToSee.firstElementChild.addEventListener('click', function () {
          activateOptional(optional);
        })
      }

    })
  </script>

</body></html>