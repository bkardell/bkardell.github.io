<html lang="en" resource-type="blogpost"><head>  
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="view-transition" content="same-origin"> 

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@briankardell">
    <meta name="twitter:creator" content="@briankardell">
    <meta name="twitter:title" content="The Secret Life of Custom Elements">
    <meta name="twitter:description" content="Twenty years ago last month, Google published an analysis of &quot;slightly over a billion documents,&quot; a snapshot of the web that helped shape the early direction of HTML5. It followed ">
    
    <!-- meta name="monetization" content="$ilp.uphold.com/kKU4GXiRwhnf " -->
     
    <link rel="alternate" type="application/rss+xml" href="https://bkardell.com/blog/feed.rss" title="bkardell.com/blog rss feed">
    <title>The Secret Life of Custom Elements</title> 
    <style>/*!
 * Web Fonts from Fontspring.com
 *
 * All OpenType features and all extended glyphs have been removed.
 * Fully installable fonts can be purchased at https://www.fontspring.com
 *
 * The fonts included in this stylesheet are subject to the End User License you purchased
 * from Fontspring. The fonts are protected under domestic and international trademark and 
 * copyright law. You are prohibited from modifying, reverse engineering, duplicating, or
 * distributing this font software.
 *
 * (c) 2010-2023 Fontspring
 *
 *
 *
 *
 * The fonts included are copyrighted by the vendor listed below.
 *
 * Vendor:      Horizon Type
 * License URL: https://www.fontspring.com/licenses/horizon-type/webfont
 *
 *
 */

@font-face {
    font-family: 'acherus_militant_1_-_light.otf';
    src: url('/acherus_militant_1_-_light.otf-webfont.woff2') format('woff2'),
         url('/acherus_militant_1_-_light.otf-webfont.woff') format('woff');
    font-weight: normal;
    font-style: normal;

}


.captioned-image {
    background-color: #eaeaea;
    display: block;
    overflow: hidden;
    padding: 1rem;
    text-align: center;
    font-style: italic;
}

.captioned-image.p-attached {
    width: 40%;
    display: inline-block;
    margin: 0 1rem 2rem 1rem;
}

section > .captioned-image.p-attached {
    margin-top: 1.5rem; /* correct for heading size*/
}

 pre { overflow-x: auto }

.captioned-image.p-attached.p-attached-left {
    float: left;
}

.captioned-image.p-attached.p-attached-right {
    float: right;
}

.captioned-image.p-attached + * + * {
    clear: both;
    margin-top: 2rem;
}


.captioned-image img, .captioned-image video {
    display: block;
    max-width: 100%;
    
    margin: 0 auto 1em auto;
}
.source {
    font-style: italic;
}
body {
    display: grid;
    grid-template-columns: 25rem auto;
    font-size: 1.1rem;
    font-family: 'acherus_militant_1_-_light.otf';
    font-weight: 400;
    font-size: 1.25rem;
    line-height: 1.625;
    margin: 0;
    background-color: rgb(249, 246, 246);
}
h1 { margin: 0.5rem; }
code-format {
    border-left: 0.5rem solid rgba(123,115,209,0.35);
    display: block;
    padding: 0.5rem;
    margin-bottom: 1rem;
}

contextual-heading {
    display: block;
    margin-top: 2rem;
}

h1, [aria-level="1"] {
    color: black;
    font-size: 1.45rem;
}

h2, [aria-level="2"] {
    color: black;
    font-size: 1.35rem;
}

h3, [aria-level="3"] {
    color: black;
    font-size: 1.25rem;
}

h4, [aria-level="4"] {
    color: black;
    font-size: 1.2rem;
}

h5, h6, [aria-level="5"], [aria-level="6"] {
    color: black;
    font-size: 1.2rem;
    font-weight: bolder;
}


.posted-on {
    font-style: italic;
    font-size: 0.8rem; 
    text-align: right;
    margin-bottom: 1rem;
}

ul, li {
    margin: 0.5rem;
    text-align: left;
}

.authorinfo {
    height: 100%;
    padding-top: 1rem;
    padding-right: 0;
    background-color: #fbf5e9; 
    display: block;
    background-image: linear-gradient(to right, #c7cccc, #dde0e8 );
    border-right-width: 1px;
    border-right-style: dotted;
}

.tagline {
    font-style: italic;
    text-align: center;
}
 
[tag-esc] {
    color: maroon;
    font-family: Courier, "Lucida Console", monospace;
}

[tag-esc]::before {
    content: '<';
}

[tag-esc]::after {
    content: '>';
}

main {
    min-width: 50%;
    width: 80%;
    padding: 1rem;
}
header .title {
    background-color: rgba(123,115,209,0.35);
    padding: 0.3rem;
    padding-left: 0.25rem;
    font-weight: bolder;
    font-size: 1rem;
    border-left: 1rem solid #999298;
}

header .profile {
    width: 50%;
    margin: 1rem 25%;
}

header .title + nav {
    font-size: 0.9rem;
}

header .blurb {
    font-size: 0.9rem;
    text-align: center;
}
header .name {
    text-align: center;
    font-size: xx-large;
}
.segue {
    font-style: italic;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
}

#aboutMeToggle {
    display: none;
}


:where(pre:has(code[class*="language"])) {
    display: block;
    background-color: black; 
    padding: 0.5rem;
}

code[class*="language"] {
    min-width: fit-content;
}

spicy-sections:not([affordance]) > h2 {
  clip: rect(0 0 0 0);
  clip-path: inset(50%);
  height: 1px;
  overflow: hidden;
  position: absolute;
  white-space: nowrap;
  width: 1px;
}

main article { max-width: 100em; margin: auto; }
/* this needs rethinking, it wants a selector like 'not flow content' */
article>*:not(contextual-heading,a), section>*:not(contextual-heading,a) {
    margin-left: 0.45rem;
}

blockquote {
  font-family: serif;
  background: #f9f9f9;
  border-left: 10px solid #ccc;
  margin: 1.5em 10px;
  padding: 0.5em 10px;
}
blockquote:before {
  color: #ccc;
  content: open-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-right: 0.25em;
  vertical-align: -0.4em;
}

blockquote:after {
  color: #ccc;
  content: close-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-left: 0.25em;
  vertical-align: -0.4em;
}
 

@media (max-width: 800px){
    body {
        grid-template-columns: 1fr;
    }
    .authorinfo {
        height: auto;
        border-bottom: 1px solid #afafff;
        padding-top:  0;
    } 

    main { width: 95%; margin: 0 auto;}

    .captioned-image.p-attached {
        width: 100%;
        margin: 1rem 0;
    }

    .captioned-image.p-attached.p-attached-left,
    .captioned-image.p-attached.p-attached-right {
        float: none;
    }

    #aboutMeToggle {
        display: block;
        background-color: #675e5e;
        color: white;
        padding: 0.25rem;
        padding-left: 0.5rem;
        border-left: 1rem solid black;
    }

    header li { display: inline; margin-left: -0.5em; }
    header .blurb li::after { content: '; '; }
    header  nav li {
        display: inline-block;
        margin-left: 0.35rem;
        margin-right: 0.35rem;
    }
    header .title {
        width: 100%;
    }
    main li .source { display: block; }

} 

spicy-sections {
    --const-mq-affordances:
      [screen and (min-width: 600px) ] collapse |
      [screen and (min-width: 801px) ] tab-bar
    ;
    display: block;
}

spicy-sections.authorinfo {
    --const-mq-affordances:
      [screen and (max-width: 801px) ] collapse
    ;
}


spicy-sections.single {
    --const-mq-affordances:
      [screen ] collapse 
;
}

[role="tab"] {
    margin-right:  1.5rem;
}

.note {
    background-color: rgba(255,255,0,0.24);
    padding: 1rem;
    font-style: italic;
}
.note::before {
    content: 'Note';
    font-size: 0.8rem;
    background-color: black;
    color: white;
    padding: 0.25rem;
    margin-right: 0.5rem;
}

</style>
    <style> 
      .captioned-image { font-size: 0.9rem; }
      .thanksTo { font-style: italic; font-size: 0.8rem; }
    </style>
    <script>
      var activateOptional = function (media) {
        var source = media.getAttribute('data-src'),
            temp,
            container = media.parentElement;

          if (media.nextSibling && media.nextSibling.matches) {
            if (media.nextSibling.matches('.clickToSee')) {
              media.parentElement.removeChild(media.nextSibling);
            }
          }
 
          if (media.tagName === 'VIDEO') {
            temp = document.createElement('video')
            temp.setAttribute('autoplay','')
            temp.setAttribute('controls','')
            temp.setAttribute('loop','')
            temp.innerHTML = '<source src="' + source + '.webm" type="video/webm">'
                    + '<source src="' + source + '.mp4" type="video/mp4">';
            media.parentElement.replaceChild(temp, media);
            setTimeout(function () {
              temp.play()
            }, 0);
          } else {
            media.src = media.getAttribute('data-src');
          }

          container.classList.add('active');
      }
    </script>
  </head>
  <body>
    <spicy-sections class="authorinfo">
<h2 id="aboutMeToggle" defaults-on-match="">Author Information</h2>
  
<header>
    <div class="name">
        Brian Kardell
    </div>
    <img class="profile" src="/profile.jpg" alt="">
    <div class="tagline"><a href="/">Betterifying the Web</a></div>
    <div class="blurb">
        <ul>
            <li>Developer Advocate at Igalia</li>
            <li>Original Co-author/Co-signer of The Extensible Web Manifesto</li>
            <li>Co-Founder/Chair, W3C Extensible Web CG</li>
            <li>Member, W3C (OpenJS Foundation)</li>
            <li>Co-author of HitchJS</li>
            <li>Blogger</li>
            <li>Art, Science &amp; History Lover</li>
            <li>Standards Geek</li>
        </ul>
    </div>
    <div class="title">Follow Me On...</div>
    <nav>
        <ul>
            <li><a rel="me" href="https://briankardell.wordpress.com">Wordpress</a></li>
            <li><a rel="me" href="https://medium.com/@briankardell">Medium</a></li>
            <li><a rel="me" href="https://twitter.com/briankardell">Twitter</a></li>
            <li><a rel="me" href="https://github.com/bkardell/">Github</a></li>
            <li><a rel="me" href="https://toot.cafe/@bkardell">Mastodon</a></li>
            <li><a rel="me" href="https://bsky.app/profile/bkardell.com">Bluesky</a></li>
            <li><a rel="me" href="https://codepen.io/bkardell">Codepen</a></li>
            <li><a rel="me" href="https://www.linkedin.com/in/brian-kardell-08a4264">LinkedIn</a></li>
            <li><a rel="me" href="https://www.instagram.com/kardellbrian">Instagram (for
art)</a></li>
            <li><a rel="me" href="http://fineartamerica.com/profiles/brian-kardell?">Fine Art
America (art for sale)</a></li>
        </ul>
    </nav>
</header> 
</spicy-sections>
<script>
  /*
    You're probably wondering "Do I need to write this?""
    "Is this part of it?"  No... If you're interested tho - 
    Custom elements have a FOUC/PE gap 
    (see https://github.com/whatwg/html/issues/6231).
    This is a slightly better experience: It 
    will be hidden _if JS is enabled_, and 
    will be shown as it is defined, 
    or after 1 sec, whichever is first.
  */
  let ss = document.createElement("style");

  ss.innerHTML = `html:not(.lldelay) :not(:defined) { visibility: hidden; }`;
  document.head.appendChild(ss);

  setTimeout(() => {
    document.documentElement.classList.add("lldelay");
  }, 1000);
</script>
    <main><div class="posted-on">Posted on null</div><article class="sectioning">
	<h1 class="contextual-heading">The Secret Life of Custom Elements</h1>
<style>
	h4.contextual-heading {
    border-left: 1rem solid #398486;
    padding-left: 0.5rem;
}
	h3.contextual-heading {
    background-color: #e8ebee;
}
</style>
<p class="segue">Twenty years ago last month, Google published <a href="https://web.archive.org/web/20060203035414/http://code.google.com/webstats/index.html">an analysis of "slightly over a billion documents,"</a> a snapshot of the web that helped shape the early direction of HTML5. It followed a lineage of smaller, more personal studies — individuals poking at the web to answer some narrow question, often with datasets that would easily fit on a thumb drive today. For about half those two decades, I’ve been arguing that we need <strong>more</strong> study of the web, not less. The platform evolves faster than our understanding of it, and the only way to know what the web actually is — not what we imagine it to be — is to look.</p>
<p>Every month the <a href="https://en.wikipedia.org/wiki/Internet_Archive">HTTP Archive</a> quietly captures a snapshot of the web as it actually exists—not the idealized web that we hope for, but the messy, improvised, duct‑taped reality of millions of sites in the wild.  I’ve been collecting and studying these elements for the last six years. </p>
<p>This new dataset is the largest I’ve ever worked with: Billions of pages, hundreds of thousands of distinct non-standard element names, and a long tail that stretches into places no standards body has ever seriously examined. And unlike the Google study, which looked for patterns in class names, this dataset captures the long tail of non‑standard elements — the names people invent for actual elements when the platform doesn’t give them what they need.</p>
<p>What emerges is a portrait of the web as it is lived: messy, inventive, repetitive, global, and full of reinvention. It’s also a mirror held up to the platform itself.</p>
<p>But, it's also much more complex to study than I could have imagined a decade ago, and I really wish that the W3C (and member orgs which include academia) had taken up the charge to begin to figure out how to really study the web and use that information to inform standards work.</p>
<section class="sectioning">
<h2 class="contextual-heading">What's difficult about it...</h2>
<p>One problem is that the dataset itself has some fairly extreme bias.  The crawl doesn't hit anything that isn't on the public internet - that means it excludes intranets which are <em>massive</em>.  In fact, most of my career was spent working on intranets.  The crawl captures only home pages, plus the target of whatever it interprets as the largest link on that page.  It also can't get to anything that requires login - which means that for a site like twitter or bluesky or mastodon, you're going to get something very unrepresentative of any of those.  So, one challenge I'd love to see us trying to tackle is how to get even better data representation.  It's hard to "pave cowpaths" if they're in a country we can't even see into.</p>
<p>Initially I had this idea that we could watch for the adoption of tags - imagining that we'd get some that would become <em>very</em> popular, just like we did with JavaScript libraries and frameworks.  However, it turns out that this is not the signal it might first appear to be.  An element appearing in tens of thousands or even hundreds of thousands of pages is often simply because they are part of a larger successful system.  If Wix or Shopify create some custom elements that work behind the WYSIWYG tooling, and lots of people use it to create their pages - then suddenly that element gets very very popular - even if it isn't actually particularly good.  In fact, we can see shifts in the data where the teams themselves changed their minds and another version supplants the first very quickly because it's simply internal.</p>
<p>Then, I thought that perhaps what we can do with the dataset instead, is to squint at it and look a little more abstractly at what people are naming their elements and see if people are re-solving similar problems.  Do we find, for example, multiple non-standard element names that appear to be about tabs?  Yes! Clearly that is indicative that we need a native element, right?  <em>Maybe</em>.  It's a bit more nuanced than that.  Here are the most commonly re-created/repeated non-standard element themes:</p>
<ul>
<li>Navigation  </li>
<li>Headers and footers  </li>
<li>Carousels and sliders</li>
<li>Modals  </li>
<li>Search bars  </li>
<li>Product cards  </li>
<li>Login forms  </li>
<li>Cookie banners  </li>
<li>Accordions  </li>
<li>Tabs   </li>
<li>Toasts  </li>
<li>Breadcrumbs</li>
</ul>
<p>While we don't have several of these in standard HTML, we <em>do</em> have native <code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;dialog&gt;</code>, and <code>&lt;search&gt;</code> elements, and even accordions via the <code>name</code> attribute of <code>&lt;details&gt;</code>.  And yet, the wild still contains hundreds or thousands of custom elements with names like <code>&lt;app-header&gt;</code>, <code>&lt;site-footer&gt;</code>, <code>&lt;main-nav&gt;</code>, <code>&lt;modal-dialog&gt;</code>, <code>&lt;search-box&gt;</code>, and <code>&lt;accordion-panel&gt;</code>.</p>
<p>Native primitives may exist, but not at the same level of abstraction as these.  <code>&lt;header&gt;</code> and <code>&lt;footer&gt;</code> in HTML are structural, not behavioral.  <code>&lt;dialog&gt;</code> is behavioral, but not styled.  <code>&lt;search&gt;</code> exists, but doesn’t solve autocomplete, filtering, or results.</p>
<p>So developers build those - and, if you stop and think about it, not all non-standard elements are equally as undesirable.  Many of them will be simple decorations or thin wrappers that <em>do</em> use their native counterparts.  Where there is definitely some interesting thing to study is where there is clear generic need where the platform doesn't provide anything close.  Above, tabs, for example.</p>
</section>
<section class="sectioning">
	<h2 class="contextual-heading">Observations..</h2>
<p>Here are many observations from the data, in no real particular order of importance.</p>
	<section class="sectioning">
		<h3 class="contextual-heading">Forms and Inputs: Tweaked, Wrapped, and Re‑Wrapped</h3>
<p>Forms and inputs are a great example of the constant re-invention I just described.  Sometimes it's because the native element is insufficient, but that's not <em>necessarily</em> the case.  In some cases they're just slight wrappers.  Among them are lots and lots of "pickers" and "selecters" that show up...</p>
<ul>
<li><code>&lt;custom-select&gt;</code></li>
<li><code>&lt;date-picker&gt;</code></li>
<li><code>&lt;variant-picker&gt;</code></li>
<li><code>&lt;quantity-selector&gt;</code></li>
</ul>
<p>There is already a lot of ongoing work to make native form elements (including selects) require less code and just be more stylable and flexible, and the data at least suggests that such efforts will be very welcome.</p>
</section>
<section class="sectioning">
<h3 class="contextual-heading">Hidden Machinery</h3>
<p>A surprising number of elements aren’t UI components at all. They’re runtime markers:</p>
<ul>
<li><code>&lt;ng-container&gt;</code></li>
<li><code>&lt;router-outlet&gt;</code></li>
<li><code>&lt;astro-island&gt;</code></li>
<li><code>&lt;ion-router-outlet&gt;</code></li>
<li><code>&lt;next-route-announcer&gt;</code></li>
</ul>
<p>These exist because frameworks need declarative boundaries for hydration, routing, rendering or template expansion. I suppose it is debatable wither these are an indicator of “missing HTML features”, or just how much.  </p>
</section>
<section class="sectioning">

<h3 class="contextual-heading">Carousels (and sliders... and toasts)</h3>
<p>I don't love carousels, but it's hard to deny that they are popular.  There are <em>dozens</em> of distinct and identifiable carousel/slider elements in the dataset and they appear <em>a lot</em>.  I really dislike a few bits of Google's attempt to make CSS-only carousels possible, but it's pretty clear why they chose to tackle that problem. I guess it is worth stressing again the bias in the dataset here - if there is a page I most expect to see a carousel, it is exactly the primary one the archive crawls.  So, while it is the most popular in the dataset, I don't know that it is the most popular all-around. You can see why Google winds up with their proposals though, toasts are on that top list too.</p>
</section>

<section class="sectioning">
<h3 class="contextual-heading">Structural semantics?</h3>
<p>There are a few broad categories where the main point seems to be "semantics". That is, very often many of these don't actually <em>do</em> anything, beyond provide some hooks, mainly for styling.  They aren't actually even custom elements sometimes (or maybe even often) - just non-standard elements. </p>
<section class="sectioning">
<h4 class="contextual-heading">e-commerce</h4>
<p>Dozens of these surround e-commerce.  There are tens of thousands of sites that use elements with names (and variants).</p>
<details>
<summary>Product &amp; merchandising</summary>
<ul>
<li><code>&lt;product-card&gt;</code></li>
<li><code>&lt;product-title&gt;</code></li>
<li><code>&lt;product-price&gt;</code></li>
<li><code>&lt;product-rating&gt;</code></li>
<li><code>&lt;product-variant&gt;</code></li>
<li><code>&lt;product-gallery&gt;</code></li>
<li><code>&lt;product-description&gt;</code></li>
<li><code>&lt;product-badge&gt;</code></li>
</ul>
</details>
<details>
<summary>Pricing &amp; money</summary>
<ul>
<li><code>&lt;price-money&gt;</code></li>
<li><code>&lt;sale-price&gt;</code></li>
<li><code>&lt;compare-at-price&gt;</code></li>
<li><code>&lt;discount-amount&gt;</code></li>
<li><code>&lt;currency-display&gt;</code></li>
</ul>
</details>
<details>
<summary>Inventory &amp; availability</summary>
<ul>
<li><code>&lt;stock-status&gt;</code></li>
<li><code>&lt;pickup-availability&gt;</code></li>
<li><code>&lt;delivery-estimate&gt;</code></li>
<li><code>&lt;inventory-level&gt;</code></li>
</ul>
</details>

<details>
<summary>Cart &amp; checkout</summary>
<ul>
<li><code>&lt;cart-items&gt;</code></li>
<li><code>&lt;cart-count&gt;</code></li>
<li><code>&lt;checkout-button&gt;</code></li>
<li><code>&lt;order-summary&gt;</code></li>
</ul>
</details>

<p>Very interestingly they are often used alongside actual machine readable semantics via jsonLD in the same markup.  </p>
<p>While the vast majority of these elements appear because of common tooling, the fact that there are dozens of variants of similar names appearing on smaller numbers of sites indicates there is something widely interesting here. It's hard to say what it is other than that it would be nice to have a common structural semantic that would work for both purposes.</p>
<p>I guess the biggest surprise here is that if it's true, why hasn't such a thing arisen already? It is entirely within the community's power to develop such a thing.  Perhaps the answer is that there is just so much variance it isn't easily plausible.  Maybe templating would somehow allow us to achieve a common pattern which achieved this based on the shared jsonLD semantics.</p>
</section>
<section class="sectioning">
<h4 class="contextual-heading">Publishing &amp; Editorial Semantics</h4>
<p>CMSes and news sites often invent tags for editorial structure, and many of these are sticking around.</p>
<details>
<summary>Content structure</summary>
<ul>
<li><code>&lt;article-header&gt;</code></li>
<li><code>&lt;article-summary&gt;</code></li>
<li><code>&lt;article-author&gt;</code></li>
<li><code>&lt;article-date&gt;</code></li>
<li><code>&lt;article-tags&gt;</code></li>
<li><code>&lt;article-tag&gt;</code></li>
<li><code>&lt;article-category&gt;</code></li>
<li><code>&lt;byline&gt;</code></li>
<li><code>&lt;dateline&gt;</code></li>
<li><code>&lt;pullquote&gt;</code></li>
<li><code>&lt;footnote&gt;</code></li>
</ul>
</details>
<details>
<summary>Taxonomy</summary>
<ul>
<li><code>&lt;tag-list&gt;</code></li>
<li><code>&lt;category-label&gt;</code></li>
<li><code>&lt;topic-header&gt;</code></li>
</ul>
</details>
<p>These reflect the needs of journalism and long‑form content.</p>
</section>
<section class="sectioning">
	<h4 class="contextual-heading">Social &amp; Community Semantics</h4>
<p>These show up in comment systems, forums, and social platforms.</p>
	
<details>
	<summary>User‑generated content</summary>
<ul>
<li><code>&lt;comment&gt;</code></li>
<li><code>&lt;comment-list&gt;</code></li>
<li><code>&lt;comment-item&gt;</code></li>
<li><code>&lt;comment-author&gt;</code></li>
<li><code>&lt;comment-content&gt;</code></li>
<li><code>&lt;comment-date&gt;</code></li>
<li><code>&lt;comment-form&gt;</code></li>
</ul>
</details>

<details>
<summary>Identity</summary>
<ul>
<li><code>&lt;user-avatar&gt;</code></li>
<li><code>&lt;user-name&gt;</code></li>
<li><code>&lt;profile-card&gt;</code></li>
</ul>
<p>These encode relationships and interactions, not UI patterns.</p>
</details>

<details>
<summary>Events</summary>
<ul>
<li><code>&lt;event-date&gt;</code></li>
<li><code>&lt;event-location&gt;</code></li>
<li><code>&lt;event-schedule&gt;</code></li>
<li><code>&lt;event-details&gt;</code></li>
</ul>
<p>Again, these are domain objects, not widgets.</p>
</details>

<details>
<summary>Invoicing</summary>
<ul>
<li><code>&lt;invoice&gt;</code></li>
<li><code>&lt;invoice-line&gt;</code></li>
<li><code>&lt;invoice-total&gt;</code></li>
<li><code>&lt;invoice-summary&gt;</code></li>
</ul>
</details>

<p>Before the web came along, there were already national and international standards around electronically trading informtation like invoices - and when XML was sold, invoices were a common example.  Here we are again.</p>
</section>

</section>
<section class="sectioning">
	<h3 class="contextual-heading">Typos, Encoding Errors, and the Weird Stuff</h3>
<p>One of the most delightful parts of the dataset is the long tail of what are almost certainly just typos:</p>
<ul>
<li><code>&lt;prodcut-card&gt;</code></li>
<li><code>&lt;navgation&gt;</code></li>
<li><code>&lt;contianer&gt;</code></li>
</ul>
<p>The fact that these can appear on tens of thousands of sites because they are part of common tooling helps re-enforce that not every non-standard element is a signal. :)</p>
</section>
<section class="sectioning">
<h3 class="contextual-heading">In conclusion...</h3>
<p>I wish that I could say "Ah ha - the data says very clearly that <em>these</em> are the specific things we should definitely 'just write down' now" in the way that I imagined a decade ago, but I don't think we're there yet.  I guess if I had to give three things I'd like to see happen from here they'd be:</p>
<ol>
<li><p>We need lots more effort in thinking about how to study these things.  I would love to see real investment in this space.  This year, at last, the W3C is hiring someone to study the web.  I'm not yet sure what that looks like but I look forward to trying to discuss more with them.</p>
</li>
<li><p>We need a real community effort - an <a href="https://ul.org/about/our-history/">Underwriters Labs</a> for custom elements, with participation and funding from orgs with money.  We don't necessarily need "the one true tabs" as much as we need a place to find what I expect will be a very few sets of tabs as custom elements which we can trust like we trust native elements.  Given a little bit of time, I have faith that this will naturally sort itself into a few 'winners'.  </p>
</li>
<li><p>That community effort might also include things which won't ever have native implmentations, but which lay down some kind of light semantic meaning or compound styling structure that we all begin to agree on - like product cards or breadcrumbs.</p>
</li>
</ol>
<p>A lot of this is pretty adjacent/close to the ideas behind OpenUI and it's possible some of this could just happen there.  However, due mainly to limits and participation, OpenUI has really not really produced custom elements or worked to somehow list or grade and promote them (though we did study them quite a bit in the tabs research).  The effort led by Brad Frost to think about a "global design system" in particular might be closer to some of these ideas.</p>
</section>
</section>
</article></main>
 
   
  <script>
    //import { MediaAffordancesElement } from "./MediaAffordancesElement.js";
    class MediaAffordancesElement extends HTMLElement {
      constructor() {
        super();
        // todo: this should be a private field
        this.__matching = new Set()
        this.mqls = [];
        this.observers = [];

        this.supportedAffordances = new Set();
      }

      observeAffordanceChange(cb) {
        this.observers.push(cb);
      }

      notifyChange() {
        let intersection = new Set();
        for (let elem of this.__matching) {
          if (this.supportedAffordances.has(elem)) {
            intersection.add(elem);
          }
        }

        if (this.__matching.size > 0) {
          this.setAttribute("mq-matched", [...this.__matching].join(" "));
        } else {
          this.removeAttribute("mq-matched");
        }
        let arr =  [...intersection]
        let affordance = arr[arr.length - 1];
        if (affordance) {
          this.setAttribute("affordance", affordance);
        } else {
          this.removeAttribute("affordance");
        }
        this.observers.forEach(cb => {
          cb(intersection, this.__matching);
        });
      }

      static get observedAttributes() {
        return ["mq-affordances"];
      }

      connectedCallback() {
        let newValue = getComputedStyle(this).getPropertyValue(
          "--const-mq-affordances"
        );
        this.connectListeners(newValue);
      }

      connectListeners(newValue = "") {
        if (newValue.trim().length === 0) {
          return;
        }
        
        newValue.split("|").forEach(segment => {
          let mq = segment.trim().match(/\[([^\]]*)/)[1];
          let names = segment
            .replace(`[${mq}]`, "")
            .trim()
            .split(" ");
          let mql = window.matchMedia(mq);
          let mqh = evt => {
            names.forEach(name => {
              this.__matching[mql.matches ? "add" : "delete"](name);
            });

            this.notifyChange();
          };
          mqh();
          mql.addEventListener("change", mqh);
          this.mqls.push(mql);
        }, this);
      }

      attributeChangedCallback(name, oldValue, newValue) {
        this.connectListeners(newValue);
      }
    }

    //-----------------------------------------------------

    (function() {
      let lastUId = 0;
      let nextUId = () => {
        return `cp${++lastUId}`;
      };

      let getLabels = regionset => {
        return [...regionset.children].filter(el => /^H\d$/.test(el.tagName));
      };

      let getContentEls = regionset => {
        return [...regionset.children].filter(el => !/^H\d$/.test(el.tagName));
      };

      let ensureId = el => {
        el.id = el.id || nextUId();
        return el.id;
      };

      let getDisclosureButton = label => {
        return label.shadowRoot.querySelector("button");
      };

     
      let style = document.createElement('style')
      style.innerHTML = `
          
        :where(spicy-sections > [affordance*="collapse"])::before { 
          content: ' ';
          display: inline-block;
          width: 0.5em;
          height: 0.75em;
          margin: 0 0.4em 0 0;
          transform: rotate(90deg);
          background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='10px' height='10px' viewBox='0 0 270 240' enable-background='new 0 0 270 240' xml:space='preserve'%3e%3cpolygon fill='black' points='5,235 135,10 265,235 '/%3e%3c/svg%3e ");
          background-size: 100% 100%;
        } 

        :where(spicy-sections > [affordance*="collapse"][aria-expanded="true"])::before, 
        :where(spicy-sections > [affordance*="collapse"][aria-expanded="true"])::after {
          transform: rotate(180deg);
        }
      `
      document.head.prepend(style)
      
      const template = `
            <style>
              :root {
                font-size: 1rem;
              }

              :host([hidden]),
              ::slotted([hidden]) {
                display: none;
              }
              
              ::slotted(h1),
              ::slotted(h2),
              ::slotted(h3),
              ::slotted(h4),
              ::slotted(h5),
              ::slotted(h6) {
                 margin-right: 1rem;
              }
              
              tab-bar ::slotted([tabindex="0"]) {
                border-bottom: 1px solid blue;
              }
              
              tab-list { 
                display: flex; 
                overflow: hidden;
                white-space: nowrap;
              }
            </style>
            <tab-bar part="tab-bar">
              <!-- The region/tablist should have a  label -->
              <tab-list part="tab-list" role="tablist"
              ><slot name="tabListSlot"></slot></tab-list>
            </tab-bar>
            <content part="content-panels">
              <slot default></slot>
            </content>
        `;

      class RegionSet extends MediaAffordancesElement {
        __defaults;
        __tabListEl;

        // tabs and exclusive collapses should have the same affordance object?
        __affordanceConf = {
          collapse: {
            // can take a condition to force, check-like
            toggle: (label, condition) => {
              let state =
                typeof condition === "boolean"
                  ? condition
                  : !label.affordanceState.expanded;
              let contentEl = label.nextElementSibling;
              label.affordanceState.expanded = state;
              label.affordanceState.nonExclusiveExpanded = state;
              label.setAttribute("aria-expanded", state);
              if (state) {
                label.setAttribute("expanded", "");
                contentEl.style.display = "block";
              } else {
                label.removeAttribute("expanded");
                contentEl.style.display = "none";
              }
            }
          },
          "exclusive-collapse": {
            // ignores condition, radio-like
            toggle: label => {
              let labels = getLabels(label.parentElement);
              let siblings = labels.filter(c => c !== label);
              let index = labels.findIndex(c => c === label);

              siblings.forEach((sibLabel, i) => {
                let relatedContent = sibLabel.nextElementSibling;
                sibLabel.tabIndex = -1;
                relatedContent.style.display = "none";
                label.setAttribute("aria-expanded", "false");
                sibLabel.affordanceState.exclusiveExpanded = false;
              });
              label.tabIndex = 0;
              //nope - todo, fix/remove this?
              label.parentElement.affordanceState.exclusiveSelection.index = index;
              label.nextElementSibling.style.display = "block";
              label.setAttribute("aria-expanded", "true");
              label.affordanceState.exclusiveExpanded = true;
              label.focus();
            }
          },
          "tab-bar": {
            // ignores condition, radio-like
            toggle: label => {
              let labels = getLabels(label.parentElement);
              let siblings = labels.filter(c => c !== label);
              let index = labels.findIndex(c => c === label);

              siblings.forEach((sibLabel, i) => {
                let relatedContent = sibLabel.nextElementSibling;
                sibLabel.tabIndex = -1;
                relatedContent.style.display = "none";
                sibLabel.setAttribute("aria-expanded", "false");
                sibLabel.affordanceState.exclusiveExpanded = false;
              });
              label.tabIndex = 0;
              label.parentElement.affordanceState.exclusiveSelection.index = index;
              label.nextElementSibling.style.display = "block";
              label.setAttribute("aria-expanded", "true");
              label.affordanceState.exclusiveExpanded = true;
              label.focus();
            }
          }
        };
        __setSize = (labelEls, contentEls) => {
          this.__size = Math.min(labelEls.length, contentEls.length);

          if (labelEls.length !== this.__size) {
            console.warn("mismatch in tab-set label/content pairs...");
          }

          labelEls.forEach((labelEl, i) => {
            let contentEl = contentEls[i];
            if (!labelEl.initialized) {
              labelEl.initialized = true; // todo: this used to be shadow, do i need it?
              let defs = this.__defaults.defaultActive;

              // this assumes it is about collapses
              labelEl.affordanceState = {
                expanded: defs.includes(labelEl),
                active: false,
                // activate in the current mode
                activate: () => {
                  if (this.affordanceState.current) {
                    this.__affordanceConf[this.affordanceState.current].toggle(
                      labelEl
                    );
                  }
                }
              };

              let defaultExclusive =
                defs.length === 0 ? labelEls[0] : defs[defs.length - 1];

              this.affordanceState.exclusiveSelection.index = labelEls.indexOf(
                defaultExclusive
              );
            }
            labelEl.setMode = mode => {
              if (mode === "non-exclusive") {
                let isExpanded = labelEl.affordanceState.expanded;
                labelEl.setAttribute("affordance", "collapse");
                labelEl.setAttribute("tabindex", "0");
                labelEl.setAttribute("aria-controls", contentEl.id);
                labelEl.setAttribute("role", "button");
                labelEl.setAttribute("aria-expanded", isExpanded);
                labelEl.nextElementSibling.style.display = isExpanded
                  ? "block"
                  : "none";
              } else if (mode === "exclusive") {
                let isExpanded =
                  labelEls.indexOf(labelEl) ===
                  this.affordanceState.exclusiveSelection.index;
                labelEl.setAttribute("affordance", "collapse");
                labelEl.setAttribute("tabindex", isExpanded ? 0 : -1);
                labelEl.setAttribute("role", "button");
                labelEl.setAttribute("aria-expanded", isExpanded);
                labelEl.setAttribute("aria-controls", contentEl.id);
                labelEl.nextElementSibling.style.display = isExpanded
                  ? "block"
                  : "none";
              } else {
                labelEl.removeAttribute("tabIndex");
                labelEl.removeAttribute("affordance");
                labelEl.removeAttribute("aria-expanded");
                labelEl.removeAttribute("role");
              }
            };
          });
        };

        __projectTabBar = () => {
          this.__removeProjections();
          getLabels(this).forEach((tabSource, i) => {
            let selected = false,
              tabIndex = -1,
              display = "none";

            tabSource.setMode();
            tabSource.slot = "tabListSlot";
            tabSource.setAttribute("role", "tab");
            let tabId = ensureId(tabSource);
            let contentSource = tabSource.nextElementSibling;
            contentSource.tabIndex = 0;
            tabSource.setAttribute("aria-controls", ensureId(contentSource));
            contentSource.setAttribute("role", "tabpanel");
            contentSource.setAttribute("aria-labelledby", tabSource.id);
            if (i === this.affordanceState.exclusiveSelection.index) {
              tabIndex = 0;
              selected = true;
              display = "block";
            }
            tabSource.setAttribute("aria-selected", selected);
            tabSource.tabIndex = tabIndex;
            contentSource.style.display = display;

            // TODO: aria-orientation :(
          });
        };

        __projectCollapses = exclusive => {
          // TODO - remove projections and... ??
          this.__removeProjections();
          getLabels(this).forEach(label => {
            label.setMode(exclusive ? "exclusive" : "non-exclusive");
          });
        };

        __removeProjections = () => {
          [...this.children].forEach(child => {
            child.removeAttribute("slot");
            child.removeAttribute("affordance")
            child.removeAttribute("role");
            child.removeAttribute("aria-selected");
            child.removeAttribute("aria-controls");
            child.removeAttribute("tabindex");
            child.removeAttribute("aria-expanded")
            child.style.display = "block";
          });
        };

        // matching pairs
        __size = 0;

        __configure = () => {
          ///hmmm

          this.__setSize(getLabels(this), getContentEls(this));

          if (this.affordanceState.current === "tab-bar") {
            this.affordanceState.currentMode = "exclusive";
            this.__projectTabBar();
          } else if (this.affordanceState.current === "collapse") {
            this.affordanceState.currentMode = "non-exclusive";
            this.__projectCollapses();
          } else if (this.affordanceState.current === "exclusive-collapse") {
            this.affordanceState.currentMode = "exclusive";
            this.__projectCollapses(true);
          } else {
            this.affordanceState.currentMode = undefined;
            this.__removeProjections();
          }

          let specifiedIndex = this.activeTabIndex || 0;
          // TODO: hmm, these are DOM changes, we could cache them
          let labelEls = getLabels(this);
          let contentEls = getContentEls(this);

          for (let i = 0; i < this.__size; i++) {
            let label = labelEls[i];
            // probably add one handler that decides
            if (!label._inited) {
              label.addEventListener("click", evt => {
                evt.target.affordanceState.activate();
              });
              label._inited = true;
            }
          }
        };
        
        __childListObserver = new MutationObserver(mutationList => {
          // we have to wire up new elements
          let labelEls = getLabels(this);
          let contentEls = getContentEls(this);

          // what if there is a mismatch?
          this.__setSize(labelEls, contentEls);
          this.__configure();
        });

        __tabset;

        affordanceState = {
          exclusiveSelection: { index: undefined },
          current: undefined,
          currentMode: undefined,
          getLabels: () => {
            return getLabels(this);
          }
        };

        /*
          Wires up suppored affordances...
        */
        constructor() {
          super();
          this.supportedAffordances.add("tab-bar");
          this.supportedAffordances.add("collapse");
          this.supportedAffordances.add("exclusive-collapse");

          this.observeAffordanceChange((matching, all) => {
            if (!this.__defaults) {
              this.__defaults = {
                onMatch: this.hasAttribute("defaults-on-match"),
                defaultActive: getLabels(this).filter(l =>
                  l.hasAttribute("default-activate")
                )
              };
            }
            this.affordanceState.current = this.getAttribute("affordance");
            this.__configure();
          });

          this.attachShadow({ mode: "open" });
          this.shadowRoot.innerHTML = template;
     
          this.__tabListEl = this.shadowRoot.querySelector("tab-list");
          this.addEventListener(
            "keydown",
            evt => {
              let labels = getLabels(this);
              let size = labels.length;
              let cur = this.affordanceState.exclusiveSelection.index;
              let prev = cur === 0 ? size - 1 : cur - 1;
              let next = cur === size - 1 ? 0 : cur + 1;

              if (
                this.affordanceState.current === "tab-bar" ||
                this.affordanceState.current === "exclusive-collapse"
              ) { 
                if (evt.keyCode == 37 || evt.keyCode == 38) {
                  labels[prev].affordanceState.activate();
                } else if (evt.keyCode == 39 || evt.keyCode == 40) {
                  labels[next].affordanceState.activate();
                }
              } else if (evt.keyCode == 32 && this.affordanceState.current === 'collapse') {
                evt.preventDefault()
              }
            },
            false
          );
          this.addEventListener(
            "keyup", 
            evt => {
              if (evt.keyCode == 32 && this.affordanceState.current === 'collapse') {
                evt.target.closest('[affordance]').affordanceState.activate()
                evt.preventDefault()
              }
            })
        }

        connectedCallback() {
          super.connectedCallback();

          //TODO: check whether there is a hash/handle selection
          
          // If you append a fragment with a pair, it should work
          this.__childListObserver.observe(this, { childList: true });
        }
      }
      customElements.define("spicy-sections", RegionSet);
    })();
    </script>
  <script>
    Array.prototype.slice.call(document.querySelectorAll('.optional [data-src]')).forEach(function (optional) {
      var prefs = window.localStorage.downloadsPrefs,
          clickToSee;
      if (prefs === 'true') {
        activateOptional(optional);
      } else {
        clickToSee = document.createElement('div');
        clickToSee.classList.add('clickToSee')
        clickToSee.innerHTML = '<button>Click to see media</button>';
        clickToSee.style.textAlign = 'center';
        clickToSee.style.border = 'none';
        optional.parentElement.insertBefore(clickToSee, optional.nextSibling);
        clickToSee.firstElementChild.addEventListener('click', function () {
          activateOptional(optional);
        })
      }

    })
  </script>

</body></html>