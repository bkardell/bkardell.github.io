<html lang="en" resource-type="blogpost"><head>  
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@briankardell">
    <meta name="twitter:creator" content="@briankardell">
    <meta name="twitter:title" content="Why I'm hella excited about OffscreenCanvas">
    <meta name="twitter:description" content="My friend and co-worker at Igalia Chris Lord has been working on OffscreenCanvas in WebKit and I'm (almost unreasonably) excited about it for so many reasons.    In this post, I'll">
    
    <meta name="monetization" content="$ilp.uphold.com/kKU4GXiRwhnf ">

    <link rel="alternate" type="application/rss+xml" href="https://bkardell.com/blog/feed.rss" title="bkardell.com/blog rss feed">
    <title>Why I'm hella excited about OffscreenCanvas</title> 
    <style>.captioned-image {
    background-color: #eaeaea;
    display: block;
    overflow: hidden;
    padding: 1rem;
    text-align: center;
    font-style: italic;
}

.captioned-image.p-attached {
    width: 40%;
    display: inline-block;
    margin: 0 1rem 2rem 1rem;
}

section > .captioned-image.p-attached {
    margin-top: 1.5rem; /* correct for heading size*/
}

 pre { overflow-x: auto }

.captioned-image.p-attached.p-attached-left {
    float: left;
}

.captioned-image.p-attached.p-attached-right {
    float: right;
}

.captioned-image.p-attached + * + * {
    clear: both;
    margin-top: 2rem;
}


.captioned-image img, .captioned-image video {
    display: block;
    max-width: 100%;
    margin: 0 auto 1em auto;
}
.source {
    font-style: italic;
}
body {
    display: grid;
    grid-template-columns: 25rem auto;
    font: 1.1rem "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-weight: 400;
    line-height: 1.625;
    margin: 0;
}
h1 { margin: 0.5rem; }
code-format {
    border-left: 0.5rem solid rgba(123,115,209,0.35);
    display: block;
    padding: 0.5rem;
    margin-bottom: 1rem;
}

contextual-heading {
    display: block;
    margin-top: 2rem;
}

h1, [aria-level="1"] {
    color: #43686b;
    font-size: 1.45rem;
}

h2, [aria-level="2"] {
    color: #856363;
    font-size: 1.35rem;
}

h3, [aria-level="3"] {
    color: #856363;
    font-size: 1.25rem;
}

h4, [aria-level="4"] {
    color: #856363;
    font-size: 1.2rem;
}

h5, h6, [aria-level="5"], [aria-level="6"] {
    color: #667496;
    font-size: 1.2rem;
    font-weight: bolder;
}

.posted-on {
    font-style: italic;
    font-size: 0.8rem; 
    text-align: right;
    margin-bottom: 1rem;
}

ul, li {
    margin: 0.5rem;
    text-align: left;
}

.authorinfo {
    height: 100%;
    padding-top: 1rem;
    padding-right: 0;
    background-color: #fbf5e9; 
    display: block;
    background-image: linear-gradient(to right, #dde0e8 , #ffffff);
}

.tagline {
    font-style: italic;
    text-align: center;
}

[tag-esc] {
    color: maroon;
    font-family: Courier, "Lucida Console", monospace;
}

[tag-esc]::before {
    content: '<';
}

[tag-esc]::after {
    content: '>';
}

main {
    min-width: 50%;
    width: 80%;
    padding: 1rem;
}
header .title {
    background-color: rgba(123,115,209,0.35);
    padding: 0.3rem;
    padding-left: 0.25rem;
    font-weight: bolder;
    font-size: 1rem;
    border-left: 1rem solid #999298;
}

header .profile {
    width: 50%;
    margin: 1rem 25%;
}

header .title + nav {
    font-size: 0.9rem;
}

header .blurb {
    font-size: 0.9rem;
    text-align: center;
}
header .name {
    text-align: center;
    font-size: xx-large;
}
.segue {
    font-style: italic;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
}

#aboutMeToggle {
    display: none;
}

spicy-sections:not([affordance]) > h2 {
  clip: rect(0 0 0 0);
  clip-path: inset(50%);
  height: 1px;
  overflow: hidden;
  position: absolute;
  white-space: nowrap;
  width: 1px;
}

main article { max-width: 100em; margin: auto; }
/* this needs rethinking, it wants a selector like 'not flow content' */
article>*:not(contextual-heading,a), section>*:not(contextual-heading,a) {
    margin-left: 0.45rem;
}

blockquote {
  font-family: serif;
  background: #f9f9f9;
  border-left: 10px solid #ccc;
  margin: 1.5em 10px;
  padding: 0.5em 10px;
}
blockquote:before {
  color: #ccc;
  content: open-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-right: 0.25em;
  vertical-align: -0.4em;
}

blockquote:after {
  color: #ccc;
  content: close-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-left: 0.25em;
  vertical-align: -0.4em;
}
 

@media (max-width: 800px){
    body {
        grid-template-columns: 1fr;
    }
    .authorinfo {
        height: auto;
        border-bottom: 1px solid #afafff;
        padding-top:  0;
    } 

    main { width: 95%; margin: 0 auto;}

    .captioned-image.p-attached {
        width: 100%;
        margin: 1rem 0;
    }

    .captioned-image.p-attached.p-attached-left,
    .captioned-image.p-attached.p-attached-right {
        float: none;
    }

    #aboutMeToggle {
        display: block;
        background-color: #675e5e;
        color: white;
        padding: 0.25rem;
        padding-left: 0.5rem;
        border-left: 1rem solid black;
    }

    header li { display: inline; margin-left: -0.5em; }
    header .blurb li::after { content: '; '; }
    header  nav li {
        display: inline-block;
        margin-left: 0.35rem;
        margin-right: 0.35rem;
    }
    header .title {
        width: 100%;
    }
    main li .source { display: block; }

} 

spicy-sections {
    --const-mq-affordances:
      [screen and (min-width: 600px) ] collapse |
      [screen and (min-width: 801px) ] tab-bar
    ;
    display: block;
}

spicy-sections.authorinfo {
    --const-mq-affordances:
      [screen and (max-width: 801px) ] collapse
    ;
}


spicy-sections.single {
    --const-mq-affordances:
      [screen ] collapse 
;
}

[role="tab"] {
    margin-right:  1.5rem;
}

</style>
    <style>
      .captioned-image { font-size: 0.9rem; }
      .thanksTo { font-style: italic; font-size: 0.8rem; }
    </style>
    <script>
      var activateOptional = function (media) {
        var source = media.getAttribute('data-src'),
            temp,
            container = media.parentElement;

          if (media.nextSibling && media.nextSibling.matches) {
            if (media.nextSibling.matches('.clickToSee')) {
              media.parentElement.removeChild(media.nextSibling);
            }
          }
 
          if (media.tagName === 'VIDEO') {
            temp = document.createElement('video')
            temp.setAttribute('autoplay','')
            temp.setAttribute('controls','')
            temp.setAttribute('loop','')
            temp.innerHTML = '<source src="' + source + '.webm" type="video/webm">'
                    + '<source src="' + source + '.mp4" type="video/mp4">';
            media.parentElement.replaceChild(temp, media);
            setTimeout(function () {
              temp.play()
            }, 0);
          } else {
            media.src = media.getAttribute('data-src');
          }

          container.classList.add('active');
      }
    </script>
  </head>
  <body>
    <spicy-sections class="authorinfo">
<h2 id="aboutMeToggle" defaults-on-match="">Author Information</h2>
  
<header>
    <div class="name">
        Brian Kardell
    </div>
    <img class="profile" src="/profile.jpg" alt="">
    <div class="tagline"><a href="/">Betterifying the Web</a></div>
    <div class="blurb">
        <ul>
            <li>Developer Advocate at Igalia</li>
            <li>Original Co-author/Co-signer of The Extensible Web Manifesto</li>
            <li>Co-Founder/Chair, W3C Extensible Web CG</li>
            <li>Member, W3C (OpenJS Foundation)</li>
            <li>Co-author of HitchJS</li>
            <li>Blogger</li>
            <li>Art, Science &amp; History Lover</li>
            <li>Standards Geek</li>
        </ul>
    </div>
    <div class="title">Follow Me On...</div>
    <nav>
        <ul>
            <li><a rel="me" href="https://briankardell.wordpress.com">Wordpress</a></li>
            <li><a rel="me" href="https://medium.com/@briankardell">Medium</a></li>
            <li><a rel="me" href="https://twitter.com/briankardell">Twitter</a></li>
            <li><a rel="me" href="https://github.com/bkardell/">Github</a></li>
            <li><a rel="me" href="https://codepen.io/bkardell">Codepen</a></li>
            <li><a rel="me" href="https://www.linkedin.com/in/brian-kardell-08a4264">LinkedIn</a></li>
            <li><a rel="me" href="https://www.instagram.com/kardellbrian">Instagram (for
art)</a></li>
            <li><a rel="me" href="http://fineartamerica.com/profiles/brian-kardell?">Fine Art
America (art for sale)</a></li>
        </ul>
    </nav>
</header>
</spicy-sections>
<script>
  /*
    You're probably wondering "Do I need to write this?""
    "Is this part of it?"  No... If you're interested tho - 
    Custom elements have a FOUC/PE gap 
    (see https://github.com/whatwg/html/issues/6231).
    This is a slightly better experience: It 
    will be hidden _if JS is enabled_, and 
    will be shown as it is defined, 
    or after 1 sec, whichever is first.
  */
  let ss = document.createElement("style");

  ss.innerHTML = `html:not(.lldelay) :not(:defined) { visibility: hidden; }`;
  document.head.appendChild(ss);

  setTimeout(() => {
    document.documentElement.classList.add("lldelay");
  }, 1000);
</script>
    <main><div class="posted-on">Posted on null</div><article class="sectioning">
    <h1 class="contextual-heading">Why I'm hella excited about <code>OffscreenCanvas</code></h1>

  <p class="segue">My friend and co-worker at Igalia <a href="https://twitter.com/cwiiis">Chris Lord</a> has been working on <code>OffscreenCanvas</code> in WebKit and I'm (almost unreasonably) excited about it for <em>so many reasons</em>.    In this post, I'll tell you a little about why it is a Really Big Deal™ to me.</p>
  <style>
    iframe { width: 100%; height: fit-content; }
    figcaption { font-style: italic; }
  </style>
  <section>
    <h2>What the heck is <code>OffscreenCanvas</code>?</h2>

    <p><code>OffscreenCanvas</code> is a JavaScript class  with a <code>getContent('2d')</code> method, just like the <code>&lt;canvas&gt;</code> element.  Unlike <code>&lt;canvas&gt;</code>, however it is <em>independent from a DOM element</em>. That's great, because it means you can create and use one, even in a worker.</p>

    <p>Cool enough... But <code>OffscreenCanvas</code> <em>also</em> has a superpower: Instances of it are <em>transferrable</em>. In other words, references to them can be transferred via <code>postMessage</code>!  </p>

    <p>All of this is really boosted by the addition of a new method on the existing DOM <code>&lt;canvas&gt;</code> API itself: <code>.transferControlToOffscreen</code>.  This returns an instance of an <code>OffscreenCanvas</code>.</p>

    <p>All that might be a little hard to put together in your head - but what is means, practically speaking, is that that you can "break off" the part of a <code>&lt;canvas&gt;</code> which is in charge of actually painting on that element's surface, and hand control doing that to a worker (asynchronously).  Amazing.</p>
  </section>

  <section class="sectioning">
    <h2 class="contextual-heading">Why I think it's so exciting.</h2>
    <p>First, it's really great for performance, which I'll demonstrate and talk about.  But the story of how we got here helps explain all of the subtle, but important reasons I think this is also exciting:
      </p><li>It is an illustration of platform evolution</li>
      <li>It helps resolve some historical questions and tech debt</li>
      <li>It is an illustration of improving the health and prioritization of the commons that is the Web ecosystem.</li>
    
    <p>To understand all of this, let me set the stage...</p>
     
    <section class="sectioning">
      <h3 class="contextual-heading">Prelude: The introduction of <code>&lt;canvas&gt;</code></h3>

    <p>It's hard to overstate just how much has changed since just before 2004 when Apple introduced the <code>&lt;canvas&gt;</code> element. Before this "HTML5 era" standards were stalled.  Interoperability was <em>poor</em> - most things were not very rigorously specified and there were no shared tests.</p>

    <p>Also, browsers didn't have tabs, just windows everything  ran in a single process and on a single thread.</p>

    <p>This is the world into which Apple introduced the <code>&lt;canvas&gt;</code> element, explaining it as as <em>"an image element with a programmatic drawing surface"</em> (remember that, it will come back).  </p>

    <p>It seemed like a <em>really</em> neat idea to me...  I wasn't quite sure <em>what</em> you would practically do with it, but very soon people began sharing lots of cool demos and experiments. I still remember a number of them.</p>
  </section>
 
  <section class="sectioning">
    <h3 class="contextual-heading">Exploration and iteration</h3>

    <p>Lots of those early experiments were mostly toys.  Many were also terrible on counts: Lots were totally inaccessible.  Some shot way too far. All of them inherently  bound up the main thread and had performance challenges.</p>

    <p>But, as we've come to see many times, the ability for <em>developers</em> to use the available tools to dream, share, rapidly critique and then iterate upon is a pretty powerful force. It allowed us to explore the question "but... for what?" in concrete ways without guessing. It helped show that there are lots of <em>actually very useful things</em> one could build - and far more that could be, if only performance was better...</p>
  </section>

  <section class="sectioning">
    <h3 class="contextual-heading">Now make it fast.</h3>

    <p>The fact that we now have many proven and real world uses helps highlight what could be improved. It also provides test scenarios that aren't easily gamed benchmarks to test whether new solutions actually help achieve that.</p>

    <p>Here's an example that should be easy to appreciate: Maps.  Maps on the web incredibly useful.  Many of the most popular map tools and services ultimately render to a canvas. This involves lots of taxing work.  You might have experienced janky painting or blocked user input as you attempted to pan or zoom around as all of that was blocking the main thread.  To highlight the impact that <code>OffscreenCanvas</code> this can have on maps, Andreas Hocevar has integrated a version of <code>OffscreenCanvas</code> into the OpenLayers mapping library. The before and after comparison (below) of even this initial work sort of speak for themselves...</p>

    <details>
      <summary>Demo - Maps: <strong>Before</strong> <code>Offscreen Canvas</code></summary>
      <figure>

        <iframe src="https://player.vimeo.com/video/399970907" width="640" height="366" frameborder="0" style="width:100%" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen=""></iframe>
        <figcaption>User interactions are temporarily blocked on and off as rendering tries to keep up. The rendering itself is very janky.  The interface feels a little broken and frustrating.</figcaption>
      </figure>
    </details>
    
    <details>
      <summary>Demo - Maps: Using <code>Offscreen Canvas</code></summary>
      <figure>
        <iframe src="https://player.vimeo.com/video/399972879" width="640" height="366" frameborder="0" style="width:100%" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen=""></iframe>
        <figcaption>Using <code>OffscreenCanvas</code>, user interactions are not blocked - the rendering is way more fluid and the interface is able to feel smooth and responsive.</figcaption>
      </figure>
    </details>

    <p>You can read a lot more about this experiment and other impressive and important benchmarks in the <a href="maps4html">Benchmarks section of his post</a>
    

    </p><p>There are a <em>ton</em> of things like this that already exist, made with <code>canvas</code> and which can now offer a real boost to all of their users.</p>
  </section>

  <section class="sectioning">
    <h3 class="contextual-heading">Bigger communities, re-thinking prioritization</h3>

    <p>Another thing that excites me is how Igalia is getting this work done and the impacts it has.</p>

    <p>Lots of good people in the web community are constantly pushing us to please pay attention to people who don't have expensive phones. However, not only is this not working out so well - it is really only scratching the surface of it.</p>

    <section class="sectioning">
      <h4 class="contextual-heading">For whom the bell tolls</h4>
     Cheap tablets also abound, for example.  But, far more than that: embedded devices are <em>everywhere</em>! Game consoles, the TVs they play on, the cable boxes and streaming devices that are hooked up to them: <em>All of them</em> are embedded hardware, and most of those are presenting interfaces with web rendering engines.  Wow!  And <em>those are just the ones that are probably in front of your face as you sit on the livingroom couch</em>.<p></p>

    <p>Walk into a modern kitchen and you'll find more: Smart appliances from refrigerators to stoves to cooking devices... Same thing.  </p>

    <p>Travel somewhere, you'll find web engine based interfaces in just about every form of transportation these days: Infotainment systems in cars, airplanes, trains and vehicle dashboards too.</p>

    <p>While you're looking out the window in transit, you'll see some more in digital signage. You'll find them in the stores you visit in point of sale systems, kiosks, at gas pumps - I mean, they are <em>literally everywhere</em>.</p>

    <p>For that one <em>maybe powerful</em> device you call a "phone" and look at a bunch during the day, you probably encounter half a dozen or more (and growing) embedded systems using web tech. And, with a few rare exceptions, they are almost universally underpowered, and replaced really slowly.</p>

    <p>Ask not for whom the hardware is slow - it is for you!</p>

    <p>Plenty of things which are at least usefully functional on a higher-end device can quickly drop the framerate (and resposiveness to user input) all the way down to ~1ps on some of these devices.</p>

    <p>More interestingly still - many of those devices are <em>precisely</em> the ones that really <em>want</em> the ability to make splashy visualization with canvas and SVG.</p>

    <p>Our work on <code>OffscreenCanvas</code> at Igalia helped create new priotitization pressures and diversified investments through things like cable boxes and cooking devices.  Lots of our tests that bog those systems down to near 1ps now run a fluid 60fps... And they make things better for <em>all of these devices</em> along the way.</p>

    <p>I think that's <em>hella</em> cool.</p>
  </section>
 
  <section class="sectioning">
    <h4 class="contextual-heading">Paying down Web Tech Debt</h4>

    <p>Here's <em>another</em> reason it excites me:  Shortly after we wrote the Extensible Web Manifesto, Alex Russell, Yehuda Katz and I <a href="https://www.smashingmagazine.com/2013/11/laying-the-groundwork-for-extensibility/">co-authored a piece for smashing magazine</a> where we explained some of the rationale for writing it.  In it, we explained that the platform had, essentially, a lot of tech debt, and needed to pay some some attention to it and lay good groundwork for the future.</p>

    <p><code>&lt;canvas&gt;</code> was an illustration we used. That's because while you can <em>imagine</em> the sort of relationship with <code>&lt;img&gt;</code> as described in its introduction, it didn't exactly exist. In fact, while one probably imagined many strata of architecture empowering an <code>&lt;img&gt;</code>'s magic (fetching, decoding, painting pixels on a canvas, etc), it wasn't clear that really existed at all. From the outside, in fact, there appeared to be many inconsistencies. If such an architecture <em>did</em> exist, it was certainly unavailable to developers. This, we explained, was probably not great for the future.</p>

    <p>While I don't know that we've created a system that literally makes Apple's introduction <em>true</em>, there have been <em>lots</em> of developments and improvements to this story to make the web platform actually <em>have</em> some kind of stata of architecture that authors can understand, plug into, hack and extend - and the arrival of <code>OffscreenCanvas</code> is just the latest and greatest addition..  </p>

    <p>There are potentially many things that are <em>like</em> an <code>&lt;img&gt;</code> in some ways, and a myriad of ideas that could extend this or borrow features  I'm excited that this allows us to entertain lot of interesting experiments that we can rapidly share, compare, critique, break down, recompose nd reassemble in order to find  some really great ideas which a lot of people (and a diverse number of businesses) could support... And very importantly, it can share all fo the same platform "stuff" because it didn't have to reinvent the entire stack beneath it, making for much easier cow-paths to pave and create standards out of.</p>

    <p>What will they be? I don't know yet! I have some ideas, of course:  New patterns for data visualizations and rendering controls, for sure.  Some new ideas for image manipulation tools feel almost certain.  Perhaps customized image elements with register-able image decoders?  Perhaps ideas that integrate new concepts of panning and zooming an actual bitmap, potentially loading higher resolution one?</p>

    <figure class="captioned-image">  
      <iframe style="height: 644px" width="1145" height="644" src="https://www.youtube.com/embed/huLhOQM7pVA" title="YouTube video player" frameborder="0" allowfullscreen=""></iframe>
      <figcaption>An example of a progressively enhanced, independently pan-and-zoomable image which can lazily load higer-def image in action.</figcaption>
    </figure>

    <p>Or, maybe whole elements that manage the stitching together together of <em>many</em> tiles of a larger, and partially loaded conceptual image - like the technique used in mapping. </p>

    <p>Providing these new abilities unlocks all kinds of potential and my own imagination is limited. </p>

    <p>I can't wait to see what ideas develop here!</p>
  </section>
</section></section></article></main>
 
  
  <script>
    //import { MediaAffordancesElement } from "./MediaAffordancesElement.js";
    class MediaAffordancesElement extends HTMLElement {
      constructor() {
        super();
        // todo: this should be a private field
        this.__matching = new Set()
        this.mqls = [];
        this.observers = [];

        this.supportedAffordances = new Set();
      }

      observeAffordanceChange(cb) {
        this.observers.push(cb);
      }

      notifyChange() {
        let intersection = new Set();
        for (let elem of this.__matching) {
          if (this.supportedAffordances.has(elem)) {
            intersection.add(elem);
          }
        }

        if (this.__matching.size > 0) {
          this.setAttribute("mq-matched", [...this.__matching].join(" "));
        } else {
          this.removeAttribute("mq-matched");
        }
        let arr =  [...intersection]
        let affordance = arr[arr.length - 1];
        if (affordance) {
          this.setAttribute("affordance", affordance);
        } else {
          this.removeAttribute("affordance");
        }
        this.observers.forEach(cb => {
          cb(intersection, this.__matching);
        });
      }

      static get observedAttributes() {
        return ["mq-affordances"];
      }

      connectedCallback() {
        let newValue = getComputedStyle(this).getPropertyValue(
          "--const-mq-affordances"
        );
        this.connectListeners(newValue);
      }

      connectListeners(newValue = "") {
        if (newValue.trim().length === 0) {
          return;
        }
        
        newValue.split("|").forEach(segment => {
          let mq = segment.trim().match(/\[([^\]]*)/)[1];
          let names = segment
            .replace(`[${mq}]`, "")
            .trim()
            .split(" ");
          let mql = window.matchMedia(mq);
          let mqh = evt => {
            names.forEach(name => {
              this.__matching[mql.matches ? "add" : "delete"](name);
            });

            this.notifyChange();
          };
          mqh();
          mql.addEventListener("change", mqh);
          this.mqls.push(mql);
        }, this);
      }

      attributeChangedCallback(name, oldValue, newValue) {
        this.connectListeners(newValue);
      }
    }

    //-----------------------------------------------------

    (function() {
      let lastUId = 0;
      let nextUId = () => {
        return `cp${++lastUId}`;
      };

      let getLabels = regionset => {
        return [...regionset.children].filter(el => /^H\d$/.test(el.tagName));
      };

      let getContentEls = regionset => {
        return [...regionset.children].filter(el => !/^H\d$/.test(el.tagName));
      };

      let ensureId = el => {
        el.id = el.id || nextUId();
        return el.id;
      };

      let getDisclosureButton = label => {
        return label.shadowRoot.querySelector("button");
      };

     
      let style = document.createElement('style')
      style.innerHTML = `
          
        :where(spicy-sections > [affordance*="collapse"])::before { 
          content: ' ';
          display: inline-block;
          width: 0.5em;
          height: 0.75em;
          margin: 0 0.4em 0 0;
          transform: rotate(90deg);
          background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='10px' height='10px' viewBox='0 0 270 240' enable-background='new 0 0 270 240' xml:space='preserve'%3e%3cpolygon fill='black' points='5,235 135,10 265,235 '/%3e%3c/svg%3e ");
          background-size: 100% 100%;
        } 

        :where(spicy-sections > [affordance*="collapse"][aria-expanded="true"])::before, 
        :where(spicy-sections > [affordance*="collapse"][aria-expanded="true"])::after {
          transform: rotate(180deg);
        }
      `
      document.head.prepend(style)
      
      const template = `
            <style>
              :root {
                font-size: 1rem;
              }

              :host([hidden]),
              ::slotted([hidden]) {
                display: none;
              }
              
              ::slotted(h1),
              ::slotted(h2),
              ::slotted(h3),
              ::slotted(h4),
              ::slotted(h5),
              ::slotted(h6) {
                 margin-right: 1rem;
              }
              
              tab-bar ::slotted([tabindex="0"]) {
                border-bottom: 1px solid blue;
              }
              
              tab-list { 
                display: flex; 
                overflow: hidden;
                white-space: nowrap;
              }
            </style>
            <tab-bar part="tab-bar">
              <!-- The region/tablist should have a  label -->
              <tab-list part="tab-list" role="tablist"
              ><slot name="tabListSlot"></slot></tab-list>
            </tab-bar>
            <content part="content-panels">
              <slot default></slot>
            </content>
        `;

      class RegionSet extends MediaAffordancesElement {
        __defaults;
        __tabListEl;

        // tabs and exclusive collapses should have the same affordance object?
        __affordanceConf = {
          collapse: {
            // can take a condition to force, check-like
            toggle: (label, condition) => {
              let state =
                typeof condition === "boolean"
                  ? condition
                  : !label.affordanceState.expanded;
              let contentEl = label.nextElementSibling;
              label.affordanceState.expanded = state;
              label.affordanceState.nonExclusiveExpanded = state;
              label.setAttribute("aria-expanded", state);
              if (state) {
                label.setAttribute("expanded", "");
                contentEl.style.display = "block";
              } else {
                label.removeAttribute("expanded");
                contentEl.style.display = "none";
              }
            }
          },
          "exclusive-collapse": {
            // ignores condition, radio-like
            toggle: label => {
              let labels = getLabels(label.parentElement);
              let siblings = labels.filter(c => c !== label);
              let index = labels.findIndex(c => c === label);

              siblings.forEach((sibLabel, i) => {
                let relatedContent = sibLabel.nextElementSibling;
                sibLabel.tabIndex = -1;
                relatedContent.style.display = "none";
                label.setAttribute("aria-expanded", "false");
                sibLabel.affordanceState.exclusiveExpanded = false;
              });
              label.tabIndex = 0;
              //nope - todo, fix/remove this?
              label.parentElement.affordanceState.exclusiveSelection.index = index;
              label.nextElementSibling.style.display = "block";
              label.setAttribute("aria-expanded", "true");
              label.affordanceState.exclusiveExpanded = true;
              label.focus();
            }
          },
          "tab-bar": {
            // ignores condition, radio-like
            toggle: label => {
              let labels = getLabels(label.parentElement);
              let siblings = labels.filter(c => c !== label);
              let index = labels.findIndex(c => c === label);

              siblings.forEach((sibLabel, i) => {
                let relatedContent = sibLabel.nextElementSibling;
                sibLabel.tabIndex = -1;
                relatedContent.style.display = "none";
                sibLabel.setAttribute("aria-expanded", "false");
                sibLabel.affordanceState.exclusiveExpanded = false;
              });
              label.tabIndex = 0;
              label.parentElement.affordanceState.exclusiveSelection.index = index;
              label.nextElementSibling.style.display = "block";
              label.setAttribute("aria-expanded", "true");
              label.affordanceState.exclusiveExpanded = true;
              label.focus();
            }
          }
        };
        __setSize = (labelEls, contentEls) => {
          this.__size = Math.min(labelEls.length, contentEls.length);

          if (labelEls.length !== this.__size) {
            console.warn("mismatch in tab-set label/content pairs...");
          }

          labelEls.forEach((labelEl, i) => {
            let contentEl = contentEls[i];
            if (!labelEl.initialized) {
              labelEl.initialized = true; // todo: this used to be shadow, do i need it?
              let defs = this.__defaults.defaultActive;

              // this assumes it is about collapses
              labelEl.affordanceState = {
                expanded: defs.includes(labelEl),
                active: false,
                // activate in the current mode
                activate: () => {
                  if (this.affordanceState.current) {
                    this.__affordanceConf[this.affordanceState.current].toggle(
                      labelEl
                    );
                  }
                }
              };

              let defaultExclusive =
                defs.length === 0 ? labelEls[0] : defs[defs.length - 1];

              this.affordanceState.exclusiveSelection.index = labelEls.indexOf(
                defaultExclusive
              );
            }
            labelEl.setMode = mode => {
              if (mode === "non-exclusive") {
                let isExpanded = labelEl.affordanceState.expanded;
                labelEl.setAttribute("affordance", "collapse");
                labelEl.setAttribute("tabindex", "0");
                labelEl.setAttribute("aria-controls", contentEl.id);
                labelEl.setAttribute("role", "button");
                labelEl.setAttribute("aria-expanded", isExpanded);
                labelEl.nextElementSibling.style.display = isExpanded
                  ? "block"
                  : "none";
              } else if (mode === "exclusive") {
                let isExpanded =
                  labelEls.indexOf(labelEl) ===
                  this.affordanceState.exclusiveSelection.index;
                labelEl.setAttribute("affordance", "collapse");
                labelEl.setAttribute("tabindex", isExpanded ? 0 : -1);
                labelEl.setAttribute("role", "button");
                labelEl.setAttribute("aria-expanded", isExpanded);
                labelEl.setAttribute("aria-controls", contentEl.id);
                labelEl.nextElementSibling.style.display = isExpanded
                  ? "block"
                  : "none";
              } else {
                labelEl.removeAttribute("tabIndex");
                labelEl.removeAttribute("affordance");
                labelEl.removeAttribute("aria-expanded");
                labelEl.removeAttribute("role");
              }
            };
          });
        };

        __projectTabBar = () => {
          this.__removeProjections();
          getLabels(this).forEach((tabSource, i) => {
            let selected = false,
              tabIndex = -1,
              display = "none";

            tabSource.setMode();
            tabSource.slot = "tabListSlot";
            tabSource.setAttribute("role", "tab");
            let tabId = ensureId(tabSource);
            let contentSource = tabSource.nextElementSibling;
            contentSource.tabIndex = 0;
            tabSource.setAttribute("aria-controls", ensureId(contentSource));
            contentSource.setAttribute("role", "tabpanel");
            contentSource.setAttribute("aria-labelledby", tabSource.id);
            if (i === this.affordanceState.exclusiveSelection.index) {
              tabIndex = 0;
              selected = true;
              display = "block";
            }
            tabSource.setAttribute("aria-selected", selected);
            tabSource.tabIndex = tabIndex;
            contentSource.style.display = display;

            // TODO: aria-orientation :(
          });
        };

        __projectCollapses = exclusive => {
          // TODO - remove projections and... ??
          this.__removeProjections();
          getLabels(this).forEach(label => {
            label.setMode(exclusive ? "exclusive" : "non-exclusive");
          });
        };

        __removeProjections = () => {
          [...this.children].forEach(child => {
            child.removeAttribute("slot");
            child.removeAttribute("affordance")
            child.removeAttribute("role");
            child.removeAttribute("aria-selected");
            child.removeAttribute("aria-controls");
            child.removeAttribute("tabindex");
            child.removeAttribute("aria-expanded")
            child.style.display = "block";
          });
        };

        // matching pairs
        __size = 0;

        __configure = () => {
          ///hmmm

          this.__setSize(getLabels(this), getContentEls(this));

          if (this.affordanceState.current === "tab-bar") {
            this.affordanceState.currentMode = "exclusive";
            this.__projectTabBar();
          } else if (this.affordanceState.current === "collapse") {
            this.affordanceState.currentMode = "non-exclusive";
            this.__projectCollapses();
          } else if (this.affordanceState.current === "exclusive-collapse") {
            this.affordanceState.currentMode = "exclusive";
            this.__projectCollapses(true);
          } else {
            this.affordanceState.currentMode = undefined;
            this.__removeProjections();
          }

          let specifiedIndex = this.activeTabIndex || 0;
          // TODO: hmm, these are DOM changes, we could cache them
          let labelEls = getLabels(this);
          let contentEls = getContentEls(this);

          for (let i = 0; i < this.__size; i++) {
            let label = labelEls[i];
            // probably add one handler that decides
            if (!label._inited) {
              label.addEventListener("click", evt => {
                evt.target.affordanceState.activate();
              });
              label._inited = true;
            }
          }
        };
        
        __childListObserver = new MutationObserver(mutationList => {
          // we have to wire up new elements
          let labelEls = getLabels(this);
          let contentEls = getContentEls(this);

          // what if there is a mismatch?
          this.__setSize(labelEls, contentEls);
          this.__configure();
        });

        __tabset;

        affordanceState = {
          exclusiveSelection: { index: undefined },
          current: undefined,
          currentMode: undefined,
          getLabels: () => {
            return getLabels(this);
          }
        };

        /*
          Wires up suppored affordances...
        */
        constructor() {
          super();
          this.supportedAffordances.add("tab-bar");
          this.supportedAffordances.add("collapse");
          this.supportedAffordances.add("exclusive-collapse");

          this.observeAffordanceChange((matching, all) => {
            if (!this.__defaults) {
              this.__defaults = {
                onMatch: this.hasAttribute("defaults-on-match"),
                defaultActive: getLabels(this).filter(l =>
                  l.hasAttribute("default-activate")
                )
              };
            }
            this.affordanceState.current = this.getAttribute("affordance");
            this.__configure();
          });

          this.attachShadow({ mode: "open" });
          this.shadowRoot.innerHTML = template;
     
          this.__tabListEl = this.shadowRoot.querySelector("tab-list");
          this.addEventListener(
            "keydown",
            evt => {
              let labels = getLabels(this);
              let size = labels.length;
              let cur = this.affordanceState.exclusiveSelection.index;
              let prev = cur === 0 ? size - 1 : cur - 1;
              let next = cur === size - 1 ? 0 : cur + 1;

              if (
                this.affordanceState.current === "tab-bar" ||
                this.affordanceState.current === "exclusive-collapse"
              ) {
                if (evt.keyCode == 37 || evt.keyCode == 38) {
                  labels[prev].affordanceState.activate();
                } else if (evt.keyCode == 39 || evt.keyCode == 40) {
                  labels[next].affordanceState.activate();
                }
              }
            },
            false
          );
        }

        connectedCallback() {
          super.connectedCallback();

          //TODO: check whether there is a hash/handle selection
          
          // If you append a fragment with a pair, it should work
          this.__childListObserver.observe(this, { childList: true });
        }
      }
      customElements.define("spicy-sections", RegionSet);
    })();
    </script>
  <script>
    Array.prototype.slice.call(document.querySelectorAll('.optional [data-src]')).forEach(function (optional) {
      var prefs = window.localStorage.downloadsPrefs,
          clickToSee;
      if (prefs === 'true') {
        activateOptional(optional);
      } else {
        clickToSee = document.createElement('div');
        clickToSee.classList.add('clickToSee')
        clickToSee.innerHTML = '<button>Click to see media</button>';
        clickToSee.style.textAlign = 'center';
        clickToSee.style.border = 'none';
        optional.parentElement.insertBefore(clickToSee, optional.nextSibling);
        clickToSee.firstElementChild.addEventListener('click', function () {
          activateOptional(optional);
        })
      }

    })
  </script>

</body></html>