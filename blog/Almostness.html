<html lang="en" resource-type="blogpost"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@briankardell">
    <meta name="twitter:creator" content="@briankardell">
    <meta name="twitter:title" content="Almostness">
    <meta name="twitter:description" content="I'd like to discuss a thing that's been weighing kind of heavily on my mind for a few years now with regard to evolving &quot;HTML&quot;.">
    
    <link rel="alternate" type="application/rss+xml" href="blog/feed.rss" title="bkardell.com/blog rss feed">
    <title>Almostness</title>
    <style>.captioned-image {
    background-color: #eaeaea;
    display: block;
    overflow: hidden;
    padding: 1rem;
    text-align: center;
    font-style: italic;
}

.captioned-image.p-attached {
    width: 40%;
    display: inline-block;
    margin: 0 1rem 2rem 1rem;
}

section > .captioned-image.p-attached {
    margin-top: 1.5rem; /* correct for heading size*/
}

 pre { overflow-x: auto }

.captioned-image.p-attached.p-attached-left {
    float: left;
}

.captioned-image.p-attached.p-attached-right {
    float: right;
}

.captioned-image.p-attached + * + * {
    clear: both;
    margin-top: 2rem;
}


.captioned-image img, .captioned-image video {
    display: block;
    max-width: 100%;
    margin: 0 auto 1em auto;
}
.source {
    font-style: italic;
}
body {
    display: flex;
    font: 1em "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-weight: 300;
    line-height: 1.625;
}
h1 { margin: 0.5rem; }
code-format {
    border-left: 0.5rem solid rgba(123,115,209,0.35);
    display: block;
    padding: 0.5rem;
    margin-bottom: 1rem;
}

contextual-heading {
    display: block;
    margin-top: 2rem;
}

[aria-level="1"] {
    color: #43686b;
    font-size: 1.45rem;
}
[aria-level="2"] {
    color: #856363;
    font-size: 1.35rem;
}
[aria-level="3"] {
    color: #856363;
    font-size: 1.25rem;
}
[aria-level="4"] {
    color: #856363;
    font-size: 1.2rem;
}
[aria-level="5"], [aria-level="6"] {
    color: #667496;
    font-size: 1.1rem;
    font-weight: bolder;
}
.posted-on {
    font-style: italic;
    font-size: 0.8rem;
    text-align: right;
    margin-bottom: 1rem;
}

ul, li {
    margin: 0.5rem;
    text-align: left;
}
header {
    padding-top: 1rem;
    padding-right: 2rem;
    background-color: #fbf5e9;
}
.tagline {
    font-style: italic;
    text-align: center;
}

[tag-esc] {
    color: maroon;
    font-family: Courier, "Lucida Console", monospace;
}

[tag-esc]::before {
    content: '<';
}

[tag-esc]::after {
    content: '>';
}

main {
    min-width: 50%;
    width: 80%;
    padding: 1rem;
}
header .title {
    background-color: rgba(123,115,209,0.35);
    padding: 0.3rem;
    padding-left: 0.25rem;
    font-weight: bolder;
    font-size: 0.9rem;
    border-left: 1rem solid #999298;
}

header .profile {
    width: 50%;
    margin: 1rem 25%;
}

header .title + nav {
    font-size: 0.9rem;
}

header .blurb {
    font-size: 0.75rem;
    text-align: center;
}
header .name {
    text-align: center;
    font-size: xx-large;
}
.segue {
    font-style: italic;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
}
[for="aboutMeToggle"] {
    display: none;
}
/* this needs rethinking, it wants a selector like 'not flow content' */
article>*:not(contextual-heading,a), section>*:not(contextual-heading,a) {
    margin-left: 0.45rem;
}

blockquote {
  font-family: serif;
  background: #f9f9f9;
  border-left: 10px solid #ccc;
  margin: 1.5em 10px;
  padding: 0.5em 10px;
}
blockquote:before {
  color: #ccc;
  content: open-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-right: 0.25em;
  vertical-align: -0.4em;
}

blockquote:after {
  color: #ccc;
  content: close-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-left: 0.25em;
  vertical-align: -0.4em;
}


@media (max-width: 800px){
    body {
        flex-direction: column;
    }
    header {
        border-bottom: 1px solid #afafff;
    }

    .captioned-image.p-attached {
        width: 100%;
        margin: 1rem 0;
    }

    .captioned-image.p-attached.p-attached-left,
    .captioned-image.p-attached.p-attached-right {
        float: none;
    }

    [for="aboutMeToggle"] {
        background-color: #675e5e;
        color: white;
        padding: 0.25rem;
        padding-left: 0.5rem;
        display: block;
        border-left: 1rem solid black;
    }
    #aboutMeToggle:focus + [for="aboutMeToggle"]{
        outline: 4px solid #c6ddf2;
    }

    #aboutMeToggle:checked ~ header {
        display: none;
    }

    header li { display: inline; margin-left: -0.5em; }
    header .blurb li::after { content: '; '; }
    header  nav li {
        display: inline-block;
        margin-left: 0.35rem;
        margin-right: 0.35rem;
    }
    header .title {
        width: 100%;
    }
    main li .source { display: block; }

}</style>
    <style>
      .captioned-image { font-size: 0.9rem; }
      .thanksTo { font-style: italic; font-size: 0.8rem; }
    </style>
    <script>
      var activateOptional = function (media) {
        var source = media.getAttribute('data-src'),
            temp,
            container = media.parentElement;

          if (media.nextSibling && media.nextSibling.matches) {
            if (media.nextSibling.matches('.clickToSee')) {
              media.parentElement.removeChild(media.nextSibling);
            }
          }

          if (media.tagName === 'VIDEO') {
            temp = document.createElement('video')
            temp.setAttribute('autoplay','')
            temp.setAttribute('controls','')
            temp.setAttribute('loop','')
            temp.innerHTML = '<source src="' + source + '.webm" type="video/webm">'
                    + '<source src="' + source + '.mp4" type="video/mp4">';
            media.parentElement.replaceChild(temp, media);
            setTimeout(function () {
              temp.play()
            }, 0);
          } else {
            media.src = media.getAttribute('data-src');
          }

          container.classList.add('active');
      }
    </script>
  </head>
  <body>
    <input id="aboutMeToggle" class="sr-only" type="checkbox" checked="">
<label for="aboutMeToggle">Toggle author information</label>
<header>
    <div class="name">
        Brian Kardell
    </div>
    <img class="profile" src="/profile.jpg" alt="">
    <div class="tagline"><a href="/">Betterifying the Web</a></div>
    <div class="blurb">
        <ul>
            <li>Sr Front-End Engineer at Apollo Group, Inc</li>
            <li>Original Co-author/Co-signer of The Extensible Web Manifesto</li>
            <li>Co-Founder/Chair, W3C Extensible Web CG</li>
            <li>Member, W3C (The JS Foundation)</li>
            <li>Co-author of HitchJS</li>
            <li>Blogger</li>
            <li>Art, Science &amp; History Lover</li>
            <li>Standards Geek</li>
        </ul>
    </div>
    <div class="title">Follow Me On...</div>
    <nav>
        <ul>
            <li><a rel="me" href="https://briankardell.wordpress.com">Wordpress</a></li>
            <li><a rel="me" href="https://medium.com/@briankardell">Medium</a></li>
            <li><a rel="me" href="https://twitter.com/briankardell">Twitter</a></li>
            <li><a rel="me" href="https://github.com/bkardell/">Github</a></li>
            <li><a rel="me" href="https://codepen.io/bkardell">Codepen</a></li>
            <li><a rel="me" href="https://www.linkedin.com/in/brian-kardell-08a4264">LinkedIn</a></li>
            <li><a rel="me" href="https://www.instagram.com/kardellbrian">Instagram (for
art)</a></li>
            <li><a rel="me" href="http://fineartamerica.com/profiles/brian-kardell?">Fine Art
America (art for sale)</a></li>
        </ul>
    </nav>
</header>
    <main><div class="posted-on">Posted on null</div><article class="sectioning">
	<contextual-heading role="heading" aria-level="1">Almostness</contextual-heading>
	<style>
	.note {
        background-color: rgba(255,255,0,0.24);
        padding: 1rem;
        font-style: italic;
    }
    .note::before {
        content: 'Note';
        font-size: 0.8rem;
        background-color: black;
        color: white;
        padding: 0.25rem;
        margin-right: 0.5rem;
    }
	</style>
	<p class="segue">
		I'd like to discuss a thing that's been weighing kind of heavily on my mind for a few years now with regard to evolving "HTML". 
	</p>

	<p>
		Today, we say that the potential path to standardization of new elements lies in experimentation and proving need and use.  Custom Elements provide a way to plug into the platform for this purpose and simple things like an agreement around dasherized tag name mean that multiple things that aren't quite custom elements can even share the same markup.  
	</p>

	<p>
		In theory, this allows us to look at "slang" and treat the future of markup more like adding words to a dictionary, based on some kind of science.
	</p>

	<p>
		But, the truth is, while there has been some discussion, we have actually said very little, concretely, about what that really means or how it will work in practice. 
	</p>

	<p>
		So far, I think that part of the reason there hasn't been a lot of pressure to do so is because we're just really starting this process and there's just much work happening "beneath" - in excavating and explaining the platform to make that proposition better.  
	</p>

	<p>
		Another reason, which I think is important, is that we don't actually know.  We've never done this before.  
	</p>


	<p>
		To many, "success" seems to mean that it is part of HTML and implemented by all browsers.  As I have said, we've mostly articulated that the way to reach this is through experimenting with "slang" and proving that you've got things figured out and that it is useful by getting significant enough use.  This seems to beg a few follow up questions though.
	</p>

	<p>
		Let's take, as an example for discussion, something exiting like the <code tag-esc="">progress</code> element.  Imagine that it didn't exist and that we were proposing it as the <code tag-esc="">x-progress</code> element, and it started getting widely used.
	</p>
	<p>
		At what point of use do we start asking ourselves if this belongs in HTML proper?  How would we know and actually even measure this?  And then, once we've actually asked ourselves about the question of inclusion into HTML --- what do we do with that answer eithr way?
	</p>

	<section class="sectioning">
		<contextual-heading role="heading" aria-level="2">At what point?</contextual-heading>
		<p>
			This is tricky and it probably seems a little like putting the cart before the horse to ask at what point we start paying attention before talking about what you're measuing in the first place, but there's a reason behind it, so stick with me...
		</p>

		<p>
			According to the HTTP Archive, the actually already standard <code tag-esc="">progress</code> element is used by just 0.04% of pages in its dataset.  That's pretty low, actually.  It's only about a third as used as the long defunct and widely disregarded <code tag-esc="">blink</code> tag, and the <code tag-esc="">font</code> elment shows over 200 times the use. 
		</p>

		<p>
			But why?  Are sites really that bad?  Well, I think that this has a lot to do with how and what you are measuing. I'll make the case in a minute that if we aren't careful, the HTTP Archive isn't going to give us unbiased data. I think it's going to be tricky to get at a "real" number that we can all agree on but for the sake of argument, let's assume that that is what this is.  Does this element advance?  
		</p>
	</section>



	<section class="sectioning">
		<contextual-heading role="heading" aria-level="2">Measuring</contextual-heading>
		<p>
			Ok, so, how do we get at a number in the first place?  As I said, I think that simply looking at the HTTP Archive queries as they exist today might create a problematic bias.  Here's why...
		</p>
		<p>
			As I understand it, the HTTP Archive's dataset is not a dataset of the whole Web.  It is rather the million or so "top" sites by views and and then, effectively, what it can itself request and crawl.  In the case of measuing element use, this could matter pretty significantly.
		</p>
		<p>
			For example, our <code tag-esc="">progress</code> frequently not on the page when it is loaded and might require substantial user interaction to suddenly appear.  That's because it is more likely to be used in an 'appy' context.  These contexts are more ephemeral and harder for the HTTP archive to reach - often requiring a login, for example.  They also frequently could be counted as 1 URL.  By contrast, if you look only at URLs, the vast majority of them are 'content pages' that can be authored by pretty much anyone with a tool like a CMS.
		</p>
		<p>
			The very nature of this seems to play heavily toward a certain 'kind' of element.  The most basic and common building blocks will get an astonishingly high count.  Something made with a popular but kind of terrible CMS can get a big boost.  And all of them create <em>content</em> which drives views.  In other words: The thing I use that needs <code tag-esc="">progress</code> might be super important to me, I might keep that tab open all day.  But, during the same day I will read 50 articles created by a rich text editor which have lots of simpler elements that are easier to relate to content.
		</p>

		<p>
			Another way to measure might be browser telemetry.  Chrome, for example, collects data about the elements in the page and feeds some of that back - and it does include custom elements.  This might be better, but we have to be careful to somehow coalese this data too to avoid other hiccups.  For example, there are sites/apps which are keenly important and widely used for specific purposes who, for various reasons, people avoid certain browsers.  This is bad for the Web, but it isn't always nefarious or for equal reasons.
		</p>
		<p>
			For example, telemetry data for Firefox, for example, would have for a long time seriously under-reported how important video was for me, saying it was near 0 - but that would be entirely untrue. I almost always have videos playing - but I quickly learned that Firefox wouldn't play a lot of videos and consciously would view sites with videos in Chrome.  
		</p>


		<p>
			So... Could a thing like <code tag-esc="">progress</code> arise today - and, if not, is that a feature, or a problem.
		</p>
		<p>
			So, I love the HTTP Archive, it's wonderful and useful but I think we have to be a little careful how we look at it in this context and see if we can feather that out somehow - to get at things.
		</p>




First, it's worth noting that the data sets there are based on popularity of traffic.  It's very tempting to say that that is a good thing, but maybe in it's purest form, unchecked, it isn't.  

		<p>How wide is wide?  Does it matter what it is?</p>

		<p>
			If you think about all of the ever growing list of things that the Web is used for, and then begin to segment out their commonalities, you will inevitably find better words than 'paragraph', 'heading' and 'section' which can say many more subtle, but important things that potentially make many things better in any number of ways. 
		</p>
		<p>  
			It's <em>very</em> likely that many custom element implementations of those words will find a considerable amount of success on the Web.   They might even get popular enough that search engines begin to be able to use them usefully, for example.
		</p>
		<p>
			Does that automatically mean they should become part of HTML?  Probably not.
		</p> 

		<p>
			Consider, for example, elements that get created around social media like <code tag-esc="">amp-twitter</code>. I don't know how widely used it is, but it's entirely possible that it hits just the sweet spot that makes it really easy to do something that everyone wants to do.  What would we do with that?  Anything?
		</p>

		<p>
			In some cases, some might argue that there <em>is</em> something potentially standardizable there which is just not that thing, and that we should begin the process of determining, building and testing, for example, a way to 'favorite' something.  Someone could try that, sure, and maybe they even prove that they can ultimately work through all of the evolutionary churn of new ideas and semantic knots and manage to popularize a more generic "reaction" element or something.... In the end, my question remains effectively the same:  What would we do with that?  Do we really think that that is part of HTML itself?
		</p>
		<p>
			I'm going to go out on a limb and suggest that there will, at a minimum, be times when we decide they do not.  In other words, they are kind of domain specific.  
		</p>
		<p>
			To be entirely honest, I'm not entirely sure what is and isn't reasonable there.
		</p><p>
			If you squint at it one way, they seem like a fairly generic thing that you could totally imagine in HTML.


			</p><p>
				It's <em>very</em> likely that many custom element implementations of those words will f,ind a considerable amount of success on the Web and yet will not be considered for inclusion in HTML.  Some things might just not fit entirely.  Here, one can imagine a button for a popular social media site,  

	</p></section>

</article></main>

  
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-88027178-1', 'auto');
    ga('send', 'pageview');
  </script>

  <script>
    Array.prototype.slice.call(document.querySelectorAll('.optional [data-src]')).forEach(function (optional) {
      var prefs = window.localStorage.downloadsPrefs,
          clickToSee;
      if (prefs === 'true') {
        activateOptional(optional);
      } else {
        clickToSee = document.createElement('div');
        clickToSee.classList.add('clickToSee')
        clickToSee.innerHTML = '<button>Click to see media</button>';
        clickToSee.style.textAlign = 'center';
        clickToSee.style.border = 'none';
        optional.parentElement.insertBefore(clickToSee, optional.nextSibling);
        clickToSee.firstElementChild.addEventListener('click', function () {
          activateOptional(optional);
        })
      }

    })
  </script>

</body></html>