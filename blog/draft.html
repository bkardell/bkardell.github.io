<html lang="en" resource-type="blogpost"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@briankardell">
    <meta name="twitter:creator" content="@briankardell">
    <meta name="twitter:title" content="TBD">
    <meta name="twitter:description" content="It's become a fairly regular occurence for me to encounter someone on social media expressing some kind of frustration with Custom Elements.  As someone involved in many discussion">
    
    <link rel="alternate" type="application/rss+xml" href="blog/feed.rss" title="bkardell.com/blog rss feed">
    <title>TBD</title>
    <style>.captioned-image {
    background-color: #eaeaea;
    display: block;
    overflow: hidden;
    padding: 1rem;
    text-align: center;
    font-style: italic;
}

.captioned-image.p-attached {
    width: 40%;
    display: inline-block;
    margin: 0 1rem 2rem 1rem;
}

section > .captioned-image.p-attached {
    margin-top: 1.5rem; /* correct for heading size*/
}

 pre { overflow-x: auto }

.captioned-image.p-attached.p-attached-left {
    float: left;
}

.captioned-image.p-attached.p-attached-right {
    float: right;
}

.captioned-image.p-attached + * + * {
    clear: both;
    margin-top: 2rem;
}


.captioned-image img, .captioned-image video {
    display: block;
    max-width: 100%;
    margin: 0 auto 1em auto;
}
.source {
    font-style: italic;
}
body {
    display: flex;
    font: 1em "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-weight: 300;
    line-height: 1.625;
}
h1 { margin: 0.5rem; }
code-format {
    border-left: 0.5rem solid rgba(123,115,209,0.35);
    display: block;
    padding: 0.5rem;
    margin-bottom: 1rem;
}

contextual-heading {
    display: block;
    margin-top: 2rem;
}

[aria-level="1"] {
    color: #43686b;
    font-size: 1.45rem;
}
[aria-level="2"] {
    color: #856363;
    font-size: 1.35rem;
}
[aria-level="3"] {
    color: #856363;
    font-size: 1.25rem;
}
[aria-level="4"] {
    color: #856363;
    font-size: 1.2rem;
}
[aria-level="5"], [aria-level="6"] {
    color: #667496;
    font-size: 1.1rem;
    font-weight: bolder;
}
.posted-on {
    font-style: italic;
    font-size: 0.8rem;
    text-align: right;
    margin-bottom: 1rem;
}

ul, li {
    margin: 0.5rem;
    text-align: left;
}
header {
    padding-top: 1rem;
    padding-right: 2rem;
    background-color: #fbf5e9;
}
.tagline {
    font-style: italic;
    text-align: center;
}

[tag-esc] {
    color: maroon;
    font-family: Courier, "Lucida Console", monospace;
}

[tag-esc]::before {
    content: '<';
}

[tag-esc]::after {
    content: '>';
}

main {
    min-width: 50%;
    width: 80%;
    padding: 1rem;
}
header .title {
    background-color: rgba(123,115,209,0.35);
    padding: 0.3rem;
    padding-left: 0.25rem;
    font-weight: bolder;
    font-size: 0.9rem;
    border-left: 1rem solid #999298;
}

header .profile {
    width: 50%;
    margin: 1rem 25%;
}

header .title + nav {
    font-size: 0.9rem;
}

header .blurb {
    font-size: 0.75rem;
    text-align: center;
}
header .name {
    text-align: center;
    font-size: xx-large;
}
.segue {
    font-style: italic;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
}
[for="aboutMeToggle"] {
    display: none;
}
/* this needs rethinking, it wants a selector like 'not flow content' */
article>*:not(contextual-heading,a), section>*:not(contextual-heading,a) {
    margin-left: 0.45rem;
}

blockquote {
  font-family: serif;
  background: #f9f9f9;
  border-left: 10px solid #ccc;
  margin: 1.5em 10px;
  padding: 0.5em 10px;
}
blockquote:before {
  color: #ccc;
  content: open-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-right: 0.25em;
  vertical-align: -0.4em;
}

blockquote:after {
  color: #ccc;
  content: close-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-left: 0.25em;
  vertical-align: -0.4em;
}


@media (max-width: 800px){
    body {
        flex-direction: column;
    }
    header {
        border-bottom: 1px solid #afafff;
    }

    .captioned-image.p-attached {
        width: 100%;
        margin: 1rem 0;
    }

    .captioned-image.p-attached.p-attached-left,
    .captioned-image.p-attached.p-attached-right {
        float: none;
    }

    [for="aboutMeToggle"] {
        background-color: #675e5e;
        color: white;
        padding: 0.25rem;
        padding-left: 0.5rem;
        display: block;
        border-left: 1rem solid black;
    }
    #aboutMeToggle:focus + [for="aboutMeToggle"]{
        outline: 4px solid #c6ddf2;
    }

    #aboutMeToggle:checked ~ header {
        display: none;
    }

    header li { display: inline; margin-left: -0.5em; }
    header .blurb li::after { content: '; '; }
    header  nav li {
        display: inline-block;
        margin-left: 0.35rem;
        margin-right: 0.35rem;
    }
    header .title {
        width: 100%;
    }
    main li .source { display: block; }

}</style>
    <style>
      .captioned-image { font-size: 0.9rem; }
      .thanksTo { font-style: italic; font-size: 0.8rem; }
    </style>
    <script>
      var activateOptional = function (media) {
        var source = media.getAttribute('data-src'),
            temp,
            container = media.parentElement;

          if (media.nextSibling && media.nextSibling.matches) {
            if (media.nextSibling.matches('.clickToSee')) {
              media.parentElement.removeChild(media.nextSibling);
            }
          }

          if (media.tagName === 'VIDEO') {
            temp = document.createElement('video')
            temp.setAttribute('autoplay','')
            temp.setAttribute('controls','')
            temp.setAttribute('loop','')
            temp.innerHTML = '<source src="' + source + '.webm" type="video/webm">'
                    + '<source src="' + source + '.mp4" type="video/mp4">';
            media.parentElement.replaceChild(temp, media);
            setTimeout(function () {
              temp.play()
            }, 0);
          } else {
            media.src = media.getAttribute('data-src');
          }

          container.classList.add('active');
      }
    </script>
  </head>
  <body>
    <input id="aboutMeToggle" class="sr-only" type="checkbox" checked="">
<label for="aboutMeToggle">Toggle author information</label>
<header>
    <div class="name">
        Brian Kardell
    </div>
    <img class="profile" src="/profile.jpg" alt="">
    <div class="tagline"><a href="/">Betterifying the Web</a></div>
    <div class="blurb">
        <ul>
            <li>Sr Front-End Engineer at Apollo Group, Inc</li>
            <li>Original Co-author/Co-signer of The Extensible Web Manifesto</li>
            <li>Co-Founder/Chair, W3C Extensible Web CG</li>
            <li>Member, W3C (The JS Foundation)</li>
            <li>Co-author of HitchJS</li>
            <li>Blogger</li>
            <li>Art, Science &amp; History Lover</li>
            <li>Standards Geek</li>
        </ul>
    </div>
    <div class="title">Follow Me On...</div>
    <nav>
        <ul>
            <li><a rel="me" href="https://briankardell.wordpress.com">Wordpress</a></li>
            <li><a rel="me" href="https://medium.com/@briankardell">Medium</a></li>
            <li><a rel="me" href="https://twitter.com/briankardell">Twitter</a></li>
            <li><a rel="me" href="https://github.com/bkardell/">Github</a></li>
            <li><a rel="me" href="https://codepen.io/bkardell">Codepen</a></li>
            <li><a rel="me" href="https://www.linkedin.com/in/brian-kardell-08a4264">LinkedIn</a></li>
            <li><a rel="me" href="https://www.instagram.com/kardellbrian">Instagram (for
art)</a></li>
            <li><a rel="me" href="http://fineartamerica.com/profiles/brian-kardell?">Fine Art
America (art for sale)</a></li>
        </ul>
    </nav>
</header>
    <main><div class="posted-on">Posted on null</div><article class="sectioning">
	<!-- bkardell-prefs></bkardell-prefs -->
	<style>
		.tldr em {
			display: none; color: rebeccapurple;
		}
	</style>
  	<script src="../prism.js"></script>
  	<link rel="stylesheet" href="../prism.css">
	<contextual-heading role="heading" aria-level="1">TBD</contextual-heading>
	<p class="segue">It's become a fairly regular occurence for me to encounter someone on social media expressing some kind of frustration with Custom Elements.  As someone involved in many discussions during the evolution and a user of them myself from the beginning, I know that they aren't perfect and I really want them to be better, so I frequently ask questions.  Too often, a number of things get inextricably connected and, I think, somewhat misunderstood, so I thought I'd sit down and write about it.  <!-- That, and walruses. --></p>

	<section class="sectioning">
		<contextual-heading role="heading" aria-level="2">Imagine</contextual-heading>
		<p>Imagine this hypothetical example:  My design team wants a shiny, modern ux for a 'stars' oriented rating component for attaching to items.  It shows N stars, and they are initially 'hollow'.  The user can choose to record a rating by selecting 1â€¦N stars.  There is a little UX on hover that lights up stars as you mouse over them and once selected, the stars are filled with a fill color (for example, gold) indicating my recorded rating.</p>

		<p>As an end-user, you've bumped into these before, I'm sure.  As a developer, if you need one of thse, a quick google search will turn you up large numbers of them that you can use today.</p>

		<p>Custom elements is supposed to help us with "this" problem. Thus, once given custom elements, a number of smart people have, in good faith, decided "let me sit down make a really good element" only to find, for example, making our <code tag-esc="">star-ratings</code> element accessible is precisely as difficult as it has always been.  Also, it requires JavaScript.  As we all know, JavaScript is imperative.  Imperative code is less resilient and means introducing a new problem: your whole page can crash and burn and give you nothing but a white screen for lots of different reasons.  All the things, as we know should use progressive enhancement.</p>

		<p>As a number of those people have now pointed out, there are already written drafts or specs that would allow us to extend native elements, even to use a new attribute <em>is="..."</em> to say that this native element is actually ultimate intended to be a "more perfect" version of that element in the event that it can.</p>


		<p>Imagine then, that we could just realize that this seems a lot like radio buttons and, functionally radio buttons would 'suffice'.  Then, perhaps we could just write HTML and say that this radio button <em>is="star-rating"</em> and, wow, this would really seem to help all of the problems disussed so far.  If only browser vendors would get their shit together and implement it that way then things would be Super Greatâ„¢</p>

	</section>


	<section class="sectioning">
		<contextual-heading role="heading" aria-level="2">Talk of many things...</contextual-heading>
		<!-- div class="captioned-image optional p-attached p-attached-right">
			<img data-src="http://www.jabberwocky.com/carroll/pics/glass21.gif" alt="">
				"The time has come," the Walrus said,<br>
				"To talk of many things:<br>
				Of shoes--and ships--and sealing-wax--<br>
				Of cabbages--and kings--<br>
				And why the sea is boiling hot--<br>
				And whether pigs have wings."
		</div -->

		<p>This is where the conversations I have usually begin because while I'm very keen to learn about things I may very well not "see" yet, I see much confusion in many of the examples that I hear presented and we frequently wind up going around in circles. In order to have more focused and valuable conversation then, I'd like to offer some additional perspective and attempt to untangle a number of things that don't seem to be exactly self-evident.  There's much to discuss to accomplish this, but in this piece, I'll attempt to explain why these spec discrepancies exist - what exactly is "the hold up" with just implementing those things already and, I hope, why I don't (currently) share this view already.</p>

  	<section class="sectioning">
  		<contextual-heading role="heading" aria-level="3">Accessibility Magic</contextual-heading>

  		<p>As I said, there is an increasingly popular stateent that if we were to extend a built-in element, accessibility would be easy.  The impression would seem to be that it would be "automatically accessible" by way of simple inheritance from the native element from which is extends. However, this seems to be, as far as I can tell, <em>almost never true</em>.  Here's why:</p>

		<p>There's just not a lot of great reasons to want to "improve" a native element that don't impact the DOM.  To change the user experience, we'll almost certainly have to create some new DOM and CSS to make our shitty looking radio buttons look like something new.  If not, you could just use the native element itself.  As soon as you add some new DOM: Viola, you've lost all that yummy accessible goodness.  To fix the accessibility issues that you've just created with that assumption, you'd need to add keyboard handling, click handling, focusability and so on.  In fact, you'll wind up dealing with just about every accessibility feature that you would have if you hadn't extended that element in the first place.</p>

		<p>Why? Because currently, all that accessibility goodness it's inextricably wound up in the DOM that you just changed.</p>

  		<p>You shouldn't take my word for this if you find it surprising:  You can read the specs, or even try it for yourself (get an older version of Chrome or possibly <a href="https://github.com/WebReflection/document-register-element" target="_blank">Andrea Giammarchi's polyfill</a>).  Or, you could simply look to demos done during the time when we thought this might actually ship.  My friend Alice Boxhall at Google did a few which seem to illustrate pretty much exactly this.</p>

		<p>So, there's no substantially valuable accessibility magic as currently specified.  But there <em>would</em> be progressive enahncement at least, right? Wellllllll...</p>
	</section>

	<section class="sectioning">
		<contextual-heading role="heading" aria-level="3">The cannonical problem</contextual-heading>
		<p>Consider for a moment the original cannonical problem description for progressive enhancement: Our design calls for a nice button that simply says "Click to print".</p>

		<p>Once upon a time not all browsers understood the button element and not all browsers supported the print function, or even JavaScript at all.  If you simply wrote the HTML and JavaScript that you actually wanted, some users would be presented with a very confusing interface:  Perhaps some non-button looking text in the page that says "Click to print" or a perhaps button that won't actually do anything at all. That would be Very Badâ„¢</p>

		<section class="sectioning">
			<contextual-heading role="heading" aria-level="4">Graceful Degradation</contextual-heading>
			<p>The way we dealt with this at one point in time was called "Graceful degradation".  One way to think about this is: <em>When you can't give them what I really wanted to, at least don't leave them in a complete lurch.  At least explain why it's fucked up or how to remedy it or something.</em></p>

			<p>Now, in practice, this often this meant something very simple indeed: using a <code tag-esc="">noscript</code> tag that said "this interface requires a JavaScript enabled browser and you should download one of those if you really expect it to work... Everyone else can just accept that some things will be f'ed because of them, not because of me."</p>

			<p>However, later, it sometimes involved the idea carefully arranging HTML code a certain way so that if your browser didn't understand some outer tag, the tag inside it would instead do something lesser.</p>
		</section>
		<section class="sectioning">
			<contextual-heading role="heading" aria-level="4">Progressive Enhancement</contextual-heading>
			<p>Progressive enhancement came along and simply suggested that we <em>invert the mental model of design</em>: Instead of starting with our ideal design and working "down", start with something basic and widely supported and work "up".</p>

			<p>So, in the case of the cannonical example, progressive enhancement would suggest that we start with something basic.  Perhaps start instead with a simple paragraph saying "you can print this for your records".  From day 1, everyone's browser has been able to render a paragraph.  Given that text, most people can then figure out how to print.  Conditionally then, determine if they can do more and then do.  Perhaps you might replace the paragraph with the nice "Click to print" button that you really wanted instead, or perhaps you could empty the paragraph and have it contain our functional button instead of the text.</p>
		</section>

		<p>So why go through this all this recap?  Well, really simply so I can point out two things that appear to be non-immediately obvious...</p>

		<p>First, the fact that some people used the "fall back" approach in the days of "graceful degradation," seems to have led many people associate code that "looks like that" as being "graceful degradation" also pronounced "very bad".  However, that's a misunderstanding.  There is no way to look at this declarative code and determine whether it "falls back" or "enhances forward". That isn't what the distinction was about.</p>

		<p>The second reason to recap is to point out that progressive enhancement has never been an <em>is-a</em> relationship (extension).  It's always been a "here's a thing you can definitely do and, if you can do more, here's what that is (usually through JavaScript)".  Consider carefully that it either began as a paragraph <em>containing</em> some text and became a paragraph <em>containing</em> a functional button, or it began as a paragraph and <em>became instead</em> a functional print button.  The "ness" of that thing never changed.</p>

		<p>This seems like a subtle distinction, but it matters.  We wouldn't expect to say <code tag-esc="">p is="button"</code>, because that is of course nonsense: We know that however we spell it out, these two things are just way too different.  Note that the simple fact that an author <em>could</em> express that though means introducing a whole lot of new things we have to account for.</p>

		<section class="sectioning">
			<contextual-heading role="heading" aria-level="4">is="it tho"?</contextual-heading>
			<p>While this seems "really different" and contrived as an example, I would posit that actually this is <em>frequently precidely</em> what we are asking for without realizing it.  What we want actually involves new DOM.  It's not, in terms available to us today, actually just a specialized version of something, it's really often a different kind of relationship.</p>

			<p>In 1987 Barbara Liskov presented a keynote address called "Data abstraction and hierarchy" which talks about how we model things and our desire to organize things into heirarchies that <em>extend</em> and <em>inherit</em>.  She then goes on to illustrate how that tends to cause numerous sorts of problems.  More importantly, she begins to explain how we might avoid those problems and the basic concept she describes is sometimes known as the "Liskov substitution principle" or "LSP" or even just "substitutionality".  In a way, what this says is that metaphor is shitty.  Your mind can trip you up and make you model something poorly.  If you do, then rather than being helpful, the system will fight you.</p>

			<p>Fortunately 'is-a' isn't the only kind of relationship we have for modeling problems.  The often cited Gang of Four <em>Design Patterns</em> reiterates on Liskov's work and provides the simple observation "composition over inheritance".  That is: Composing features through a <em>has-a</em> relationship is often a better way to go.</p>

			<p>The really interesting thing about that is that that's kind of where we are today: Absolutely nothing new is required in order to follow the self-same progressive enhancement patterns that we've been using all along and gain pretty much the same values we would with <code>is="..."</code> through composition rather than inheritance.</p>

			<pre><code class="language-html">&lt;!-- instead of writing this --&gt;
&lt;input type="radio" is="x-radio"&gt;

&lt;!-- you write this --&gt;
&lt;x-radio&gt;
    &lt;input type="radio"&gt;
&lt;/x-radio&gt;</code></pre>

			<p>Functionally, they are equivalent in pretty much every useful way: Form serialization, validation, etc - and you have to change and proxy precisely as much in either model for the sake of accessibility, depending on just what DOM what you change.  But we need nothing new to do it, and it opens no significantly complex new challenges for us to answer.</p>
		</section>

		<section class="sectioning">
			<contextual-heading role="heading" aria-level="4">But I don't see people doing that... Why?</contextual-heading>
			<p>Well, part of it may be that people just aren't thinking about it that way.  For example, I have developed several custom elements that work precisely like this.  But that's definitely not the entire story.  The truth is because it's actually harder than most of our contrived examples would like to admit and it is tough to strike a good balance.</p>

			<p>Let's go back to our "Hypothetical Problem #1" again and look at it "in real life".  We've been discussing a lot about extending a radio button, but that is, in fact, kind of a red herring.  This component is, more realistically, a form.  A form is the thing you'd likely have to <em>is="..."</em> and that would require the form to wire up whatever it needed to be a good accessible native interface, including a fieldset with a legend and several labels linked to radio buttons that share the same name, etc.  As I said, we can do the same with composition and that would look something like:</p>

			<pre><code class="language-html">&lt;my-ratings&gt;
  &lt;form action="submitRating" method="POST"&gt;
    &lt;p class="average-rating"&gt;Average Rating: 4/5 stars&lt;/p&gt;
      &lt;fieldset&gt;
        &lt;legend&gt;How many stars would you rate this as?&lt;/legend&gt;
        &lt;label&gt;
          &lt;input type="radio" value="1" name="my-rating-1"&gt;
            1 star
        &lt;/label&gt;

        &lt;label&gt;
          &lt;input type="radio" value="2" name="my-rating-1"&gt;
            2 stars
        &lt;/label&gt;

        &lt;label&gt;
          &lt;input type="radio" value="3" name="my-rating-1"&gt;
          3 stars
        &lt;/label&gt;

        &lt;label&gt;
            &lt;input type="radio" value="4" name="my-rating-1"&gt;
            4 stars
        &lt;/label&gt;
        &lt;label&gt;
            &lt;input type="radio" value="5" name="my-rating-1"&gt;
            5 stars
        &lt;/label&gt;
    &lt;/fieldset&gt;
  &lt;/form&gt;
&lt;/my-ratings&gt;</code></pre>

	<p>Alternatively, what you see frequently instead is something like:</p>

	<pre><code class="language-html">&lt;my-ratings&gt;&lt;/my-ratings&gt;</code></pre>

	<p>You can be unhappy about that, but the honest truth is, there are a lot of legitimate tradeoffs to consider there and the value proposition just always isn't there.  Which do you think that authors are more likely to want to actually adopt? Which are they less to get wrong? Which accomplishes other important engineering goals of abstraction/ecapsulation?  Having stability and the ability to centralize some of this stuff (like complex DOM formulas and difficult UX and accessibility challenges) is a pretty big win.  The "cost" is that that ratings component will be 'nothing' unless there's JavaScript, but - is that always bad?</p>

	<p>I don't think it is, for a number of reasons.  The first is, I don't think anything is too holy to question and the important thing is that we're asking good questions.  So why is it that you feel this really matters so much.  If the idea is "it's declarative and therefore analyzable and fault tolerant" well, this ticks that box.  By using an actual element rather than selectors or something and having a way to trace that back to implementations, we gain a way to analyze pages for common usages far beyond what we had before.  By drawing the line where it does, this also won't blow up your app, that particular thing will just cease to be there.  But guess what? Worse is true of partially loaded CSS and that happens too: But we're ok with that.  Finally, this doesn't have to be an all or nothing answer.  Some aspects of my application are kind of mission critical - in those, perhaps I am willing to take more pains in this approach.  A ratings widget, well, maybe it isn't so much.  I have to weigh the cost benefit of taking that approach.  It's costly to authors, it's costly for maintenance, it's frequently more costly across the wire, it frequently means I need multiple approaches: SSR, the ability to accept form encoding where I may have a JSON based RESTful service already in place and so on.  And also, guess what?  Even some native elements in some browsers are actually not accessible.  To address that, you'll need JavaScript.  Saying "I'm doing it this way so that it works for everyone" seems disingenuous to me if that leaves people out of the everyone.  At the end of the day, I have to justify: Why I am doing this and what does everyone gain?  It's not always simple nor black and white. Most of us, in fact, actually agree with that as a sentiment at some level: <a href="https://adactio.com/journal/4437">It depends</a>.</p>

	<section class="sectioning">
		<contextual-heading role="heading" aria-level="5">We can do better</contextual-heading>
		<p>Now, you may say that this seems like an unfortunate set of choices.  Yeah, probably.  You may say it shouldn't be as hard as it is to make good choices.  Agree!  You may say it would be nice if we didn't have to do all that proxying. Sure! Confirm.  The question is simply:  How do we get there?  And all I'm really offering is: It really doesn't seem like extension, as currently specified, anwser most of those questions any better than what Custom Elements is already shipping uniformly with. I'm suggesting that if you would have liked that, it kind of seems like you should like this.  If, after reading this, you still don't, I'd like to understand why.  What is the "thing" it gives you that is really super great and how does it not create a host of new problems along the way?</p>

		<p>So what <em>would solve those problem</em>? Yeah, that's why I'm asking the questions: <em>I don't know</em>.  What qualities should those answers have? <em>I'm kind of unsure</em>.  These are the conversations I'd like to have.</p>

		<p>One thing that definitely seems to come up a lot is: Why in the name of all that is holy are there so many toolkits with specialized things that seem a lot like native components and why are most of them so complicated and inaccessible: How can we fix that?</p>

		<p>Well, some people point to limits in styling.  Is that something we should tackle?  I kind of think so, but a lot of vendors are really hesitant to go too deply into that for a number of not actually bad reasons.  For example: Not all components render the same on all devices <em>on purpose</em> and this will continue.  If we box ourselves in too much, we limit our ability to adapt and experiement.  But this isn't even the whole problem perhaps because in a lot of cases it seems people want something only <em>kind of</em> like a native element and our ability to map it cleanly is really the problem.  In fact, this is a huge problem in the Web Platform.  The bolt-on nature of ARIA and it's ability to express way more unclear nonsense than correctness and only really mostly in terms of well known components is kind of really kind of problematic.  This isn't blasphemy, it's been a common and noted critique about why accessibility is still so problematic.  Should we deal with this?  Yes.  How? I don't know.  One really nifty solution to a number of these problems is a thing called AOM, or the Accessibility Object Model.  But you know what it requires?  JavaScript.  Is that OK with you?  It works for me, but our sensibilities may really differ and I'd like you to say something <em>now</em> before we've invested a few years into that if that's going to concern a lot of people.  If not that, what?  I don't know, I'm not sure how we solve these problems.</p>


		</section>



	</section>

</section></section></article></main>

  
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-88027178-1', 'auto');
    ga('send', 'pageview');
  </script>

  <script>
    Array.prototype.slice.call(document.querySelectorAll('.optional [data-src]')).forEach(function (optional) {
      var prefs = window.localStorage.downloadsPrefs,
          clickToSee;
      if (prefs === 'true') {
        activateOptional(optional);
      } else {
        clickToSee = document.createElement('div');
        clickToSee.classList.add('clickToSee')
        clickToSee.innerHTML = '<button>Click to see media</button>';
        clickToSee.style.textAlign = 'center';
        clickToSee.style.border = 'none';
        optional.parentElement.insertBefore(clickToSee, optional.nextSibling);
        clickToSee.firstElementChild.addEventListener('click', function () {
          activateOptional(optional);
        })
      }

    })
  </script>

</body></html>