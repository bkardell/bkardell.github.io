<html lang="en" resource-type="blogpost"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@briankardell">
    <meta name="twitter:creator" content="@briankardell">
    <meta name="twitter:title" content="Glass half :empty">
    <meta name="twitter:description" content="Standards are hard.  Recently, the CSS Working Group has been discussing some related things about selectors dealing with &quot;emptiness&quot;.  I have no concrete opinions but a lot of tho">
    
    <link rel="alternate" type="application/rss+xml" href="blog/feed.rss" title="bkardell.com/blog rss feed">
    <title>Glass half :empty</title>
    <style>.captioned-image {
    background-color: #eaeaea;
    display: block;
    overflow: hidden;
    padding: 1rem;
    text-align: center;
    font-style: italic;
}

.captioned-image.p-attached {
    width: 40%;
    display: inline-block;
    margin: 0 1rem 2rem 1rem;
}

section > .captioned-image.p-attached {
    margin-top: 1.5rem; /* correct for heading size*/
}

 pre { overflow-x: auto }

.captioned-image.p-attached.p-attached-left {
    float: left;
}

.captioned-image.p-attached.p-attached-right {
    float: right;
}

.captioned-image.p-attached + * + * {
    clear: both;
    margin-top: 2rem;
}


.captioned-image img, .captioned-image video {
    display: block;
    max-width: 100%;
    margin: 0 auto 1em auto;
}
.source {
    font-style: italic;
}
body {
    display: flex;
    font: 1em "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-weight: 300;
    line-height: 1.625;
}
h1 { margin: 0.5rem; }
code-format {
    border-left: 0.5rem solid rgba(123,115,209,0.35);
    display: block;
    padding: 0.5rem;
    margin-bottom: 1rem;
}

contextual-heading {
    display: block;
    margin-top: 2rem;
}

[aria-level="1"] {
    color: #43686b;
    font-size: 1.45rem;
}
[aria-level="2"] {
    color: #856363;
    font-size: 1.35rem;
}
[aria-level="3"] {
    color: #856363;
    font-size: 1.25rem;
}
[aria-level="4"] {
    color: #856363;
    font-size: 1.2rem;
}
[aria-level="5"], [aria-level="6"] {
    color: #667496;
    font-size: 1.1rem;
    font-weight: bolder;
}
.posted-on {
    font-style: italic;
    font-size: 0.8rem;
    text-align: right;
    margin-bottom: 1rem;
}

ul, li {
    margin: 0.5rem;
    text-align: left;
}
header {
    padding-top: 1rem;
    padding-right: 2rem;
    background-color: #fbf5e9;
}
.tagline {
    font-style: italic;
    text-align: center;
}

[tag-esc] {
    color: maroon;
    font-family: Courier, "Lucida Console", monospace;
}

[tag-esc]::before {
    content: '<';
}

[tag-esc]::after {
    content: '>';
}

main {
    min-width: 50%;
    width: 80%;
    padding: 1rem;
}
header .title {
    background-color: rgba(123,115,209,0.35);
    padding: 0.3rem;
    padding-left: 0.25rem;
    font-weight: bolder;
    font-size: 0.9rem;
    border-left: 1rem solid #999298;
}

header .profile {
    width: 50%;
    margin: 1rem 25%;
}

header .title + nav {
    font-size: 0.9rem;
}

header .blurb {
    font-size: 0.75rem;
    text-align: center;
}
header .name {
    text-align: center;
    font-size: xx-large;
}
.segue {
    font-style: italic;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
}
[for="aboutMeToggle"] {
    display: none;
}
/* this needs rethinking, it wants a selector like 'not flow content' */
article>*:not(contextual-heading,a), section>*:not(contextual-heading,a) {
    margin-left: 0.45rem;
}

blockquote {
  font-family: serif;
  background: #f9f9f9;
  border-left: 10px solid #ccc;
  margin: 1.5em 10px;
  padding: 0.5em 10px;
}
blockquote:before {
  color: #ccc;
  content: open-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-right: 0.25em;
  vertical-align: -0.4em;
}

blockquote:after {
  color: #ccc;
  content: close-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-left: 0.25em;
  vertical-align: -0.4em;
}


@media (max-width: 800px){
    body {
        flex-direction: column;
    }
    header {
        border-bottom: 1px solid #afafff;
    }

    .captioned-image.p-attached {
        width: 100%;
        margin: 1rem 0;
    }

    .captioned-image.p-attached.p-attached-left,
    .captioned-image.p-attached.p-attached-right {
        float: none;
    }

    [for="aboutMeToggle"] {
        background-color: #675e5e;
        color: white;
        padding: 0.25rem;
        padding-left: 0.5rem;
        display: block;
        border-left: 1rem solid black;
    }
    #aboutMeToggle:focus + [for="aboutMeToggle"]{
        outline: 4px solid #c6ddf2;
    }

    #aboutMeToggle:checked ~ header {
        display: none;
    }

    header li { display: inline; margin-left: -0.5em; }
    header .blurb li::after { content: '; '; }
    header  nav li {
        display: inline-block;
        margin-left: 0.35rem;
        margin-right: 0.35rem;
    }
    header .title {
        width: 100%;
    }
    main li .source { display: block; }

}</style>
    <style>
      .captioned-image { font-size: 0.9rem; }
      .thanksTo { font-style: italic; font-size: 0.8rem; }
    </style>
    <script>
      var activateOptional = function (media) {
        var source = media.getAttribute('data-src'),
            temp,
            container = media.parentElement;

          if (media.nextSibling && media.nextSibling.matches) {
            if (media.nextSibling.matches('.clickToSee')) {
              media.parentElement.removeChild(media.nextSibling);
            }
          }

          if (media.tagName === 'VIDEO') {
            temp = document.createElement('video')
            temp.setAttribute('autoplay','')
            temp.setAttribute('controls','')
            temp.setAttribute('loop','')
            temp.innerHTML = '<source src="' + source + '.webm" type="video/webm">'
                    + '<source src="' + source + '.mp4" type="video/mp4">';
            media.parentElement.replaceChild(temp, media);
            setTimeout(function () {
              temp.play()
            }, 0);
          } else {
            media.src = media.getAttribute('data-src');
          }

          container.classList.add('active');
      }
    </script>
  </head>
  <body>
    <input id="aboutMeToggle" class="sr-only" type="checkbox" checked="">
<label for="aboutMeToggle">Toggle author information</label>
<header>
    <div class="name">
        Brian Kardell
    </div>
    <img class="profile" src="/profile.jpg" alt="">
    <div class="tagline"><a href="/">Betterifying the Web</a></div>
    <div class="blurb">
        <ul>
            <li>Sr Front-End Engineer at Apollo Group, Inc</li>
            <li>Original Co-author/Co-signer of The Extensible Web Manifesto</li>
            <li>Co-Founder/Chair, W3C Extensible Web CG</li>
            <li>Member, W3C (The JS Foundation)</li>
            <li>Co-author of HitchJS</li>
            <li>Blogger</li>
            <li>Art, Science &amp; History Lover</li>
            <li>Standards Geek</li>
        </ul>
    </div>
    <div class="title">Follow Me On...</div>
    <nav>
        <ul>
            <li><a rel="me" href="https://briankardell.wordpress.com">Wordpress</a></li>
            <li><a rel="me" href="https://medium.com/@briankardell">Medium</a></li>
            <li><a rel="me" href="https://twitter.com/briankardell">Twitter</a></li>
            <li><a rel="me" href="https://github.com/bkardell/">Github</a></li>
            <li><a rel="me" href="https://codepen.io/bkardell">Codepen</a></li>
            <li><a rel="me" href="https://www.linkedin.com/in/brian-kardell-08a4264">LinkedIn</a></li>
            <li><a rel="me" href="https://www.instagram.com/kardellbrian">Instagram (for
art)</a></li>
            <li><a rel="me" href="http://fineartamerica.com/profiles/brian-kardell?">Fine Art
America (art for sale)</a></li>
        </ul>
    </nav>
</header>
    <main><div class="posted-on">Posted on null</div><article class="sectioning">
    <contextual-heading role="heading" aria-level="1">Glass half :empty</contextual-heading>
    <script src="../prism.js"></script>
    <link rel="stylesheet" href="../prism.css">
    <style>
    .note {
        background-color: rgba(255,255,0,0.24);
        padding: 1rem;
        font-style: italic;
    }
    .note::before {
        content: 'Note';
        font-size: 0.8rem;
        background-color: black;
        color: white;
        padding: 0.25rem;
        margin-right: 0.5rem;
    }
    .output {
        margin-left: 1rem;
        font-family: "Courier New", Courier, monospace
    }
    .spec-quote {
        display: block;
        margin: 1rem;
    }
    section {
        margin-left: 0.5rem;
    }
    ul {
        font-style: italic;
    }
    table {
        margin: 1rem auto;
        width: 80%;
    }
    th:nth-child(1),
    td:nth-child(1) {
        text-align: left;
    }
    th:nth-child(2),
    td:nth-child(2) {
        text-align: right;
        font-style: italic;
    }
    </style>
    <p class="segue">
        Standards are hard.  Recently, the CSS Working Group has been discussing some related things about selectors dealing with "emptiness".  I have no concrete opinions but a lot of thoughts and feedback I think it might be helpful to write down - and I'd like to hear yours after reading this as well...
    </p>
    <p>
        Here is a story that I have heard many times:  A developer has an actual problem that they are trying to solve.  The typical class, attribute or ID selectors aren't going to make this as elegant or as easy as they like and so they think to themselves "wow, you know, this seems like probably a really common thing. I wonder if there is <em>another</em> kind of selector that I could use here to make this much better?"  Sometimes, they get lucky, but frequently, the answer is "no".  But every once in a while, they find something that <em>sounds</em> very promising, only to find out that it doesn't actually do what they thought it did.  These were not the droids they were looking for.
    </p>
    <p>
       That feeling sucks.  When this happens, people sometimes blog. They sometimes complain on social media, or to someone at a meetup or conference.  They sometimes send an email to the www-style mailing list, and they sometimes open an issue on github or propose something new.  New discussions begin.
    </p>
    <p>
        The "trouble" here is two-fold.  First, standards move slowly - far more slowly than the projects that most of us are used to.  The fastest standardization is still measured in years before there is wide enough deployment that most devs can really be bothered to look into it.  When we fail to get it right, we basically get back in the very long queue to hopefully try again.  The second issue is the Web doesn't abide real, breaking changes.  We don't get to remove or repurpose the old thing except in rare/extreme circumstances.
    </p>
    <p>
        So, with this as a backdrop...
    </p>
    <p>
        CSS includes a pseudo class <code>:empty</code>, it has for some time.  Firefox 3.5, Safari 3.2, Chrome 4 all had support according to caniuse.  IE 6, 7, 8 didn't support it, but other than that, the full caniuse table is basically an entire wall of green.  jQuery definitely, also, has supported it forever because it was in the early CSS draft from the late 90's upon which jQuery based its selector support.  Yet, when you look at data in the wild, this selector is effectively unused and lots of people who use CSS all the time have not heard of it.
    </p>
    <p>
        Why is that?  Well, it's hard to say for sure but we do have all of the channels of input listed above which would suggest that the reason is that it's not currently useful and that people would like it to have meant something else instead... Which is, I think, where it gets tricky.
    </p>

    <section class="sectioning">
        <contextual-heading role="heading" aria-level="2">WDYM Empty?</contextual-heading>
        <p>
            See, there seem to be no universal answer here.  Instead, there are a whole lot different expectations, wants, and rationales.  However, most of them sound like fairly reasonable interpretations and desires.  In retrospect, it's kind of not that suprising - we have so many words for subtle variations of "there is not something there":  0, null, void, undefined, empty, etc.
        </p>
        <p>
            The sections below are an attempt to catalog the various answers, asks, rationales and discussions that I've had or heard.  They seem to fall into a few broad categories, with subtley different and interesting bits.
        </p>
        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3"><strike>No Child Nodes at All</strike></contextual-heading>
            <p>
                Let's start with one of the strictest possible definitions I can imagine: If the thing actually has no child nodes at all.  The only thing that could match is things like this:
            </p>
            <pre><code class="language-html">&lt;p&gt;&lt;/p&gt;</code></pre>
            <p>
                This seems, initially, like an entirely reasonable interpretation.  If the concept of emptiness that you are thinking of has anything to do with 'stuff <em>inside the element</em>', this is the one case that everyone agrees should definitely be 'empty'.
            </p>
            <p>
                Note, however, that it's crossed out above.  That's because this is <em>more strict</em> than the current specification and implementations which we have already discussed have nearly 0 uptake and lots of complaints that even that isn't what people want.  As you read more, hopefully it comes clear why, practically speaking, this is probably not an especially useful definition (at least not if we only get one).
        </p></section>

        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3"><strike>Currently Matching <code>:empty</code> Perspective</strike></contextual-heading>
            <p>
                Cut to what has been actually implemented all of these years.  Under that definition, the following is considered <code>:empty</code> too:
            </p>
            <pre><code class="language-html">&lt;p&gt;&lt;!-- still empty --&gt;&lt;/p&gt;</code></pre>
            <p>
                If it surprises you that this is a thing that would actually even have to be called out separately, that I think is part of the issue: We're not all sharing a common mental model to begin with.  A lot of people think 'that is not a child, it's just a comment and it isn't parsed into anything'.  But, strictly speaking, that's not true.  It is not an <em>element</em> child, but it is definitely a <em>node</em> child.  <code>thatParagraph.childNodes.length</code> is 1.
            </p>
            <p>
                The CSS Working Group saw that this would trip people up and maybe reduce the usefulness of it as well and so, from day one, defined that comment nodes and processing instruction nodes, for example, didn't 'count' toward measuring emptiness.
        </p></section>

        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">The "Insignificant Whitespace"  Perspective</contextual-heading>
            <p>
                One of the easiest ways to foul up what currently exists is like this..
            </p>
             <pre><code class="language-html">&lt;p&gt;&nbsp;&lt;/p&gt;</code></pre>
            <p>
                This surprises a number of people because they think "whitespace is insignificant in HTML and it is just parsed out".  But that is kind of an overstatement of what <em>insignificant whitespace</em> means.  That doesn't mean it isn't parsed, it means it shouldn't be <em>displayed</em>. Go ahead and ask that node how many <code>.childNodes</code> it has, and it will happily reply that the answer is <em>1</em>, not <em>0</em>.  That child is a <code>TextNode</code> holding the data <code>" "</code>.
            </p>
            <p>
                This trips up a lot of authors for several reasons.  First, I think because their mental model is built around <em>elements</em> and a view of the DOM based on dev tools in which a text node doesn't 'look' like an element node.  Some of this, I think, is just a mental block because if you ask most of the same people whether the following is empty..
            </p>

             <pre><code class="language-html">&lt;p&gt;what about this&lt;/p&gt;</code></pre>

             <p>... they would answer "of course not", and so it seems a given that a least a portion of this is requires modifying our current understanding.</p>
             <p>
                 That said, even if you understand this, the question of whether 'insignificant whitespace' should be considered goes beyond just strict theory.  A feature isn't valuable because it is strictly correct, it is valuable because it can be used and, it appears that way too many things rely on "insignificant whitespace" working out to be, well, insignificant in determining emptiness... It's just too easy and common to create that particular situation and frequently, those are things that desparately want a concept of emptiness too (a CMS that allows you to drag in and then populate things somewhat visually, for example).
             </p>
             <p>
                 This too, seems to me a reasonable interpretation: If the text node contains only <em>insignificant whitespace</em> that is still considered 'empty'.
             </p>
        </section>


        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3"><strike>The "Insignificant Whitespace Including Generated Content"  Perspective</strike></contextual-heading>
            <p>
                I'm going to list this one here because it seems to come up a lot and it is a non-starter, but also I think has some interesting observations that go along with it that either raise or help answer a number of other questions...</p>

            <p>
                A number of people seem to think that the following <code tag-esc="">p</code> should <em>not</em> be considered <code>:empty</code>.
            </p>
             <pre><code class="language-html">&lt;p id="one"&gt;&lt;/p&gt;
&lt;style&gt;
    #one::before {
        content: 'empty?';
    }
&lt;/style&gt;
             </code></pre>
            <p>
                I'm using an id here simply to avoid confusion that this might apply to any other example.  People see this render in devtool as something which appears to be <em>inside</em> of the paragraph, and clearly content is rendered - so they think "See? It is not empty. It has 'stuff' in it."</p>
            <p>
                As I said, while this may "feel" intuitive at first, this is a non-starter for reasons which will probably appear obvious in retrospect:  CSS selectors cannot rely on the application of CSS.  This would itself create circularity which, in CSS is a deal breaker.  For example, that would make it possible to write:
            </p>
            <pre><code class="language-html">&lt;p id="one"&gt;&lt;/p&gt;
&lt;style&gt;
    #one:empty::before {
        content: 'empty?';
    }
&lt;/style&gt;</code></pre>
             <p>
                 The DOM is empty, which causes CSS to match a rule which says it is not, which cause the rule to no longer apply, and so on.  There are probably ways to build in resilience to this very specific example, but still, it violates fundamental principles of CSS.
             </p>
             <p>
                 As I said though, I think it is interesting to point out not just for clarity but because it points to/allows us to stress two kind of important things:  First, CSS selectors operate on the DOM tree. Second, children in the DOM tree are not the only way that users "get" some kind of content.  There is no DOM node created in this case - but there is a <em>box</em> containing actual text drawn on the screen and there is a node created in the <em>accessibility tree</em>.  Our measure of 'emptiness' can't really include <em>exactly</em> what content is actually presented to an end user visually or accessibly which leads me to the next one...
             </p>
        </section>

        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3"><strike>From the End-User's Perspective Empty</strike></contextual-heading>
            <p>
                This is really just a correlary to the above one, but a lot of people would like to define emptiness in terms of what is shown to end-users of some kind (whether through the screen or accessibility tree) - so, for example, they'd like this to match:
            </p>

            <pre><code class="language-html">&lt;p id="two"&gt;
    &lt;span style="display:none;"&gt;error&lt;/span&gt;
&lt;/p&gt;</code></pre>

            <p>
                While that totally makes sense to me as some kind of a <em>want</em>, it too is a non-starter for the same reasons listed in the section above: It relies on the application of CSS.
            </p>
        </section>


        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">The Does "Insignificance" Actually Matter Perspective</contextual-heading>
            <p>
                So, if we intentially omit 'insignificant whitespace' I guess a part of the question is how and why. Examples would help
            </p>
             <pre><code class="language-html">&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;Tab;&lt;/p&gt;
&lt;p&gt;&amp;#x00009;&lt;/p&gt;
&lt;p&gt;&amp;#9;&lt;/p&gt;
&lt;p&gt;&amp;NewLine;&lt;/p&gt;
&lt;p&gt;&amp;#x0000A;&lt;/p&gt;
&lt;p&gt;&amp;#10;&lt;/p&gt;</code></pre>
            <p>All of the above express paragraph that contains only whitespace and, for example the <code>nodeType</code> and <code>.data</code> property of the two is actually pretty much  indistinguishable in browsers regardless of whether those were expressed as entities or not.  Further, what about elements like <code tag-esc="">pre</code> for example?  In these, the same 'insignificance' suddenly <em>is</em> significant.
            </p>
            <p>
            Maybe this implies that "significant whitespace" isn't actually what we're after at all... Maybe that is just a thing we currently observe because we all expect that very particular one to work for that reason.  Maybe.</p>
            <p>A lot of the use cases that determine that a strict definition of empty sans insignificant whitespace is inadequate, it seems, can also create entity issues like this as well.  Most notably, WYSIWG editors in which the 'intent' becomes  disconnected and where it is unclear which of those is always appropriate.
            </p>
            <p>Because of these points, I think (again, currently) that one <em>could</em> (I am not attempting to do so specifically) make a rational case that "insignificance" isn't the problem and that "intentionality of how we expressed whitespace" shouldn't really be considered here either.  That, perhaps a mechanism allowing us to consider those as empty would be useful.  The same one? A different one? Again, I dont know and I'm not making a case, I am simply attempting to catalog the debates, rationales and discussions without leaning too hard in any very specific direction.</p>
        </section>

        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">The Does "Elementness" Actually Matter Perspective</contextual-heading>
            <p>
                Depending on where you fall down on the item above, it's not always clear what to do with this:
            </p>
             <pre><code class="language-html">&lt;div&gt;&lt;br&gt;&lt;/div&gt;</code></pre>
            <p>The <code tag-esc="">br</code> element is a legacy concept that predates the W3C and, well, it's weird.  Pretty much everyone recognizes this as an element which <em>means</em> a character... about whitespace.</p>
            <p>
                If whitespace "as meaning" rather than "as style" is based on the tree and based on all of the things in all the previous points (how they are styled is irrelevant) and that WYSIWG editors disconnect, and so on - I (again, currently) believe here too one could make a fairly reasonable argument that a <code tag-esc="">br</code> child should be treated the same as a <code tag-esc="">br</code> entity, or at least having a way to consider that similarly empty as well.
            </p>
        </section>

        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">Is it about the content model or characterness?</contextual-heading>
            <p>
                Oh my... I know this might sound a little off to some at first, but what about an <code tag-esc="">hr</code>?  While we probably like to think of it as a "horizontal rule", that is at least to some extent about <em>rendering</em>.  According to the (current) specification it actually <em>represents</em> a 'paragraph-level thematic break' which is very similar in nature to <code tag-esc="">br</code>:  It is an element which can't itself contain content and implies "break-ed-ness" but it doesn't map cleanly to entity-like 'character-ness'.
            </p>
            <p>
                Is it empty? I don't know - this feels like a stretch (to me), but I see the argument: If your definition really relies on containing some kind of 'character content' then, I kind of get it... maybe.
            </p>
        </section>


        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">Elements That <em>Kinda Mean</em> They Should Themselves Not Contain Stuff</contextual-heading>
            <p>
                There are some things that <em>seem</em> like the above, but there is a case to be made that they are different.  For example
            </p>

            <pre><code class="language-html">&lt;p id="three"&gt;&lt;span hidden&gt;error&lt;/span&gt;&lt;/p&gt;</code></pre>

            <p>
                While this seems similar to the <code>style="display:none;"</code> one above  and many would undoubtedly make the case that authors can override the meaning of hidden with CSS so that it not, in fact, actually 'hidden' - that's about styling, not meaning.  To do so violates the meaning.  Because of this, one could make what I think (currently at least) seems like a rational case that this is actually quite different from the above - almost the inverse in that it stresses the importance and meaning of the tree only.  According to the <em>meaning</em> of the DOM tree and not considering CSS, this is defined as something which should not be displayed and is <em>irrelevant</em>, much like insignificant white space.
            </p>

            <p>
                In fact, depending on your view of this one, a number of elements could not count against a measure of emptiness.  Any void tag or thing with a content model of none...  <code tag-esc="">template</code> for example, or <code tag-esc="">link</code>.  Could they be displayed?  Sure, but that doesn't change their meaning and by definition they can't contain characters, so if your definition is somehow about characters, I can definitely see the use in something that says "no point in counting these".
            </p>
        </section>

        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">The "Other Kinds of Empty" Perspective</contextual-heading>
            <p>
                Let's take a detour and talk about something a little different. So far we've been talking about things in terms of whether something has childNodes of some kind and which kinds count.  But, in the last section, I mentioned 'void tags'.  Most form elements are <code tag-esc="">input</code>s which are, themselves, void and can't "contain" text in the way we've been talking about so far and would therefore seem to fit in with whatever rationale one accepts for the section above.... Except, maybe not.
            </p>
            <p>
                Why?   Because they obviously do  "contain" text at some point - that is their whole point in being.  But they "contain" it in an entirely different sense.
            </p>
            <p>
               Form elements already have other relevant pseudo-classes <code>:valid</code>, <code>:invalid</code> and <code>:indeterminate</code> for example.  Used together these still leave a gap in most people's mind in creating a good UI.  We don't generally want a form loading and looking as if it contains a bunch of errors.  Technically speaking, it totally does - but that isn't what users expect or developers want and so it seems reasonable to expect that there would be a way to omit that state.   Many people, it seems, turn to the spec when they are thinking about form elements, looking for this concept of emptiness too, and that doesn't exist either.
            </p>
            <p>
                This one is unique enough that currently the CSS working group has agreed to take this up under the working name <code>:blank</code>, instead of trying to solve it with <code>:empty</code>.  Is that the right move? I don't know. I do think it helps illustrate just how diverse the things that need some concept of "emptiness" are though.
            </p>
            <p>
                I think the important thing here is that the concept of emptiness here has to do with a property rather than children... and... it might not be the only one.  For example, while void elements can't contain text content inside (or any childNode of any kind really) - it can have other content-oriented properties.  An image, for example, can have alt text - or just about anything could have an <code>aria-label</code>. Do we care? Does it change things?  Again, I don't know.  Maybe? Sometimes?
            </p>
        </section>

        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">The Nothingness Within</contextual-heading>
            <p>Of course, most of what we are stressing about in most of the above things are about some kind of debate about "what we should and shouldn't consider about some kind of childNode" - but realistically, at least some of this is because that is how we are thinking about it, or accustomed to thinking about it.</p>
            <p>Many authors, it seems, really want something conceptually similar - not just about children, but about descendants.  In fact, in this light, many of the above become clearer if we look at this as the question instead. If you want to know if a form element contains nothing - you very probably want to be able to say 'an element that contains one of those'.  If you want to know if something 'contains' something text node related, you probably don't care whether it is wrapped in a paragraph or a strong inside a span inside a paragraph.</p>
            <p>This is tricky because in CSS selectors, historically, we don't do that: The thing that you can style is always the last thing in a selector. Except that we have wanted to since at least 1998 when <code>:has</code> was discussed.  We still don't hav <code>:has</code> because no one can figure out a way to keep CSS performant if we add that ability.  But we <em>do</em> have some things like <code>:focus-within</code> that is a very specific kind of <code>:has</code> that we can make work.  Is it possible that we could somehow optimize a thing about containing text nodes?  Maybe.  Is that a good idea?  I don't really know.</p>

        </section>

    </section>


    <section class="sectioning">
        <contextual-heading role="heading" aria-level="2">So...</contextual-heading>
        <p>So.  These are all of the things that I have heard, so far.  If you have some other thing that isn't documented here, please share it with me (all of my contact info is in the bar on this page).  As I say, many of these desires don't sound unreasonable, but they also don't sound like they can be accomodated under a single name with no arguments or anything.  What I'd really like is for CSS to give us the reasonable powers authors need, but I'm still not really sure what they are yet.</p>
    </section>

    <!-- p class="thanksTo"></p -->
</article></main>

  
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-88027178-1', 'auto');
    ga('send', 'pageview');
  </script>

  <script>
    Array.prototype.slice.call(document.querySelectorAll('.optional [data-src]')).forEach(function (optional) {
      var prefs = window.localStorage.downloadsPrefs,
          clickToSee;
      if (prefs === 'true') {
        activateOptional(optional);
      } else {
        clickToSee = document.createElement('div');
        clickToSee.classList.add('clickToSee')
        clickToSee.innerHTML = '<button>Click to see media</button>';
        clickToSee.style.textAlign = 'center';
        clickToSee.style.border = 'none';
        optional.parentElement.insertBefore(clickToSee, optional.nextSibling);
        clickToSee.firstElementChild.addEventListener('click', function () {
          activateOptional(optional);
        })
      }

    })
  </script>

</body></html>