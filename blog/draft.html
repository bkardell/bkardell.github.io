<html lang="en" resource-type="blogpost"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@briankardell">
    <meta name="twitter:creator" content="@briankardell">
    <meta name="twitter:title" content="TBD">
    <meta name="twitter:description" content="TBD SEGUE">
    
    <link rel="alternate" type="application/rss+xml" href="blog/feed.rss" title="bkardell.com/blog rss feed">
    <title>TBD</title>
    <style>.captioned-image {
    background-color: #eaeaea;
    display: block;
    overflow: hidden;
    padding: 1rem;
    text-align: center;
    font-style: italic;
}

.captioned-image.p-attached {
    width: 40%;
    display: inline-block;
    margin: 0 1rem 2rem 1rem;
}

section > .captioned-image.p-attached {
    margin-top: 1.5rem; /* correct for heading size*/
}

 pre { overflow-x: auto }

.captioned-image.p-attached.p-attached-left {
    float: left;
}

.captioned-image.p-attached.p-attached-right {
    float: right;
}

.captioned-image.p-attached + * + * {
    clear: both;
    margin-top: 2rem;
}


.captioned-image img, .captioned-image video {
    display: block;
    max-width: 100%;
    margin: 0 auto 1em auto;
}
.source {
    font-style: italic;
}
body {
    display: flex;
    font: 1em "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-weight: 300;
    line-height: 1.625;
}
h1 { margin: 0.5rem; }
code-format {
    border-left: 0.5rem solid rgba(123,115,209,0.35);
    display: block;
    padding: 0.5rem;
    margin-bottom: 1rem;
}

contextual-heading {
    display: block;
    margin-top: 2rem;
}

[aria-level="1"] {
    color: #43686b;
    font-size: 1.45rem;
}
[aria-level="2"] {
    color: #856363;
    font-size: 1.35rem;
}
[aria-level="3"] {
    color: #856363;
    font-size: 1.25rem;
}
[aria-level="4"] {
    color: #856363;
    font-size: 1.2rem;
}
[aria-level="5"], [aria-level="6"] {
    color: #667496;
    font-size: 1.1rem;
    font-weight: bolder;
}
.posted-on {
    font-style: italic;
    font-size: 0.8rem;
    text-align: right;
    margin-bottom: 1rem;
}

ul, li {
    margin: 0.5rem;
    text-align: left;
}
header {
    padding-top: 1rem;
    padding-right: 2rem;
    background-color: #fbf5e9;
}
.tagline {
    font-style: italic;
    text-align: center;
}

[tag-esc] {
    color: maroon;
    font-family: Courier, "Lucida Console", monospace;
}

[tag-esc]::before {
    content: '<';
}

[tag-esc]::after {
    content: '>';
}

main {
    min-width: 50%;
    width: 80%;
    padding: 1rem;
}
header .title {
    background-color: rgba(123,115,209,0.35);
    padding: 0.3rem;
    padding-left: 0.25rem;
    font-weight: bolder;
    font-size: 0.9rem;
    border-left: 1rem solid #999298;
}

header .profile {
    width: 50%;
    margin: 1rem 25%;
}

header .title + nav {
    font-size: 0.9rem;
}

header .blurb {
    font-size: 0.75rem;
    text-align: center;
}
header .name {
    text-align: center;
    font-size: xx-large;
}
.segue {
    font-style: italic;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
}
[for="aboutMeToggle"] {
    display: none;
}
/* this needs rethinking, it wants a selector like 'not flow content' */
article>*:not(contextual-heading,a), section>*:not(contextual-heading,a) {
    margin-left: 0.45rem;
}

blockquote {
  font-family: serif;
  background: #f9f9f9;
  border-left: 10px solid #ccc;
  margin: 1.5em 10px;
  padding: 0.5em 10px;
}
blockquote:before {
  color: #ccc;
  content: open-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-right: 0.25em;
  vertical-align: -0.4em;
}

blockquote:after {
  color: #ccc;
  content: close-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-left: 0.25em;
  vertical-align: -0.4em;
}


@media (max-width: 800px){
    body {
        flex-direction: column;
    }
    header {
        border-bottom: 1px solid #afafff;
    }

    .captioned-image.p-attached {
        width: 100%;
        margin: 1rem 0;
    }

    .captioned-image.p-attached.p-attached-left,
    .captioned-image.p-attached.p-attached-right {
        float: none;
    }

    [for="aboutMeToggle"] {
        background-color: #675e5e;
        color: white;
        padding: 0.25rem;
        padding-left: 0.5rem;
        display: block;
        border-left: 1rem solid black;
    }
    #aboutMeToggle:focus + [for="aboutMeToggle"]{
        outline: 4px solid #c6ddf2;
    }

    #aboutMeToggle:checked ~ header {
        display: none;
    }

    header li { display: inline; margin-left: -0.5em; }
    header .blurb li::after { content: '; '; }
    header  nav li {
        display: inline-block;
        margin-left: 0.35rem;
        margin-right: 0.35rem;
    }
    header .title {
        width: 100%;
    }
    main li .source { display: block; }

}</style>
    <style>
      .captioned-image { font-size: 0.9rem; }
      .thanksTo { font-style: italic; font-size: 0.8rem; }
    </style>
    <script>
      var activateOptional = function (media) {
        var source = media.getAttribute('data-src'),
            temp,
            container = media.parentElement;

          if (media.nextSibling && media.nextSibling.matches) {
            if (media.nextSibling.matches('.clickToSee')) {
              media.parentElement.removeChild(media.nextSibling);
            }
          }

          if (media.tagName === 'VIDEO') {
            temp = document.createElement('video')
            temp.setAttribute('autoplay','')
            temp.setAttribute('controls','')
            temp.setAttribute('loop','')
            temp.innerHTML = '<source src="' + source + '.webm" type="video/webm">'
                    + '<source src="' + source + '.mp4" type="video/mp4">';
            media.parentElement.replaceChild(temp, media);
            setTimeout(function () {
              temp.play()
            }, 0);
          } else {
            media.src = media.getAttribute('data-src');
          }

          container.classList.add('active');
      }
    </script>
  </head>
  <body>
    <input id="aboutMeToggle" class="sr-only" type="checkbox" checked="">
<label for="aboutMeToggle">Toggle author information</label>
<header>
    <div class="name">
        Brian Kardell
    </div>
    <img class="profile" src="/profile.jpg" alt="">
    <div class="tagline"><a href="/">Betterifying the Web</a></div>
    <div class="blurb">
        <ul>
            <li>Sr Front-End Engineer at Apollo Group, Inc</li>
            <li>Original Co-author/Co-signer of The Extensible Web Manifesto</li>
            <li>Co-Founder/Chair, W3C Extensible Web CG</li>
            <li>Member, W3C (The JS Foundation)</li>
            <li>Co-author of HitchJS</li>
            <li>Blogger</li>
            <li>Art, Science &amp; History Lover</li>
            <li>Standards Geek</li>
        </ul>
    </div>
    <div class="title">Follow Me On...</div>
    <nav>
        <ul>
            <li><a rel="me" href="https://briankardell.wordpress.com">Wordpress</a></li>
            <li><a rel="me" href="https://medium.com/@briankardell">Medium</a></li>
            <li><a rel="me" href="https://twitter.com/briankardell">Twitter</a></li>
            <li><a rel="me" href="https://github.com/bkardell/">Github</a></li>
            <li><a rel="me" href="https://codepen.io/bkardell">Codepen</a></li>
            <li><a rel="me" href="https://www.linkedin.com/in/brian-kardell-08a4264">LinkedIn</a></li>
            <li><a rel="me" href="https://www.instagram.com/kardellbrian">Instagram (for
art)</a></li>
            <li><a rel="me" href="http://fineartamerica.com/profiles/brian-kardell?">Fine Art
America (art for sale)</a></li>
        </ul>
    </nav>
</header>
    <main><div class="posted-on">Posted on null</div><article class="sectioning">
	<!-- bkardell-prefs></bkardell-prefs -->
	<style>
		.tldr em {
			display: none; color: rebeccapurple;
		}
	</style>
  	<script src="../prism.js"></script>
  	<link rel="stylesheet" href="../prism.css">
	<contextual-heading role="heading" aria-level="1">TBD</contextual-heading>
	<p class="segue">TBD SEGUE</p>

	<!-- div class="captioned-image optional p-attached p-attached-right">
		<img data-src="http://www.jabberwocky.com/carroll/pics/glass21.gif" alt="">
			"The time has come," the Walrus said,<br>
			"To talk of many things:<br>
			Of shoes--and ships--and sealing-wax--<br>
			Of cabbages--and kings--<br>
			And why the sea is boiling hot--<br>
			And whether pigs have wings."
	</div -->

	<p>It's become a fairly regular occurence for me to encounter someone on social media expressing some kind of frustration with Custom Elements. I genuinely want to understand where the pain points are.  As one of the folks involved in many discussions during the evolution and a user of them myself, I know that they aren't perfect and I really want them to be better, and so I ask questions.  The complaints are always slightly different, but all they seem to kind of play into common themes: Custom Elements currently require JavaScript.  They don't currently allow us avoid all the hard work that is historically necessary (without Custom Elements) for making "improvements" to existing native elements by just saying <em>is="..."</em>.</p>

	<p>This seems doubly frustrating as a number of folk have pointed to already written drafts or specs that would seem like they'd really help their concerns if only browser vendors would get their shit together and implement it that way then things would be Super Greatâ„¢.</p>

	<p>I don't share this belief, but I'm willing to admit that there might be things that I don't "see" yet.  If there are, I'm very keen to learn about them.  However, I'd like to suggest that perhaps there is some larger general confusion here that currently prevents us from having some really valuable conversation.  In this piece, I'll attempt to explain why that discrepancy exists, what exactly is "the hold up" with implementing those things and, I hope, why I don't feel precisely this way.</p>

	<section class="sectioning">
		<contextual-heading role="heading" aria-level="2">Something to drive the conversation</contextual-heading>

		<p>Very frequently I see a hypothetical example framed that goes something like this:  My design team created shiny, modern ux for a 'stars' oriented rating component for attaching to items.  It shows N stars, and they are initially 'hollow'.  The user can choose to record a rating by selecting 1-N stars.  There is a little UX on hover that lights up stars as you mouse over them and once selected, the stars are filled with a fill color (for example, gold) indicating my recorded rating.</p>


		<p>As the example continues, it will point out that radio buttons seem very similar in a lot of ways.  In fact, 20 years ago, that's just what we would have done.  It would have worked for everyone and been pretty accessible too because it was native HTML 'out of the box'.  They'll then point out that that <em>means</em> something, and it works for everyone.  On the other hand, they'll hold up that the following code with custom elements</p>

		<pre><code class="language-html">&lt;my-ratings"&gt;&lt;/my-ratings"&gt;</code>

		<p>means nothing, unless you run some JavaScript. This is absolutely true.</p>

		<p>Further, they may point out that the creator of the component has to 're-invent' all of the accessibility features that came 'out of the box' with native radio buttons: Keyboard handling, label click handling and so on.  This is also completely true.</p>

		<p>They might say "we shouldn't have to recreate the magic of radio buttons in order to make this if we simply want to tweak the existing one a little bit". Also, I think, not controversial in any way.</p>

		<p>However, then there's kind of a leap in the reasoning:  For example: If we had the ability to say a radio button <code>is="ratings-star"</code> or something "as in the specification" and then it would be easy and compelling to write good, progressively enhanced components that just "tweak" the edges of existing ones.  Some take it further still and say that untilwe have that, Web Components are really no good, potentially this even demonstrates that they are bad and should be actively avoided.</p>

		<p>This, I think is entirely not true and I'll explain why.</p>
	</pre></section>


  	<section class="sectioning">
  		<contextual-heading role="heading" aria-level="2">"Automatic Accessibility"</contextual-heading>

  		<p>There seems to be an increasingly popular belief that if we were to extend a built-in element that it would be "automatically accessible" by way of simple inheritance from the native element. However, this just isn't true.  And, I don't mean "this isn't always true" I mean "as far as I can tell, this is <em>almost never</em> true".</p>

  		<p>But, you shouldn't take my word for this:  You can read the specs, or even try it for yourself (get an older version of Chrome or possibly <a href="https://github.com/WebReflection/document-register-element" target="_blank">Andrea Giammarchi's polyfill</a>).  Or, you could simply look to demos done during the time when we thought this might actually ship.  My friend Alice Boxhall at Google did a few which seem to illustrate pretty much exactly what I am about to tell you:</p>

		<p>There's just not a lot of great reasons to want to change a native element that don't impact the DOM.  To change the user experience, we'll almost certainly have to create some new DOM and CSS to make our shitty looking radio buttons look like something new.  If not, why are you even using a custom element instead of the native element itself?  As soon as you do: Viola, you've lost all that yummy accessible goodness.  To fix the accessibility issues that you've just created with that assumption, you'd need to add keyboard handling, click handling, focusability and so on.  In fact, you'll wind up dealing with just about every accessibility feature that you would have if you'd simply extended the default <code>HTMLElement</code> in the first place.</p>

		<p>Why?  Because currently, it's inextricably wound up in the DOM you just entirely changed.</p>

		<p>So, there's no automatic magic accessibility bullet to be had here through extension as specified right now.  But at least there is progressive enhancement.</p>
	</section>

	<section class="sectioning">
		<contextual-heading role="heading" aria-level="2">Progressive Enhancement</contextual-heading>
		<p>Alright, let's talk about progressive enhancement.</p>

		<p>Consider the original cannonical problem description for progressive enhancement: Our design calls for a nice button that simply says "Click to print".  Once upon a time not all browsers understood the button element and not all browsers supported the print function, or even JavaScript at all.  If you simply wrote the HTML and JavaScript that you actually wanted, some users would be presented with a very confusing interface:  Perhaps some non-button looking text in the page that says "Click to print" or a perhaps button that won't actually do anything at all. That would be Very Badâ„¢</p>

		<p>The way we dealt with this at one point in time was called "Graceful degradation".  One way to think about this is:

		</p><p><em>When you can't give them what I really wanted to, at least don't leave them in a complete lurch.  At least explain why it's fucked up or how to remedy it or something.</em></p>

		<p>Now, often this meant something very simple indeed: using a <code tag-esc="">noscript</code> tag that said "this interface requires a JavaScript enabled browser and you should download one of those if you really expect it to work... Everyone else can just accept that some things will be f'ed because of you, not because of me."</p>

		<p>However, sometimes it instead involved the idea carefully arranging HTML code a certain way so that if your browser didn't understand some outer tag, the tag inside it would instead do something lesser.</p>

		<p>Progressive enhancement simply suggested that we invert that mental model. Instead of starting with our ideal design and working "down", start with something basic and widely supported and work "up".</p>

		<p>So, in the case of the cannonical example, progressive enhancement would suggest that we start with something basic.  Perhaps start instead with a simple paragraph saying "you can print this for your records".  From day 1, everyone's browser has been able to render a paragraph.  Given that text, most people can then figure out how to print.  Conditionally then, determine if they can do more and then do.  Perhaps you might replace the paragraph with the nice "Click to print" button that you really wanted instead, or perhaps you could empty the paragraph and have it contain our functional button instead of the text.</p>

		<p>So why go through this recap?  Well, really simply so I can point out two things that appear to be non-immediately obvious.  First, the fact that some people used the "fall back" approach in the days of "graceful degradation," seems to have led many people associate code that looks like it "falls back" as being not progressive enhancement, but rather something "Bad".  This, however, is incorrect really.  Progressively enhancing through declarative forms looks identical and is entirely in keeping with our aims - the only really difference is in the mindset of approaching the problem.</p>

		<p>The second reason to recap is to point out that this has never been an <em>is-a</em> relationship (extension) either.  It's always been a "here's a thing you can definitely do and, if you can do more, here's what that is (usually through JavaScript)".  It either began as a paragraph <em>containing</em> some text and became a paragraph <em>containing</em> a functional button, or it began as a paragraph and became a functional print button.  The "ness" of that thing never changed.</p>

		<p>We wouldn't expect to say <code tag-esc="">p is="button"</code>, because that is of course nonsense: We know that however we spell it out, these two things are just way too different.  Note that the simple fact that an author <em>could</em> express that though means introducing a whole lot of new things we have to account for.</p>

		<section class="sectioning">
			<contextual-heading role="heading" aria-level="3">is="it tho"?</contextual-heading>
			<p>I mention the above here to simply say that this is <em>frequently</em> actually what we are asking for without realizing it.  This is the case because because what we want actually involves new DOM.  It's not, in terms available to us today, actually just a specialized version of something, it's really often a different kind of relationship</p>

			<p>In 1987 Barbara Liskov presented a keynote address called "Data abstraction and hierarchy" which talks about how we model things and our desire to organize things into heirarchies that <em>extend</em> and <em>inherit</em>.  She then goes on to illustrate how that tends to cause numerous sorts of problems.  More importantly, she begins to explain how we might avoid those problems and the basic concept she describes is sometimes known as the "Liskov substitution principle" or "LSP" or even just "substitutionality".  In a way, what this says is that metaphor is shitty.  Your mind can trip you up and make you model something poorly.  If you do, then rather than being helpful, the system will fight you.</p>

			<p>Fortunately 'is-a' isn't the only kind of relationship we have for modeling problems.  The often cited Gang of Four <em>Design Patterns</em> reiterates on Liskov's work and provides the simple observation "composition over inheritance".  That is: Composing features through a <em>has-a</em> relationship is often a better way to go.</p>

			<p>The really interesting thing about that is that that's kind of where we are today: Absolutely nothing new is required in order to follow the self-same progressive enhancement patterns that we've been using all along and gain pretty much the same values we would with <code>is="..."</code> through composition rather than inheritance.</p>

			<pre><code class="language-html">&lt;!-- instead of writing this --&gt;
&lt;input type="radio" is="x-radio"&gt;

&lt;!-- you write this --&gt;
&lt;x-radio&gt;
    &lt;input type="radio"&gt;
&lt;/x-radio&gt;</code></pre>

			<p>Functionally, they are equivalent in pretty much every useful way: Form serialization, validation, etc - and you have to change and proxy precisely as much in either model for the sake of accessibility, depending on just what DOM what you change.  But we need nothing new to do it, and it opens no significantly complex new challenges for us to answer.</p>
		</section>

		<section class="sectioning">
			<contextual-heading role="heading" aria-level="3">But I don't see people doing that... Why?</contextual-heading>
			<p>Well, part of it may be that people just aren't thinking about it that way.  For example, I have developed several custom elements that work precisely like this.  But that's definitely not the entire story.  The truth is because it's actually harder than most of our contrived examples would like to admit and it is tough to strike a good balance.</p>

			<p>Let's go back to our "Hypothetical Problem #1" again and look at it "in real life".  We've been discussing a lot about extending a radio button, but that is, in fact, kind of a red herring.  This component is, more realistically, a form.  A form is the thing you'd likely have to <em>is="..."</em> and that would require the form to wire up whatever it needed to be a good accessible native interface, including a fieldset with a legend and several labels linked to radio buttons that share the same name, etc.  As I said, we can do the same with composition and that would look something like:</p>

			<pre><code class="language-html">&lt;my-ratings&gt;
  &lt;form action="submitRating" method="POST"&gt;
    &lt;p class="average-rating"&gt;Average Rating: 4/5 stars&lt;/p&gt;
      &lt;fieldset&gt;
        &lt;legend&gt;How many stars would you rate this as?&lt;/legend&gt;
        &lt;label&gt;
          &lt;input type="radio" value="1" name="my-rating-1"&gt;
            1 star
        &lt;/label&gt;

        &lt;label&gt;
          &lt;input type="radio" value="2" name="my-rating-1"&gt;
            2 stars
        &lt;/label&gt;

        &lt;label&gt;
          &lt;input type="radio" value="3" name="my-rating-1"&gt;
          3 stars
        &lt;/label&gt;

        &lt;label&gt;
            &lt;input type="radio" value="4" name="my-rating-1"&gt;
            4 stars
        &lt;/label&gt;
        &lt;label&gt;
            &lt;input type="radio" value="5" name="my-rating-1"&gt;
            5 stars
        &lt;/label&gt;
    &lt;/fieldset&gt;
  &lt;/form&gt;
&lt;/my-ratings&gt;</code></pre>

	<p>Alternatively, what you see frequently instead is something like:</p>
	<pre><code class="language-html">&lt;my-ratings&gt;&lt;/my-ratings&gt;</code></pre>

	<p>You can be unhappy about that, but the honest truth is, there are a lot of legitimate tradeoffs to consider there and the value proposition just always isn't there.  Which do you think that authors are more likely to want to actually adopt? Which are they less to get wrong? Which accomplishes other important engineering goals of abstraction/ecapsulation?  Having stability and the ability to centralize some of this stuff (like complex DOM formulas and difficult UX and accessibility challenges) is a pretty big win.  The "cost" is that that ratings component will be 'nothing' unless there's JavaScript, but - is that always bad?</p>

	<p>I don't think it is, for a number of reasons.  The first is, I don't think anything is too holy to question and the important thing is that we're asking good questions.  So why is it that you feel this really matters so much.  If the idea is "it's declarative and therefore analyzable and fault tolerant" well, this ticks that box.  By using an actual element rather than selectors or something and having a way to trace that back to implementations, we gain a way to analyze pages for common usages far beyond what we had before.  By drawing the line where it does, this also won't blow up your app, that particular thing will just cease to be there.  But guess what? Worse is true of partially loaded CSS and that happens too: But we're ok with that.  Finally, this doesn't have to be an all or nothing answer.  Some aspects of my application are kind of mission critical - in those, perhaps I am willing to take more pains in this approach.  A ratings widget, well, maybe it isn't so much.  I have to weigh the cost benefit of taking that approach.  It's costly to authors, it's costly for maintenance, it's frequently more costly across the wire, it frequently means I need multiple approaches: SSR, the ability to accept form encoding where I may have a JSON based RESTful service already in place and so on.  And also, guess what?  Even some native elements in some browsers are actually not accessible.  To address that, you'll need JavaScript.  Saying "I'm doing it this way so that it works for everyone" seems disingenuous to me if that leaves people out of the everyone.  At the end of the day, I have to justify: Why I am doing this and what does everyone gain?  It's not always simple nor black and white. Most of us, in fact, actually agree with that as a sentiment at some level: <a href="https://adactio.com/journal/4437">It depends</a>.</p>

	<section class="sectioning">
		<contextual-heading role="heading" aria-level="4">We can do better</contextual-heading>
		<p>Now, you may say that this seems like an unfortunate set of choices.  Yeah, probably.  You may say it shouldn't be as hard as it is to make good choices.  Agree!  You may say it would be nice if we didn't have to do all that proxying. Sure! Confirm.  The question is simply:  How do we get there?  And all I'm really offering is: It really doesn't seem like extension, as currently specified, anwser most of those questions any better than what Custom Elements is already shipping uniformly with. I'm suggesting that if you would have liked that, it kind of seems like you should like this.  If, after reading this, you still don't, I'd like to understand why.  What is the "thing" it gives you that is really super great and how does it not create a host of new problems along the way?</p>

		<p>So what <em>would solve those problem</em>? Yeah, that's why I'm asking the questions: <em>I don't know</em>.  What qualities should those answers have? <em>I'm kind of unsure</em>.  These are the conversations I'd like to have.</p>

		<p>One thing that definitely seems to come up a lot is: Why in the name of all that is holy are there so many toolkits with specialized things that seem a lot like native components and why are most of them so complicated and inaccessible: How can we fix that?</p>

		<p>Well, some people point to limits in styling.  Is that something we should tackle?  I kind of think so, but a lot of vendors are really hesitant to go too deply into that for a number of not actually bad reasons.  For example: Not all components render the same on all devices <em>on purpose</em> and this will continue.  If we box ourselves in too much, we limit our ability to adapt and experiement.  But this isn't even the whole problem perhaps because in a lot of cases it seems people want something only <em>kind of</em> like a native element and our ability to map it cleanly is really the problem.  In fact, this is a huge problem in the Web Platform.  The bolt-on nature of ARIA and it's ability to express way more unclear nonsense than correctness and only really mostly in terms of well known components is kind of really kind of problematic.  This isn't blasphemy, it's been a common and noted critique about why accessibility is still so problematic.  Should we deal with this?  Yes.  How? I don't know.  One really nifty solution to a number of these problems is a thing called AOM, or the Accessibility Object Model.  But you know what it requires?  JavaScript.  Is that OK with you?  It works for me, but our sensibilities may really differ and I'd like you to say something <em>now</em> before we've invested a few years into that if that's going to concern a lot of people.  If not that, what?  I don't know, I'm not sure how we solve these problems.</p>


		</section>



	</section>

</section></article></main>

  
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-88027178-1', 'auto');
    ga('send', 'pageview');
  </script>

  <script>
    Array.prototype.slice.call(document.querySelectorAll('.optional [data-src]')).forEach(function (optional) {
      var prefs = window.localStorage.downloadsPrefs,
          clickToSee;
      if (prefs === 'true') {
        activateOptional(optional);
      } else {
        clickToSee = document.createElement('div');
        clickToSee.classList.add('clickToSee')
        clickToSee.innerHTML = '<button>Click to see media</button>';
        clickToSee.style.textAlign = 'center';
        clickToSee.style.border = 'none';
        optional.parentElement.insertBefore(clickToSee, optional.nextSibling);
        clickToSee.firstElementChild.addEventListener('click', function () {
          activateOptional(optional);
        })
      }

    })
  </script>

</body></html>