<html lang="en" resource-type="blogpost"><head> 
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@briankardell">
    <meta name="twitter:creator" content="@briankardell">
    <meta name="twitter:title" content="Much Ado About Nothing">
    <meta name="twitter:description" content="Standards move slowly - far slower than the slowest project you've ever worked on.  Even the fastest standardization is  measured in years, not months, before there is wide enough ">
    
    <meta name="monetization" content="$ilp.uphold.com/kKU4GXiRwhnfS">

    <link rel="alternate" type="application/rss+xml" href="https://bkardell.com/blog/feed.rss" title="bkardell.com/blog rss feed">
    <title>Much Ado About Nothing</title> 
    <style>.captioned-image {
    background-color: #eaeaea;
    display: block;
    overflow: hidden;
    padding: 1rem;
    text-align: center;
    font-style: italic;
}

.captioned-image.p-attached {
    width: 40%;
    display: inline-block;
    margin: 0 1rem 2rem 1rem;
}

section > .captioned-image.p-attached {
    margin-top: 1.5rem; /* correct for heading size*/
}

 pre { overflow-x: auto }

.captioned-image.p-attached.p-attached-left {
    float: left;
}

.captioned-image.p-attached.p-attached-right {
    float: right;
}

.captioned-image.p-attached + * + * {
    clear: both;
    margin-top: 2rem;
}


.captioned-image img, .captioned-image video {
    display: block;
    max-width: 100%;
    margin: 0 auto 1em auto;
}
.source {
    font-style: italic;
}
body {
    display: flex;
    font: 1em "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-weight: 400;
    line-height: 1.625;
}
h1 { margin: 0.5rem; }
code-format {
    border-left: 0.5rem solid rgba(123,115,209,0.35);
    display: block;
    padding: 0.5rem;
    margin-bottom: 1rem;
}

contextual-heading {
    display: block;
    margin-top: 2rem;
}

[aria-level="1"] {
    color: #43686b;
    font-size: 1.45rem;
}
[aria-level="2"] {
    color: #856363;
    font-size: 1.35rem;
}
[aria-level="3"] {
    color: #856363;
    font-size: 1.25rem;
}
[aria-level="4"] {
    color: #856363;
    font-size: 1.2rem;
}
[aria-level="5"], [aria-level="6"] {
    color: #667496;
    font-size: 1.1rem;
    font-weight: bolder;
}
.posted-on {
    font-style: italic;
    font-size: 0.8rem;
    text-align: right;
    margin-bottom: 1rem;
}

ul, li {
    margin: 0.5rem;
    text-align: left;
}
header {
    padding-top: 1rem;
    padding-right: 2rem;
    background-color: #fbf5e9;
}
.tagline {
    font-style: italic;
    text-align: center;
}

[tag-esc] {
    color: maroon;
    font-family: Courier, "Lucida Console", monospace;
}

[tag-esc]::before {
    content: '<';
}

[tag-esc]::after {
    content: '>';
}

main {
    min-width: 50%;
    width: 80%;
    padding: 1rem;
}
header .title {
    background-color: rgba(123,115,209,0.35);
    padding: 0.3rem;
    padding-left: 0.25rem;
    font-weight: bolder;
    font-size: 0.9rem;
    border-left: 1rem solid #999298;
}

header .profile {
    width: 50%;
    margin: 1rem 25%;
}

header .title + nav {
    font-size: 0.9rem;
}

header .blurb {
    font-size: 0.75rem;
    text-align: center;
}
header .name {
    text-align: center;
    font-size: xx-large;
}
.segue {
    font-style: italic;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
}

#aboutMeToggle {
    display: none;
}

[for="aboutMeToggle"] {
    display: none;
}

main article { max-width: 100em; margin: auto; }
/* this needs rethinking, it wants a selector like 'not flow content' */
article>*:not(contextual-heading,a), section>*:not(contextual-heading,a) {
    margin-left: 0.45rem;
}

blockquote {
  font-family: serif;
  background: #f9f9f9;
  border-left: 10px solid #ccc;
  margin: 1.5em 10px;
  padding: 0.5em 10px;
}
blockquote:before {
  color: #ccc;
  content: open-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-right: 0.25em;
  vertical-align: -0.4em;
}

blockquote:after {
  color: #ccc;
  content: close-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-left: 0.25em;
  vertical-align: -0.4em;
}


@media (max-width: 800px){
    body {
        flex-direction: column;
    }
    header {
        border-bottom: 1px solid #afafff;
    }

    .captioned-image.p-attached {
        width: 100%;
        margin: 1rem 0;
    }

    .captioned-image.p-attached.p-attached-left,
    .captioned-image.p-attached.p-attached-right {
        float: none;
    }

    [for="aboutMeToggle"] {
        background-color: #675e5e;
        color: white;
        padding: 0.25rem;
        padding-left: 0.5rem;
        display: block;
        border-left: 1rem solid black;
    }
    #aboutMeToggle:focus + [for="aboutMeToggle"]{
        outline: 4px solid #c6ddf2;
    }

    #aboutMeToggle:checked ~ header {
        display: none;
    }

    header li { display: inline; margin-left: -0.5em; }
    header .blurb li::after { content: '; '; }
    header  nav li {
        display: inline-block;
        margin-left: 0.35rem;
        margin-right: 0.35rem;
    }
    header .title {
        width: 100%;
    }
    main li .source { display: block; }

}</style>
    <style>
      .captioned-image { font-size: 0.9rem; }
      .thanksTo { font-style: italic; font-size: 0.8rem; }
    </style>
    <script>
      var activateOptional = function (media) {
        var source = media.getAttribute('data-src'),
            temp,
            container = media.parentElement;

          if (media.nextSibling && media.nextSibling.matches) {
            if (media.nextSibling.matches('.clickToSee')) {
              media.parentElement.removeChild(media.nextSibling);
            }
          }
 
          if (media.tagName === 'VIDEO') {
            temp = document.createElement('video')
            temp.setAttribute('autoplay','')
            temp.setAttribute('controls','')
            temp.setAttribute('loop','')
            temp.innerHTML = '<source src="' + source + '.webm" type="video/webm">'
                    + '<source src="' + source + '.mp4" type="video/mp4">';
            media.parentElement.replaceChild(temp, media);
            setTimeout(function () {
              temp.play()
            }, 0);
          } else {
            media.src = media.getAttribute('data-src');
          }

          container.classList.add('active');
      }
    </script>
  </head>
  <body>
    <input id="aboutMeToggle" class="sr-only" type="checkbox" checked="">
<label for="aboutMeToggle">Toggle author information</label>
<header>
    <div class="name">
        Brian Kardell
    </div>
    <img class="profile" src="/profile.jpg" alt="">
    <div class="tagline"><a href="/">Betterifying the Web</a></div>
    <div class="blurb">
        <ul>
            <li>Developer Advocate at Igalia</li>
            <li>Original Co-author/Co-signer of The Extensible Web Manifesto</li>
            <li>Co-Founder/Chair, W3C Extensible Web CG</li>
            <li>Member, W3C (The JS Foundation)</li>
            <li>Co-author of HitchJS</li>
            <li>Blogger</li>
            <li>Art, Science &amp; History Lover</li>
            <li>Standards Geek</li>
        </ul>
    </div>
    <div class="title">Follow Me On...</div>
    <nav>
        <ul>
            <li><a rel="me" href="https://briankardell.wordpress.com">Wordpress</a></li>
            <li><a rel="me" href="https://medium.com/@briankardell">Medium</a></li>
            <li><a rel="me" href="https://twitter.com/briankardell">Twitter</a></li>
            <li><a rel="me" href="https://github.com/bkardell/">Github</a></li>
            <li><a rel="me" href="https://codepen.io/bkardell">Codepen</a></li>
            <li><a rel="me" href="https://www.linkedin.com/in/brian-kardell-08a4264">LinkedIn</a></li>
            <li><a rel="me" href="https://www.instagram.com/kardellbrian">Instagram (for
art)</a></li>
            <li><a rel="me" href="http://fineartamerica.com/profiles/brian-kardell?">Fine Art
America (art for sale)</a></li>
        </ul>
    </nav>
</header>
    <main><div class="posted-on">Posted on null</div><article class="sectioning">
    <contextual-heading role="heading" aria-level="1">Much Ado About Nothing</contextual-heading>
    <script src="../prism.js"></script>
    <link rel="stylesheet" href="../prism.css">
    <style>
    .note {
        background-color: rgba(255,255,0,0.24);
        padding: 1rem;
        font-style: italic;
    }
    .note::before {
        content: 'Note';
        font-size: 0.8rem;
        background-color: black;
        color: white;
        padding: 0.25rem;
        margin-right: 0.5rem;
    }
    .output {
        margin-left: 1rem;
        font-family: "Courier New", Courier, monospace
    }
    .spec-quote {
        display: block;
        margin: 1rem;
    }
    section {
        margin-left: 0.5rem;
    }
    ul {
        font-style: italic;
    }
    table {
        margin: 1rem auto;
        width: 80%;
    }
    th:nth-child(1),
    td:nth-child(1) {
        text-align: left;
    }
    th:nth-child(2),
    td:nth-child(2) {
        text-align: right;
        font-style: italic;
    }
    </style>
    <p class="segue">
        Standards move slowly - far slower than the slowest project you've ever worked on.  Even the fastest standardization is  measured in years, not months, before there is wide enough deployment that most devs can really be bothered to look into it.  When we fail to get it right (as we have occasionally done) we basically get back in the very long queue to hopefully try again.  Worse, we don't get to "take back" the failure if anyone is using it either.  Some recent CSS Working Group discussions have me thinking a lot about one such particular shortcomming in standardization and how we should deal with it now.
    </p>

    <p>
        As you may, or may not be aware, CSS includes an <code>:empty</code> pseudo class, it has for some time.  Firefox 3.5, Safari 3.2, Chrome 4 all had support according to caniuse.  IE 6, 7, 8 didn't support it, but other than that, the full caniuse table is basically an entire <em>wall</em> of green.  jQuery also has supported it since the beginning (v1.0).
    </p>


    <section class="sectioning">
        <contextual-heading role="heading" aria-level="2">Currently Deployed</contextual-heading>
        <p>
            As currently deployed, the following div matches <code>:empty</code>, as I think just about everyone would expect.
        </p>

        <pre><code class="language-html">&lt;div&gt;&lt;/div&gt;</code></pre>

        <p>
            And so does this...
        </p>

        <pre><code class="language-html">&lt;div&gt;&lt;!-- still empty --&gt;&lt;/div&gt;</code></pre>

        <p>Many people find it surprising that this is even a thing that would have to be specifically called out - of course it's empty.  Others find it suprising that the first group thinks that because, of course it is not.  Whichever group you fall into, as defined, comments and processing and processing instructions don't count toward 'non-emptiness'.  However, given that, it is suprising to <em>most</em> people, it seems, that this example (currently) does not match..
        </p>
        <pre><code class="language-html">&lt;div&gt;
    &lt;!-- not empty --&gt;
&lt;/div&gt;</code></pre>

        <p>
            Can you spot the difference?  It's just whitespace in the code formatting.
        </p>

        <p>
            A lot of people think that these things (comments, "insignificant whitespace" and so on) get "parsed out" because generally, when we think about the Web, we are thinking about what we <em>experience</em> as users and the fact that as authors, our mental model is primarily based on elements.  We might "experience" neither regularly, but they are still parsed into <code>Node</code>s that still exist in the tree and that matters, if for example, you want to be able to say that the following does <em>not</em> match <code>:empty</code>,
        </p>

       <pre><code class="language-html">&lt;div&gt;This stuff is in a TextNode&lt;/div&gt;</code></pre>


        <p>
            ... despite having no actual <code>.children</code>, which seems pretty reasonable. So, these are some kind of key points in beginning to understand this discussion:
        </p>
        <ul>
            <li>
                It's possible to have 0 <code>children</code> (which is only about elements) but still have <code>childNodes</code>.
            </li>
            <li>
                It would seem that any reasonably useful definition of emptiness must care about some child nodes, because that is what text is, it's not an element - but should not care about others (see Low Uptake below)
            </li>
            <li>
                Nothing is "parsed out" or "insignificant" in terms of nodes:  The comments are nodes.  The text nodes are node, and yes, they really do contain all those whitespace characters.
            </li>
        </ul>
        <p></p>

    </section>

    <section class="sectioning">
        <contextual-heading role="heading" aria-level="2">Low Uptake</contextual-heading>
        <p>
            As I said, this has been available for some time.  Yet, it seems that when you look at data in the wild, this selector is effectively unused.  Many of those who have tried to turn to it for something have commented in some way (on social media, through blogs, mails to mailing lists, talking to people at conferences, creating other ways to solve similar problems or opening github issues) that it didn't do what they expected (or wanted, or needed).
        </p>
        <p>
            Because of this, the CSS Working Group is trying to figure out what to do and how to move forward.  In fact, it has such incredibly low uptake that the Working Group itself is ok with actually changing the <em>existing</em> definition of the standard, meaning that things that didn't match yesterday suddenly would.
        </p>
    </section>

    <section class="sectioning">
        <contextual-heading role="heading" aria-level="2">Case Closed...ish</contextual-heading>
        <p>
            Just recently the CSS working group 'resolved' to expand the definition to not count text nodes that only contain whitespace in the same way that they don't count comment nodes today.
        </p>
        <p>
            I want to stress that saying this was "resolved" doesn't make it so or final:  It really only means that this is our best plan to date that we seem to have enough agreement on.  It's not unusual for something to change - realistically speaking, something is only <em>actually</em> a standard when interoperable implementations have actually shipped and it gets some kind of measurable usage (though, it doesn't take much).
        </p>
    </section>

    <section class="sectioning">
        <contextual-heading role="heading" aria-level="2">Glass Half Empty</contextual-heading>
        <p>
            While this change would make it more practically useful for a few more cases which wouldn't work in the past, I'm actually sure whether this is good or bad.
        </p>
        <p>
            Optimistically, imagine that we get this implemented widely, quickly.  Under the best scenario, we won't really know if we got it right for 3-4 years.  However, I am more pessimistic and believe it will take longer than that - and it's entirely possible that we again fall short.  At <em>best</em> that leaves us right back where we are now, having burned a little good will along the way.  Practically, maybe worse, we may now crossed that line where we can't define <code>:empty</code> well because in expanding the usefulness slightly, it was just enough to gain enough real world use to worry people about changing it.  This has happened before.
        </p>
        <p>
            Given this, I feel like it <em>might</em> make sense to have a bit of a broader conversation <em>now</em> before determining that this is definitely the thing we want to ship.  To understand what I mean, and why I am still worried about this, let's rewind.
        </p>
    </section>

    <section class="sectioning">
        <contextual-heading role="heading" aria-level="2">How did we get here?</contextual-heading>
        <p>If you've ever read my blog, you know that I like history.  I think that "how did we get here?" can be very helpful in informing "where do we go now?" - Especially if we are reconsidering  something where we missed the mark.  So, let's review some history.</p>
         <p>
            On April 3, 2000, David Baron sent <a href="https://lists.w3.org/Archives/Public/www-html/2000Apr/0024.html">an email to the www-html mailing list</a> noting that the HTML specification at the time recommended that
        </p>
        <blockquote>User agents should ignore empty P elements.</blockquote>
        <p>
            In it, he points out that there are <em>at least</em> two ways to "ignore" them and he wasn't quite sure what it meant.  They could, for example, be ignored stylistically via the default stylesheet, or they could be dropped by the parser and not even become an element.  He also notes that there might be good reasons to avoid the latter and gives an example:  Authors could put an empty tag in markup with the intent of populating it with script.  "I'd be interested to hear the opinions of others on this matter," says David.
        </p>
        <p>
            Such a simple seeming question - but what happens next is enlightening: People don't agree.  Not just that, but they begin to ask a <em>whole lot</em> of new questions and provide very interesting rationales.  The very first reply, hours later, is in the form of a statement, not an opinion, that the  'correct' answer (i.e., there is one) is that empty <code tag-esc="">p</code> elements <em>should</em> be removed by the parser, and why he thinks that is.
        </p>
        <p>
            Cool. Except that this is immediately followed by a reply that says "I'm afraid my recollection is quite the opposite" - including why that in fact <em>couldn't</em> work in XML or XHTML and also why that line was added to the spec in the first place (because a whole bunch of stuff in the real world creates empty paragraphs as we will see in a minute, and that is often purposeful. But... now we start hearing the first comments about "ignorable white space"
        </p>
        <blockquote>...then the problem
would appear to be much harder,
since what you really want
is conditional formatting properties
depending on whether 'some' elements
contain only ignorable white space
(in the XML sense).</blockquote>
        <p>Which, as Tantek points out, isn't what most people think:</p>
        <blockquote>There is no such thing
as ignorable white space
(in any sense, HTML, XML,WXYZML, whatever)
for a complete CSS1 implementation
because you can always
have rules with white-space:pre:</blockquote>
        <p>This is interesting, and totally true... Whitespace might not be an element child, but neither is a word.  And while it might "effectively" be ignorable to authors and users, it is, actually <em>totally</em> in the DOM, and kind of has to be.  It's also interesting because he mentions CSS styling in there - but we'll come back to that...</p>

        <p>After not too much time, Jason Orendorff points out</p>
        <blockquote>There is already a CSS property 'empty-cells'
that affects how empty table cells are rendered.
Perhaps there should be an 'empty-elements' property:
<p>
  P { empty-elements: ignore; }
</p>
Or an ":empty" pseudo-class:
<p>
  P:empty { display: none; }
</p>
<p>[And that the] bit about empty paragraphs
being "ignored" should probably be removed [
from HTML itself].</p></blockquote>
        <p>
            OK, pause briefly and think about this: If you had a child right when this discussion about <code>:empty</code> began, they would have graduated highschool this year... Wow.
        </p>
        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">Now we've got a syntax for... something</contextual-heading>
        <p>
            This particular bit of thread moves to the CSS Working group and now we've got a good idea how to write a selector, but we honestly don't seem to know what it would mean.  The discussion goes on in both lists and opinions seem to abound.  One posits that this whole topic is <em>really</em> about <em>margin collapsing</em>.  Apparently, they (and maybe the spec?) maintain that that the following markup <em>shouldn't</em> match the <code>p+p</code> selector, but would, if they aren't 'ignored' in a big way:
        </p>
        <pre><code class="language-html">&lt;p&gt;&lt;p&gt;Test</code></pre>
        <!--section>
            <contextual-heading>A weird, but I think relevant, sidebar</contextual-heading>
        <p>
            Many people recognize that <code tag-esc>br</code> is a little strange.  It is a void element, it has no content nor closing tag.  At the end of the day, it's just a marker that represents a "line break".  However, if you have a look at the source of <a href="http://info.cern.ch/hypertext/WWW/TheProject.html">Tim's original WWW page</a> you'll notice that <code tag-esc>p</code> was a marker as well, like a pilcrow, that idenitifes where the paragraph starts.  There's no actual 'need' for more as the end of a paragraph is logically inferrable.  In fact, browsers still logically infer if an author messes it up.  Further, the HTML specification, even today contains several examples of paragraphs with <em>no</em> <code tag-esc>p</code> at all, and many popular formats, like markdown, have no need for it.  Similarly, if you ask for the <code>.innerText</code> of some node containing <code tag-esc>p</code>s and <code tag-esc>br</code>s, these will be represented pretty much like they are in markdown - as just text.  The reason we even have some of these elements, I think, owes to the history of HTML and the fact that they come from the very earliest atttempts at marking up documents.
        </p>
        </section -->
        <p>
            Dan Connoly points out that an "empty paragraph" is conceptual nonsense  -such a thing does not exist for any traditional definition of a 'paragraph'.  He  offers that a paragraph "Should include at least one character, word, image, or form control".  While this is 'technically true', it is suprisingly not actually especially helpful.  Why?  Well, because practically speaking, it doesn't matter for at least two important reasons.  First, there are <em>plenty</em> of empty <code tag-esc="">p</code> elements in the wild and, as David originally pointed out, the document might not be 'done'.  Further, it seems incomplete: What if that "one character" <em>also represented whitespace</em> - like a non-breaking space, or a carriage return, or an entity representing one of those?  All of these are just as conceptually illogical.
        </p>
        <p>
            Anyways, the topic goes on.
        </p>
        <p>
            Someone else points out that pseudo classes with generated content will mean the thing isn't really 'empty' by some definitions either... What about those?  Someone else asks about actual spaces vs entities.  There are comments that in terms of 'rendering' - a p containing a hidden form control 'kinda seems empty' too.  Eh, wait... Does it matter if that hidden form control has a value?  Is a form control's <code>value</code> property the same a TextNode's <code>.data</code> property?  Is a <code tag-esc="">p</code> containing only a <code tag-esc="">span</code> that is <code>display: none;</code> empty? Hmm... What about a comment?  That's not an <em>element</em> child, but it too parses into a node child...  If a thing contains only a comment, is it empty?  And, well, is <code tag-esc="">p</code> really <em>that special</em>, or does these same concerns apply to other things too?
        </p>

        <p>
            Wait, wait, wait... what were we talking about again? Parsing? Semantics? Rendering?
        </p>
    </section>

    <section class="sectioning">
        <contextual-heading role="heading" aria-level="3">Observations and opinions</contextual-heading>
        <p>
            There are a few things that I generally take away from all of this.
        </p>
        <section class="sectioning">
            <contextual-heading role="heading" aria-level="4">Over Stressing 'Correctness' is Probably a Red Herring</contextual-heading>
            <p>
             Arguing about whether a document is 'semantically correct' seems to eat a log of time here, or arguing that authors or tools shouldn't create trees that seem 'dumb' or 'illogical'. However, the truth is that there are numerous, reasonable ways for nearly all of these sitiations to happen, and tons and tons of existing content which shouldn't have to dramatically change either in order to utilize a concept of emptiness to improve styles.
            </p>
        </section>

        <section class="sectioning">
            <contextual-heading role="heading" aria-level="4">Only the DOM</contextual-heading>
            <p>
                Over the years, a lot of people have brought up a lot of points about how CSS might affect this: For example that CSS 'styles' affect whitespace - or that you can generate content.  For example, from a user's perspective, this is not empty:
            </p>
            <pre><code class="language-html">&lt;p id="one"&gt;&lt;/p&gt;
&lt;style&gt;
    #one::before {
        content: 'empty?';
    }
&lt;/style&gt;</code></pre>
            <p>
                While this may "feel" like an intuitive way to think about emptiness at first, it feels like any consideration of 'what CSS does' means we're probably looking at the wrong things.  CSS selectors cannot rely on the application of CSS.  This would itself create circularity which, in CSS is a deal breaker.  For example, that would make it possible to write:
            </p>
            <pre><code class="language-html">&lt;p id="one"&gt;&lt;/p&gt;
&lt;style&gt;
    #one:empty::before {
        content: 'empty?';
    }
&lt;/style&gt;</code></pre>
             <p>
                 Assuing that the DOM matches empty, would cause CSS to match a rule which says it is not, which would cause the rule to no longer apply, and on and on.  There are probably ways to build in resilience to this very specific example, but still, it violates fundamental principles of CSS and so, we have to focus on the structure and semantics of the DOM as if CSS were <em>not</em> applied, because it isn't at this stage.
             </p>
        </section>



        <section class="sectioning">
            <contextual-heading role="heading" aria-level="4">Scope and Text</contextual-heading>
            <p>
                While many of the current discussions in the CSS Working Group are very focused on a few very specific examples, I believe this is problematic too.  I think that the reason that we are looking at these examples in the first place it because they distil the simplest possible example of something that is both reasonable, exists in the real world, and is currently problematic.  I think it's kind of a mistake to imagine that they remotely represent the actual 'scope' of the problem, and here's why..
            </p>

            <p>
                If you look back at all of the discussions, it would seem most of them actually have to do with some kind of <em>text</em>.  Elements, Nodes, entities, values, semantics, intent, etc - these things mostly seem to be getting in the way of asking for what often seem to want.  It is entirely possible to fix those cases while still leaving most of the same conceptual problems. For example, every single element in the example below is arguably 'empty' in the sense that there is no useful text for the user to be had.
            </p>

           <pre><code class="language-html">&lt;ul&gt;
    &lt;li&gt;
    &lt;li&gt;&amp;nbsp;
    &lt;li&gt;&lt;br&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;div class="my-component"&gt;
    &lt;link rel="stylesheet"
        href="https://example.com/my.css"&gt;
&lt;/div&gt;
</code></pre>
            <p>
                Which of the above should match <code>:empty</code>? Today, even with the new change, few would.  Are each of the <code tag-esc="">li</code> elements empty?  Why?  If they all are, what about the <code tag-esc="">ul</code>?  Today, the <code tag-esc="">ul</code> definitely would't be.  The <code tag-esc="">link</code> itself would be, but not the <code>.my-component</code> div.  However, that is precisely what can happen if the thing you drag into the page contains a <code tag-esc="">link</code> node, and if you need a concept of <code>:empty</code> today so that that can be finished and configured, you probably don't want that to count toward empiness any more than a comment node.  In fact, if your element contains void tags that imply closing, they cannot contain text content.  They will be empty themselves, but in terms above, should they count as empty?  Yes, you <em>could</em> style them as visible, but they aren't supposed to be, right?
            </p>
            <p>
                Saying "If I am not in some edit mode, I'd like to hide <code tag-esc="">li</code>s which contain only things about whitespace, because that doesn't make sense" seems reasonable - and it seems reasonable that all of those could fit one reasonable definition of that, but it has to be about more than it is now.
            </p>
            <p>
                Further, what we are talking about so far is very simple things - but modern tools let you drag, drop, and configure more advanced things than that, and frequently that is done by including some hunk of code which might include a <code tag-esc="">script</code>
            </p>
        </section>



             <pre><code class="language-html">&lt;p&gt;&nbsp;&lt;/p&gt;</code></pre>
            <p>
                This surprises a number of people because they think "whitespace is insignificant in HTML and it is just parsed out".  But that is kind of an overstatement of what <em>insignificant whitespace</em> means.  That doesn't mean it isn't parsed, it means it shouldn't be <em>displayed</em>. Go ahead and ask that node how many <code>.childNodes</code> it has, and it will happily reply that the answer is <em>1</em>, not <em>0</em>.  That child is a <code>TextNode</code> holding the data <code>" "</code>.
            </p>
    </section>


    <section class="sectioning">
        <contextual-heading role="heading" aria-level="3">WDYM Empty?</contextual-heading>

        <p>
            See, I think that this is part of the problem: There not only seems to be no single, universal answer here - there are completely different asks and mental models.  I asked this question on twitter recently, and received a lot of relies.  Interestingly, there was a lot of variance and the variety of observations aligned pretty well with the same sorts of discussions from 2000.
        </p>
        <p>
            This is kind of unsuprising if you think about it, we have so many subtley different definitions of some kind of "nothing":  0, null, void, undefined, empty, etc.  And in terms of the DOM, we have many constructs and use cases.
        </p>
        <p>
            Looking back across history and comments I think there are some fairly certain observations that we can add to clarify the fuzziest ends of the problem.
        </p>


    </section>
    <section class="sectioning">
        <contextual-heading role="heading" aria-level="3">So, now what?</contextual-heading>

        <p>Well, it seems to me that no discussion of this goes long before questions arise which are phrased based on text, rather than something about children or elements. Editors are a really common theme </p>

        <p>So far, really a lot of discussion focuses on child



                A lot of the discussions focus on a really simple 'does it have child nodes' or even 'does it have element children' mental model.  This is kind of the view we have now, and if you can believe it, one of the complains we have "on the record" is about empty paragraphs (actually lots of tags that 'can' be used as makers) because people like to indent code and it can lead to, for example, there being a "p" or an "li" that still contains a space and currently doesn't match the definition of <code>:empty</code> today.</p>
            <p>Further, it seems we have a number of "child or descentant" asks or proposals that feel like they could solve any such case pretty well except that they can't consider the other perspectives listed below.   Because of this, I think 'child nodes' as the primary view here is a red herring and we should kind look elsewhere for these particular ideas.</p>
        </section>

        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">The "something about text" Perspective</contextual-heading>
            <p>
                I think that, ultimately really a lot of the things raised have more to do with 'text' than they do about elements.  Most of the problematic cases that come up have to do with text somehow - even those weird "text, but as an element" or "text, but an entity" issues.  And, just like any time you are dealing with text, there are probably a few ways you might want to look at that - none of them are invalid, really.  You might want to trim, you might not.  You might want things escaped, or not.
            </p>
            <p>
                Here's where things get just a little tricky though - text as structure is weird. Let me demonstrate..
            </p>

            <pre><code class="language-html">&lt;!-- if you want this to be empty "because it doesn't contain text" --&gt;
&lt;p&gt; &lt;/p&gt;

&lt;!-- and this to be empty "because it doesn't contain text" --&gt;
&lt;p&gt;
   &lt;!-- still empty --&gt;
&lt;/p&gt;

&lt;!-- it stands to reason that neither does this --&gt;
&lt;p&gt;
    &lt;strong&gt;&lt;/strong&gt;
&lt;/p&gt;</code></pre>

        <p>
            That is, if we really want to talk about 'absence of text content' of some kind than it is unlikelywe probably want to talk about a <em>descendant</em> relationship and not strictly a parent/child one.  This isn't typically how CSS works - you can't generally style parents based on their qualities of their children.  Despite it also having been in the draft for years before anyone thought of <code>:empty</code>, <code>:has</code> (also supported by jQuery from the beginning, for the same reason) has been elusive precisely because it's not how CSS works and no one can seem to figure out how to make that work performantly.  So... perhaps we are at an impasse.
        </p>
        <p>
            Well... Maybe not. describe limited has
        </p>
<p>

                If you solve for that problem, it seems to me that either very nearly all or maybe even actually all of the things can be possible without so many confusing questions.
            </p>

            <p>
                That makes sense to me because the Web is about text. As 'spiffy' as we might make it, HTML was envisioned with this perspective in mind. HTML was originally supposed to be the "least common denominator" - the thing you could always ask for.  In the original vision, you might have asked for an image, desribing the sorts of images  you could understand, and the server could tell you "I don't have any of those, but let me tell you what I can about the image in this common format (HTML) we can both understand".  This basic idea of the importance of text still holds true today in HTML today - we need text all over.  It's even true of images in a sense, and  form elements - the reason they more or less all have to 'enhance' an input is that that is the simple, most basic thing - some text.
            </p>

            <p>
                The thing is that the history of text in HTML is itself confused and there are a few 'possible' ways to look at something.  I think the best thing is to accomodate
            </p>

            <p>
                It seems to me that this would simplify things and the answers are often similar.
            </p>
            <pre><code class="language-html"><!-- Does this element contain text? Nope. -->
&lt;p&gt;&lt;/p&gt;

<!-- how about this one? well, here it depends what we are looking at.  We could look at the nodeType and the .data property, or we could look at that and trim() or think about it like .textContent of a text node and decide if we care about whitespace. If we had a way to indicate that, we could answer either appropriately -->
&lt;p&gt; &lt;/p&gt;


<!-- how about this one? well, same as the above really -->
&lt;div&gt;&lt;br&gt;&lt;/div&gt;


&lt;script&gt;
let pEl = document.querySelector('#id');

console.log(`"${pEl.innerText}"`);
// logs " " (1 character, not an entity - this is the idea of "insignificant whitespace")

console.log(`"${pEl.innerText}"`);
// logs "   " (3 characters, no entities)

console.log(`'${pEl.childNodes[0].data}'`)
// logs "   " (3 characters, no entities)

console.log(`'${pEl.childNodes[0].wholeText}'`)
// logs "   " (3 characters, no entities)


console.log(`'${pEl.childNodes[0]}'`)
// logs " &amp;nbsp; "

&lt;/script&gt;
            </code></pre>


        </section>



        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">The "Insignificant Whitespace"  Perspective</contextual-heading>
            <p>
                One of the easiest ways to foul up what currently exists is like this..
            </p>
             <pre><code class="language-html">&lt;p&gt;&nbsp;&lt;/p&gt;</code></pre>
            <p>
                This surprises a number of people because they think "whitespace is insignificant in HTML and it is just parsed out".  But that is kind of an overstatement of what <em>insignificant whitespace</em> means.  That doesn't mean it isn't parsed, it means it shouldn't be <em>displayed</em>. Go ahead and ask that node how many <code>.childNodes</code> it has, and it will happily reply that the answer is <em>1</em>, not <em>0</em>.  That child is a <code>TextNode</code> holding the data <code>" "</code>.
            </p>
            <p>
                This trips up a lot of authors for several reasons.  First, I think because their mental model is built around <em>elements</em> and a view of the DOM based on dev tools in which a text node doesn't 'look' like an element node.  Some of this, I think, is just a mental block because if you ask most of the same people whether the following is empty..
            </p>

             <pre><code class="language-html">&lt;p&gt;what about this&lt;/p&gt;</code></pre>

             <p>... they would answer "of course not", and so it seems a given that a least a portion of this is requires modifying our current understanding.</p>
             <p>
                 That said, even if you understand this, the question of whether 'insignificant whitespace' should be considered goes beyond just strict theory.  A feature isn't valuable because it is strictly correct, it is valuable because it can be used and, it appears that way too many things rely on "insignificant whitespace" working out to be, well, insignificant in determining emptiness... It's just too easy and common to create that particular situation and frequently, those are things that desparately want a concept of emptiness too (a CMS that allows you to drag in and then populate things somewhat visually, for example).
             </p>
             <p>
                 This too, seems to me a reasonable interpretation: If the text node contains only <em>insignificant whitespace</em> that is still considered 'empty'.
             </p>
        </section>


        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3"><strike>The "Insignificant Whitespace Including Generated Content"  Perspective</strike></contextual-heading>
            <p>
                I'm going to list this one here because it seems to come up a lot and it is a non-starter, but also I think has some interesting observations that go along with it that either raise or help answer a number of other questions...</p>

            <p>
                A number of people seem to think that the following <code tag-esc="">p</code> should <em>not</em> be considered <code>:empty</code>.
            </p>
             <pre><code class="language-html">&lt;p id="one"&gt;&lt;/p&gt;
&lt;style&gt;
    #one::before {
        content: 'empty?';
    }
&lt;/style&gt;
             </code></pre>
            <p>
                I'm using an id here simply to avoid confusion that this might apply to any other example.  People see this render in devtool as something which appears to be <em>inside</em> of the paragraph, and clearly content is rendered - so they think "See? It is not empty. It has 'stuff' in it."</p>
            <p>
                As I said, while this may "feel" intuitive at first, this is a non-starter for reasons which will probably appear obvious in retrospect:  CSS selectors cannot rely on the application of CSS.  This would itself create circularity which, in CSS is a deal breaker.  For example, that would make it possible to write:
            </p>
            <pre><code class="language-html">&lt;p id="one"&gt;&lt;/p&gt;
&lt;style&gt;
    #one:empty::before {
        content: 'empty?';
    }
&lt;/style&gt;</code></pre>
             <p>
                 The DOM is empty, which causes CSS to match a rule which says it is not, which cause the rule to no longer apply, and so on.  There are probably ways to build in resilience to this very specific example, but still, it violates fundamental principles of CSS.
             </p>
             <p>
                 As I said though, I think it is interesting to point out not just for clarity but because it points to/allows us to stress two kind of important things:  First, CSS selectors operate on the DOM tree. Second, children in the DOM tree are not the only way that users "get" some kind of content.  There is no DOM node created in this case - but there is a <em>box</em> containing actual text drawn on the screen and there is a node created in the <em>accessibility tree</em>.  Our measure of 'emptiness' can't really include <em>exactly</em> what content is actually presented to an end user visually or accessibly which leads me to the next one...
             </p>
        </section>

        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3"><strike>From the End-User's Perspective Empty</strike></contextual-heading>
            <p>
                This is really just a correlary to the above one, but a lot of people would like to define emptiness in terms of what is shown to end-users of some kind (whether through the screen or accessibility tree) - so, for example, they'd like this to match:
            </p>

            <pre><code class="language-html">&lt;p id="two"&gt;
    &lt;span style="display:none;"&gt;error&lt;/span&gt;
&lt;/p&gt;</code></pre>

            <p>
                While that totally makes sense to me as some kind of a <em>want</em>, it too is a non-starter for the same reasons listed in the section above: It relies on the application of CSS.
            </p>
        </section>


        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">The Does "Insignificance" Actually Matter Perspective</contextual-heading>
            <p>
                So, if we intentially omit 'insignificant whitespace' I guess a part of the question is how and why. Examples would help
            </p>
             <pre><code class="language-html">&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;Tab;&lt;/p&gt;
&lt;p&gt;&amp;#x00009;&lt;/p&gt;
&lt;p&gt;&amp;#9;&lt;/p&gt;
&lt;p&gt;&amp;NewLine;&lt;/p&gt;
&lt;p&gt;&amp;#x0000A;&lt;/p&gt;
&lt;p&gt;&amp;#10;&lt;/p&gt;</code></pre>
            <p>All of the above express paragraph that contains only whitespace and, for example the <code>nodeType</code> and <code>.data</code> property of the two is actually pretty much  indistinguishable in browsers regardless of whether those were expressed as entities or not.  Further, what about elements like <code tag-esc="">pre</code> for example?  In these, the same 'insignificance' suddenly <em>is</em> significant.
            </p>
            <p>
            Maybe this implies that "significant whitespace" isn't actually what we're after at all... Maybe that is just a thing we currently observe because we all expect that very particular one to work for that reason.  Maybe.</p>
            <p>A lot of the use cases that determine that a strict definition of empty sans insignificant whitespace is inadequate, it seems, can also create entity issues like this as well.  Most notably, WYSIWG editors in which the 'intent' becomes  disconnected and where it is unclear which of those is always appropriate.
            </p>
            <p>Because of these points, I think (again, currently) that one <em>could</em> (I am not attempting to do so specifically) make a rational case that "insignificance" isn't the problem and that "intentionality of how we expressed whitespace" shouldn't really be considered here either.  That, perhaps a mechanism allowing us to consider those as empty would be useful.  The same one? A different one? Again, I dont know and I'm not making a case, I am simply attempting to catalog the debates, rationales and discussions without leaning too hard in any very specific direction.</p>
        </section>

        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">The Does "Elementness" Actually Matter Perspective</contextual-heading>
            <p>
                Depending on where you fall down on the item above, it's not always clear what to do with this:
            </p>
             <pre><code class="language-html">&lt;div&gt;&lt;br&gt;&lt;/div&gt;</code></pre>
            <p>The <code tag-esc="">br</code> element is a legacy concept that predates the W3C and, well, it's weird.  Pretty much everyone recognizes this as an element which <em>means</em> a character... about whitespace.</p>
            <p>
                If whitespace "as meaning" rather than "as style" is based on the tree and based on all of the things in all the previous points (how they are styled is irrelevant) and that WYSIWG editors disconnect, and so on - I (again, currently) believe here too one could make a fairly reasonable argument that a <code tag-esc="">br</code> child should be treated the same as a <code tag-esc="">br</code> entity, or at least having a way to consider that similarly empty as well.
            </p>
        </section>

        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">Is it about the content model or characterness?</contextual-heading>
            <p>
                Oh my... I know this might sound a little off to some at first, but what about an <code tag-esc="">hr</code>?  While we probably like to think of it as a "horizontal rule", that is at least to some extent about <em>rendering</em>.  According to the (current) specification it actually <em>represents</em> a 'paragraph-level thematic break' which is very similar in nature to <code tag-esc="">br</code>:  It is an element which can't itself contain content and implies "break-ed-ness" but it doesn't map cleanly to entity-like 'character-ness'.
            </p>
            <p>
                Is it empty? I don't know - this feels like a stretch (to me), but I see the argument: If your definition really relies on containing some kind of 'character content' then, I kind of get it... maybe.
            </p>
        </section>


        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">Elements That <em>Kinda Mean</em> They Should Themselves Not Contain Stuff</contextual-heading>
            <p>
                There are some things that <em>seem</em> like the above, but there is a case to be made that they are different.  For example
            </p>

            <pre><code class="language-html">&lt;p id="three"&gt;&lt;span hidden&gt;error&lt;/span&gt;&lt;/p&gt;</code></pre>

            <p>
                While this seems similar to the <code>style="display:none;"</code> one above  and many would undoubtedly make the case that authors can override the meaning of hidden with CSS so that it not, in fact, actually 'hidden' - that's about styling, not meaning.  To do so violates the meaning.  Because of this, one could make what I think (currently at least) seems like a rational case that this is actually quite different from the above - almost the inverse in that it stresses the importance and meaning of the tree only.  According to the <em>meaning</em> of the DOM tree and not considering CSS, this is defined as something which should not be displayed and is <em>irrelevant</em>, much like insignificant white space.
            </p>

            <p>
                In fact, depending on your view of this one, a number of elements could not count against a measure of emptiness.  Any void tag or thing with a content model of none...  <code tag-esc="">template</code> for example, or <code tag-esc="">link</code>.  Could they be displayed?  Sure, but that doesn't change their meaning and by definition they can't contain characters, so if your definition is somehow about characters, I can definitely see the use in something that says "no point in counting these".
            </p>
        </section>

        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">The "Other Kinds of Empty" Perspective</contextual-heading>
            <p>
                Let's take a detour and talk about something a little different. So far we've been talking about things in terms of whether something has childNodes of some kind and which kinds count.  But, in the last section, I mentioned 'void tags'.  Most form elements are <code tag-esc="">input</code>s which are, themselves, void and can't "contain" text in the way we've been talking about so far and would therefore seem to fit in with whatever rationale one accepts for the section above.... Except, maybe not.
            </p>
            <p>
                Why?   Because they obviously do  "contain" text at some point - that is their whole point in being.  But they "contain" it in an entirely different sense.
            </p>
            <p>
               Form elements already have other relevant pseudo-classes <code>:valid</code>, <code>:invalid</code> and <code>:indeterminate</code> for example.  Used together these still leave a gap in most people's mind in creating a good UI.  We don't generally want a form loading and looking as if it contains a bunch of errors.  Technically speaking, it totally does - but that isn't what users expect or developers want and so it seems reasonable to expect that there would be a way to omit that state.   Many people, it seems, turn to the spec when they are thinking about form elements, looking for this concept of emptiness too, and that doesn't exist either.
            </p>
            <p>
                This one is unique enough that currently the CSS working group has agreed to take this up under the working name <code>:blank</code>, instead of trying to solve it with <code>:empty</code>.  Is that the right move? I don't know. I do think it helps illustrate just how diverse the things that need some concept of "emptiness" are though.
            </p>
            <p>
                I think the important thing here is that the concept of emptiness here has to do with a property rather than children... and... it might not be the only one.  For example, while void elements can't contain text content inside (or any childNode of any kind really) - it can have other content-oriented properties.  An image, for example, can have alt text - or just about anything could have an <code>aria-label</code>. Do we care? Does it change things?  Again, I don't know.  Maybe? Sometimes?
            </p>
        </section>

        <section class="sectioning">
            <contextual-heading role="heading" aria-level="3">The Nothingness Within</contextual-heading>
            <p>Of course, most of what we are stressing about in most of the above things are about some kind of debate about "what we should and shouldn't consider about some kind of childNode" - but realistically, at least some of this is because that is how we are thinking about it, or accustomed to thinking about it.</p>
            <p>Many authors, it seems, really want something conceptually similar - not just about children, but about descendants.  In fact, in this light, many of the above become clearer if we look at this as the question instead. If you want to know if a form element contains nothing - you very probably want to be able to say 'an element that contains one of those'.  If you want to know if something 'contains' something text node related, you probably don't care whether it is wrapped in a paragraph or a strong inside a span inside a paragraph.</p>
            <p>This is tricky because in CSS selectors, historically, we don't do that: The thing that you can style is always the last thing in a selector. Except that we have wanted to since at least 1998 when <code>:has</code> was discussed.  We still don't hav <code>:has</code> because no one can figure out a way to keep CSS performant if we add that ability.  But we <em>do</em> have some things like <code>:focus-within</code> that is a very specific kind of <code>:has</code> that we can make work.  Is it possible that we could somehow optimize a thing about containing text nodes?  Maybe.  Is that a good idea?  I don't really know.</p>

        </section>

    </section>


    <section class="sectioning">
        <contextual-heading role="heading" aria-level="2">So...</contextual-heading>
        <p>So.  That's it.  These are all of the things that I have heard, so far.  The only real observation that I have, besides "there are a lot of ways people see this" is that it seems to me that the ones listed here break into a few broad categories - or at least could cleave somewhat more naturally along these joints:  a) Things that want to look at children directly, as nodes.  b) Things that really care about 'text content' and c) things that care about some property oriented view of content.</p>

        <p>If you have some other thing that isn't documented here, please share it with me (all of my contact info is in the bar on this page).  As I say, many of these desires don't sound unreasonable, but they also don't sound like they can be accomodated under a single name with no arguments or anything.  What I'd really like is for CSS to give us the reasonable powers authors need, but I'm still not really sure what they are yet.</p>
    </section>

    <!-- p class="thanksTo"></p -->
</article></main>

  
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-88027178-1', 'auto');
    ga('send', 'pageview');
  </script>

  <script>
    Array.prototype.slice.call(document.querySelectorAll('.optional [data-src]')).forEach(function (optional) {
      var prefs = window.localStorage.downloadsPrefs,
          clickToSee;
      if (prefs === 'true') {
        activateOptional(optional);
      } else {
        clickToSee = document.createElement('div');
        clickToSee.classList.add('clickToSee')
        clickToSee.innerHTML = '<button>Click to see media</button>';
        clickToSee.style.textAlign = 'center';
        clickToSee.style.border = 'none';
        optional.parentElement.insertBefore(clickToSee, optional.nextSibling);
        clickToSee.firstElementChild.addEventListener('click', function () {
          activateOptional(optional);
        })
      }

    })
  </script>

</body></html>