<html lang="en" resource-type="blogpost"><head>  
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="view-transition" content="same-origin"> 

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@briankardell">
    <meta name="twitter:creator" content="@briankardell">
    <meta name="twitter:title" content="i is=&quot;the walrus&quot;">
    <meta name="twitter:description" content="It's become a fairly regular occurence for me to encounter someone on social media expressing some kind of frustration with Custom Elements.  As both an avid user of them myself an">
    <meta name="twitter:image" content="http://www.jabberwocky.com/carroll/pics/glass21.gif">
    <!-- meta name="monetization" content="$ilp.uphold.com/kKU4GXiRwhnf " -->
     
    <link rel="alternate" type="application/rss+xml" href="https://bkardell.com/blog/feed.rss" title="bkardell.com/blog rss feed">
    <title>i is="the walrus"</title> 
    <style>/*!
 * Web Fonts from Fontspring.com
 *
 * All OpenType features and all extended glyphs have been removed.
 * Fully installable fonts can be purchased at https://www.fontspring.com
 *
 * The fonts included in this stylesheet are subject to the End User License you purchased
 * from Fontspring. The fonts are protected under domestic and international trademark and 
 * copyright law. You are prohibited from modifying, reverse engineering, duplicating, or
 * distributing this font software.
 *
 * (c) 2010-2023 Fontspring
 *
 *
 *
 *
 * The fonts included are copyrighted by the vendor listed below.
 *
 * Vendor:      Horizon Type
 * License URL: https://www.fontspring.com/licenses/horizon-type/webfont
 *
 *
 */

@font-face {
    font-family: 'acherus_militant_1_-_light.otf';
    src: url('/acherus_militant_1_-_light.otf-webfont.woff2') format('woff2'),
         url('/acherus_militant_1_-_light.otf-webfont.woff') format('woff');
    font-weight: normal;
    font-style: normal;

}


.captioned-image {
    background-color: #eaeaea;
    display: block;
    overflow: hidden;
    padding: 1rem;
    text-align: center;
    font-style: italic;
}

.captioned-image.p-attached {
    width: 40%;
    display: inline-block;
    margin: 0 1rem 2rem 1rem;
}

section > .captioned-image.p-attached {
    margin-top: 1.5rem; /* correct for heading size*/
}

 pre { overflow-x: auto }

.captioned-image.p-attached.p-attached-left {
    float: left;
}

.captioned-image.p-attached.p-attached-right {
    float: right;
}

.captioned-image.p-attached + * + * {
    clear: both;
    margin-top: 2rem;
}


.captioned-image img, .captioned-image video {
    display: block;
    max-width: 100%;
    margin: 0 auto 1em auto;
}
.source {
    font-style: italic;
}
body {
    display: grid;
    grid-template-columns: 25rem auto;
    font-size: 1.1rem;
    font-family: 'acherus_militant_1_-_light.otf';
    font-weight: 400;
    font-size: 1.25rem;
    line-height: 1.625;
    margin: 0;
    background-color: rgb(249, 246, 246);
}
h1 { margin: 0.5rem; }
code-format {
    border-left: 0.5rem solid rgba(123,115,209,0.35);
    display: block;
    padding: 0.5rem;
    margin-bottom: 1rem;
}

contextual-heading {
    display: block;
    margin-top: 2rem;
}

h1, [aria-level="1"] {
    color: black;
    font-size: 1.45rem;
}

h2, [aria-level="2"] {
    color: black;
    font-size: 1.35rem;
}

h3, [aria-level="3"] {
    color: black;
    font-size: 1.25rem;
}

h4, [aria-level="4"] {
    color: black;
    font-size: 1.2rem;
}

h5, h6, [aria-level="5"], [aria-level="6"] {
    color: black;
    font-size: 1.2rem;
    font-weight: bolder;
}

.posted-on {
    font-style: italic;
    font-size: 0.8rem; 
    text-align: right;
    margin-bottom: 1rem;
}

ul, li {
    margin: 0.5rem;
    text-align: left;
}

.authorinfo {
    height: 100%;
    padding-top: 1rem;
    padding-right: 0;
    background-color: #fbf5e9; 
    display: block;
    background-image: linear-gradient(to right, #c7cccc, #dde0e8 );
    border-right-width: 1px;
    border-right-style: dotted;
}

.tagline {
    font-style: italic;
    text-align: center;
}
 
[tag-esc] {
    color: maroon;
    font-family: Courier, "Lucida Console", monospace;
}

[tag-esc]::before {
    content: '<';
}

[tag-esc]::after {
    content: '>';
}

main {
    min-width: 50%;
    width: 80%;
    padding: 1rem;
}
header .title {
    background-color: rgba(123,115,209,0.35);
    padding: 0.3rem;
    padding-left: 0.25rem;
    font-weight: bolder;
    font-size: 1rem;
    border-left: 1rem solid #999298;
}

header .profile {
    width: 50%;
    margin: 1rem 25%;
}

header .title + nav {
    font-size: 0.9rem;
}

header .blurb {
    font-size: 0.9rem;
    text-align: center;
}
header .name {
    text-align: center;
    font-size: xx-large;
}
.segue {
    font-style: italic;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
}

#aboutMeToggle {
    display: none;
}


:where(pre:has(code[class*="language"])) {
    display: block;
    background-color: black; 
    padding: 0.5rem;
}

code[class*="language"] {
    min-width: fit-content;
}

spicy-sections:not([affordance]) > h2 {
  clip: rect(0 0 0 0);
  clip-path: inset(50%);
  height: 1px;
  overflow: hidden;
  position: absolute;
  white-space: nowrap;
  width: 1px;
}

main article { max-width: 100em; margin: auto; }
/* this needs rethinking, it wants a selector like 'not flow content' */
article>*:not(contextual-heading,a), section>*:not(contextual-heading,a) {
    margin-left: 0.45rem;
}

blockquote {
  font-family: serif;
  background: #f9f9f9;
  border-left: 10px solid #ccc;
  margin: 1.5em 10px;
  padding: 0.5em 10px;
}
blockquote:before {
  color: #ccc;
  content: open-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-right: 0.25em;
  vertical-align: -0.4em;
}

blockquote:after {
  color: #ccc;
  content: close-quote;
  font-size: 2em;
  line-height: 0.1em;
  margin-left: 0.25em;
  vertical-align: -0.4em;
}
 

@media (max-width: 800px){
    body {
        grid-template-columns: 1fr;
    }
    .authorinfo {
        height: auto;
        border-bottom: 1px solid #afafff;
        padding-top:  0;
    } 

    main { width: 95%; margin: 0 auto;}

    .captioned-image.p-attached {
        width: 100%;
        margin: 1rem 0;
    }

    .captioned-image.p-attached.p-attached-left,
    .captioned-image.p-attached.p-attached-right {
        float: none;
    }

    #aboutMeToggle {
        display: block;
        background-color: #675e5e;
        color: white;
        padding: 0.25rem;
        padding-left: 0.5rem;
        border-left: 1rem solid black;
    }

    header li { display: inline; margin-left: -0.5em; }
    header .blurb li::after { content: '; '; }
    header  nav li {
        display: inline-block;
        margin-left: 0.35rem;
        margin-right: 0.35rem;
    }
    header .title {
        width: 100%;
    }
    main li .source { display: block; }

} 

spicy-sections {
    --const-mq-affordances:
      [screen and (min-width: 600px) ] collapse |
      [screen and (min-width: 801px) ] tab-bar
    ;
    display: block;
}

spicy-sections.authorinfo {
    --const-mq-affordances:
      [screen and (max-width: 801px) ] collapse
    ;
}


spicy-sections.single {
    --const-mq-affordances:
      [screen ] collapse 
;
}

[role="tab"] {
    margin-right:  1.5rem;
}


</style>
    <style> 
      .captioned-image { font-size: 0.9rem; }
      .thanksTo { font-style: italic; font-size: 0.8rem; }
    </style>
    <script>
      var activateOptional = function (media) {
        var source = media.getAttribute('data-src'),
            temp,
            container = media.parentElement;

          if (media.nextSibling && media.nextSibling.matches) {
            if (media.nextSibling.matches('.clickToSee')) {
              media.parentElement.removeChild(media.nextSibling);
            }
          }
 
          if (media.tagName === 'VIDEO') {
            temp = document.createElement('video')
            temp.setAttribute('autoplay','')
            temp.setAttribute('controls','')
            temp.setAttribute('loop','')
            temp.innerHTML = '<source src="' + source + '.webm" type="video/webm">'
                    + '<source src="' + source + '.mp4" type="video/mp4">';
            media.parentElement.replaceChild(temp, media);
            setTimeout(function () {
              temp.play()
            }, 0);
          } else {
            media.src = media.getAttribute('data-src');
          }

          container.classList.add('active');
      }
    </script>
  </head>
  <body>
    <spicy-sections class="authorinfo">
<h2 id="aboutMeToggle" defaults-on-match="">Author Information</h2>
  
<header>
    <div class="name">
        Brian Kardell
    </div>
    <img class="profile" src="/profile.jpg" alt="">
    <div class="tagline"><a href="/">Betterifying the Web</a></div>
    <div class="blurb">
        <ul>
            <li>Developer Advocate at Igalia</li>
            <li>Original Co-author/Co-signer of The Extensible Web Manifesto</li>
            <li>Co-Founder/Chair, W3C Extensible Web CG</li>
            <li>Member, W3C (OpenJS Foundation)</li>
            <li>Co-author of HitchJS</li>
            <li>Blogger</li>
            <li>Art, Science &amp; History Lover</li>
            <li>Standards Geek</li>
        </ul>
    </div>
    <div class="title">Follow Me On...</div>
    <nav>
        <ul>
            <li><a rel="me" href="https://briankardell.wordpress.com">Wordpress</a></li>
            <li><a rel="me" href="https://medium.com/@briankardell">Medium</a></li>
            <li><a rel="me" href="https://twitter.com/briankardell">Twitter</a></li>
            <li><a rel="me" href="https://github.com/bkardell/">Github</a></li>
            <li><a rel="me" href="https://toot.cafe/@bkardell">Mastodon</a></li>
            <li><a rel="me" href="https://bsky.app/profile/bkardell.com">Bluesky</a></li>
            <li><a rel="me" href="https://codepen.io/bkardell">Codepen</a></li>
            <li><a rel="me" href="https://www.linkedin.com/in/brian-kardell-08a4264">LinkedIn</a></li>
            <li><a rel="me" href="https://www.instagram.com/kardellbrian">Instagram (for
art)</a></li>
            <li><a rel="me" href="http://fineartamerica.com/profiles/brian-kardell?">Fine Art
America (art for sale)</a></li>
        </ul>
    </nav>
</header> 
</spicy-sections>
<script>
  /*
    You're probably wondering "Do I need to write this?""
    "Is this part of it?"  No... If you're interested tho - 
    Custom elements have a FOUC/PE gap 
    (see https://github.com/whatwg/html/issues/6231).
    This is a slightly better experience: It 
    will be hidden _if JS is enabled_, and 
    will be shown as it is defined, 
    or after 1 sec, whichever is first.
  */
  let ss = document.createElement("style");

  ss.innerHTML = `html:not(.lldelay) :not(:defined) { visibility: hidden; }`;
  document.head.appendChild(ss);

  setTimeout(() => {
    document.documentElement.classList.add("lldelay");
  }, 1000);
</script>
    <main><div class="posted-on">Posted on 11/23/2017</div><article posted-on="11/23/2017" class="sectioning">
    <style>
		/*body:not(.preferences-set) > :not(main) { display: none; }
		body:not(.preferences-set) {
			background-color: #444;
			color: white;
		} 
		*/
		body:not(.prefers-images) .captioned-image:not(.active) > * { border: 1px dashed gray }

		#downloadsPrefs {
			font-size: 0.8rem;
			background-color: #fcfcfc;
			border: 1px dotted gray;
			margin-bottom: 1rem;
		}
		#downloadsPrefs p {
			margin: 2rem 10%;
		}/*
		#downloadsPrefs ~ * {
			display: none;
		}*/
	</style>
	<div id="downloadsPrefs">
		<p style="font-size: 1.5rem">Note from the author...</p>
		<p>My posts frequently (like this one) have a 'theme' and tend to use a number of images for visual flourish. Personally, I like it that way, I find it more engaging and I prefer for people to read it that way.  However, for users on a metered or slow connection, downloading unnecessary images is, well, unnecessary, potentially costly and kind of rude.  Just to be polite to my users, I offer the ability for you to opt out of 'optional' images if the total size of viewing the page would exceed a budget I have currently defined as 200k...
		</p>
		<p><label>Show me all the images when I read <input type="checkbox" id="download-all-images-pref" checked=""></label></p>
		<p><label>Don't ask me again on this device <input type="checkbox" id="download-all-images-pref-save"></label></p>
		<p><button id="setDownloadPrefs">Dismiss</button></p>
	</div>
	<script>
		'use strict';
		(function () {
			var prefsButton = document.querySelector('#setDownloadPrefs'),
				prefs = window.localStorage.downloadsPrefs;
			function downloadImages () {
				var lazy = Array.prototype.slice.call(document.querySelectorAll('.captioned-image>[data-src]'));

				lazy.forEach(activateOptional)
			}
			function removeDownloadPrefsOverlay() {
				document.body.classList.add('preferences-set')
				document.querySelector('#downloadsPrefs').remove()
			}

			prefsButton.addEventListener('click', function() {
				var all = document.querySelector('#download-all-images-pref'),
					save = document.querySelector('#download-all-images-pref-save'),
					prefs = window.localStorage.downloadsPrefs

				if (all.checked) {
					downloadImages();
				}
				if (save.checked) {
					window.localStorage.downloadsPrefs = all.checked;
				}
				removeDownloadPrefsOverlay()
			});

			if (typeof prefs !== 'undefined') {
				console.log(prefs)
				if (prefs === 'true') {
					document.body.classList.add('prefers-images')
					window.localStorage.downloadsPrefs = prefs
					window.addEventListener('DOMContentLoaded', downloadImages)
				}
				removeDownloadPrefsOverlay()
			}
		}())
	</script>
    <style>
        .tldr em {
            display: none; color: rebeccapurple;
        }

        .sidenote {
            background-color: rgba(153,145,209,0.42);
            padding: 1rem;
            font-style: italic;
        }

        .sidenote::before {
            content: 'Side Note';
            font-size: 0.8rem;
            background-color: black;
            color: white;
            padding: 0.25rem;
            margin-right: 0.5rem;
        }

    </style>
    <script src="../prism.js"></script>
    <link rel="stylesheet" href="../prism.css">
    <h1 class="contextual-heading"><code tag-esc="">i is="the walrus"</code></h1>
    <p class="segue">
        It's become a fairly regular occurence for me to encounter someone on social media expressing some kind of frustration with Custom Elements.  As both an avid user of them myself and someone involved in many discussions during their creation and evolution, I really want them to be better too.  As I speak to the folks who are frustrated, however, I find that there is so much there that it's difficult to discuss.  So, I thought perhaps it would be worth sitting down and writing about it.  That, and walruses.
    </p>


    <section class="sectioning">
        <h2 class="contextual-heading">The time has come...</h2>
        <div class="captioned-image optional p-attached p-attached-right">
            <img data-src="http://www.jabberwocky.com/carroll/pics/glass21.gif" alt="">
                "The time has come," the Walrus said,<br>
                "To talk of many things:<br>
                Of shoes--and ships--and sealing-wax--<br>
                Of cabbages--and kings--<br>
                And why the sea is boiling hot--<br>
                And whether pigs have wings."
        </div>

        <p style="clear: none">
            Over the last few years, I've watched several observations and criticisms sprout up about Custom Elements.  It began (I think) with someone pointing out that there's an ability that is spec'ed today: The ability to extend native elements with the <code>is="…"</code> attribute.  Extension, as the argument goes, is desparately needed for accessibility sake.  Yet, for some reason, it remains unimplemented.  This has generated a lot of discussion, frequently about who was to blame for holding the Web back and making custom elements less valuable.  Given this core premise, further arguments have been made as to how this would be good for so many additional reasons: Given X, then Y. Given Y, then Z.  In concert, all of these simple observations and arguments really do appear to lead inexorably toward a very simple and well-justified "overall solution" that would be really grand...If browsers would just get their shit together and implment the thing in the spec.  It's pretty frustrating to a lot of people.  I can appreciate that.
        </p>

        <p style="clear: none">
            I'd like to take some time and unpack a lot of this though...
        </p>


        <section class="sectioning">
            <h3 class="contextual-heading">Accessibility Magic</h3>
            <div class="captioned-image optional p-attached p-attached-left">
                <img data-src="/media/walricorn.jpg" alt="walricorn t-shirt">
                <p>You can, and probably should, buy this amazing walricorn t-shirt on Amazon.</p>
            </div>

            <p>
                Let's start here: The popular understanding that if we were to extend a built-in element it would be "automatically accessible" by the simple virtue of inheritance.  I think it's important to explan that this is very nearly entirely untrue.  Sadly, the magical walricorn won't actually magically bring all of the good little elements who used <code>is="…"</code> free accessibility on International Walrus Day (November 24th).
            </p>

            <p style="clear: none;">
                Here's why: <em>Currently, all that accessibility goodness that we desire is inextricably wound up in the native DOM</em>. Sadly, the vast majority of use cases for "improving" a native element is actually about improving the DOM itself, and this creates a substantial mismatch.  In reality (not an opinion), as soon as we create a new shadow root or hide the existing element or do just about anything really useful to the user experience, all of that accessibility goodness largely just vanishes.
            </p>

            <p style="clear: none">
                Note: I say <em>almost</em> entirely untrue because there, in fact, are some small set of problems that involve no new DOM at all.  However, in terms of accessibility, many of these  also have similarly trivial solutions already available today and/or there are other proposals under discussion that promise to help solve these problems better.
            </p>

            <p style="clear: none">
                So, any concept that <code>is="…"</code> will make all components more accessible is, sadly, just misleading. There's no magical affordance in extension that allows it to map "whatever random shit I just made up" to "the thing with all of the good accessibility characteristics".  You've still got to do a lot of work.
            </p>

            <p>
                What's more, this isn't really a controverial statement in standards land.  Hats off to Google for actually trying really hard to solve a lot of problems. For a brief instant, some people were very hopeful in the idea of <code>is="…"</code>.  Others saw too many problems and too little benefit.  That moment seems to have passed though and, realistically, no one seems to actively believe that  <code>is="…"</code> holds a lot of answers.  Since that time, counter-proposals have been fermentingand, currently, appear to have wider conceptual support (I'll mention some of that later).
            </p>

        </section>

        <section class="sectioning">
            <h3 class="contextual-heading">Progressive Enhancement</h3>
            <div class="captioned-image optional p-attached p-attached-right">
                <img data-src="https://www.exploringnature.org/graphics/mammals/walrus_diagram.jpg" alt="an illustrated diagram of some walrus features">
                Walrus extends Animal.
            </div>
            <p>
            While accessibility is commonly cited, I think that really it is the Progressive Enhancement (PE) that appears to be afforded by <code>is="…"</code> that is probably the real lynchpin feature that really makes so many people latch on to this idea.  I can entirely appreciate this: It sounds so good.  Unfortunately, I think this is misleading as well.</p>

            <p style="clear: none">Here's something subtle to think about:  Is <code>is="…"</code> really PE in the traditional sense?  Well, no.  It can't be since the ability to extend has never existed before. PE has traditionally never been an <em>is-a</em> relationship.</p>

            <p style="clear: none; margin-top: inherit;">Consider a common example used to explain PE: Our designs include a button that say "click to print" which should call <code>window.print()</code> when clicked.  PE says start basic with something that works for everyone.  In this case, it might be a paragraph saying "Print this page for your records".  Every browser is capable of doing that. Users can then often figure out how to print in their particular environment.  Then, if a user's browsers meets the requesite criteria (it knows what a button is, it supports JavaScript and <code>window.print()</code> is defined), then it <em>enhances</em>.  Seems good.</p>

            <p>
                But now consider the details: It might become a paragraph <em>containing</em> a functional button, or it might actually <em>become instead</em> a functional print button. Is that the same thing?
            </p>

            <div style="margin-top: 0" class="captioned-image optional p-attached p-attached-left">
                <img style="width: 300px" data-src="https://vignette.wikia.nocookie.net/marveldatabase/images/d/db/Hubert_Carpenter_%28Earth-616%29.png/revision/latest?cb=20110609023559" alt="A photo of Marvel's Walrus Man villian">
                <code tag-esc="">man is="walrus"</code>
            </div>
            <p>
                Neither <em>turning one thing into something else</em>, nor <em>changing the composition of a thing</em> are really the same thing as <em>extension</em>. Traditionally, the "ness" of that element instance never changed.  In no case was the same thing both paragraph <em>and</em> button at the same time.  That's why you can't write <code tag-esc="">p is="button"</code> for example - it's nonsense.  However, the mere fact that this attribute would <em>allow</em> an author to express such a desire (meaning, someone can and will type that) means introducing a whole lot of new plumbing and complexity for new cases that have to be accounted for.
            </p>

            <p style="clear: none">
                However we spell it out, a paragraph and a button are two things that are just entirely different things in terms of heirarchy and that's the important thing, here's why...</p>
        </section>

        <section style="clear: both" class="sectioning">
            <h3 class="contextual-heading">Metaphorical Walruses</h3>
            <p>
                While you may think that the above "paragraph that is a button" example above seems "really different from what you're asking for" and is merely my contrived example aimed to convince you of something irrelevant, it isn't.  I would suggest that <em>currently</em> this is actually <em>precisely</em> what we are frequently asking for without even realizing it.  Why?  Well, again, that's because what we want actually usually involves new DOM.  It's not, <em>in terms available to us today</em>, actually just a specialized version of something. Really often, what we're describing is a different, and more complex kind of relationship.  <em>is-a</em> is very specifically about <em>extension</em>, and extension is about describing a taxonomy, like, in the Linnean sense.
            </p>

            <p>
                Understanding the basic ideas of Linnean Taxonomy is <em>obviously</em> very important to understand if you want to get a job as say, a marine biologist or a paelentologist. But what most people don't realize is that unlike some of the other frivolus things they made you learn in school, like, for example, algebra - understanding <em>this</em> can also come in extremely handy in everyday adult life.  For example, if you needed to help my friend Sarah Drasner win a bar bet about whether people know what it is...
            </p>

            <center style="margin: 2rem 0"><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Alright, please help us nerds settle a drinking bet. Do you know what the Linnaean System of Classification is? (No googling)</p>— Sarah Drasner (@sarah_edo) <a href="https://twitter.com/sarah_edo/status/911462225491116032?ref_src=twsrc%5Etfw">September 23, 2017</a></blockquote>
        <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></center>

            <p>
                Or, maybe more practically, if you are doing software modeling, as we are here.  So, let's talk about that for a minute.
            </p>


            <p class="sidenote">
                A really significant amount of western thought has centered around trying to divide up the world like this into kind of fragile and abritrary taxonomies. Author David Weinberger has written a lot about this tendency/history, his <a href="https://www.youtube.com/watch?v=43DZEy_J694">Everything is Miscellaneous</a> is a really enjoyable and non-technical talk that is worth watching some time.
            </p>

            <div style="margin-top: 0rem" class="captioned-image optional p-attached p-attached-left">
                <img data-src="https://cdn.vox-cdn.com/thumbor/E9-lw3BD0Ama-3cUSOXA_J5l_d0=/0x0:404x303/1400x1050/cdn.vox-cdn.com/uploads/chorus_image/image/51386351/d200908311113466240.0.jpg" alt="Photo of Barbara Liskov">
            </div>

            <p>
                In 1987 Barbara Liskov presented a keynote address called "Data abstraction and hierarchy" which talks about how we model things and our desire to organize things into heirarchies that <em>extend</em> and <em>inherit</em>. Liskov goes on to illustrate how that tends to cause numerous sorts of problems.  More importantly, she begins to explain how we might avoid those problems and the basic concept she describes is sometimes known as the "Liskov substitution principle" or "LSP" or even just "substitutionality".  In 2008 she won the Turing Award for her work.
            </p>

            <p>
                In a way, what she's saying is: Metaphor makes for shitty modeling.  Our <em>minds</em> are actually perfectly fine handling all sorts of wild linkages, comparisons and semantics that are more metaphorical than literal - in fact, they're kind of built to find patterns and relationships even when they don't exit.
            </p>

            <div style="margin-top: 0rem" class="captioned-image optional">
                <img data-src="/media/walrus_cloud.jpg" alt="Clouds that kinda sorta look like a walrus">
                Photo credit to <a href="https://www.flickr.com/photos/lostmycat/" target="_blank">Janie</a>.
            </div>

            <p>
                Programming languages, on the other hand, tend to take things pretty literally.  Because of this, our minds can trip us up and make us model something poorly.  Extension is good and useful, don't misunderstand what I am saying.  But if we use it poorly then rather than being a really helpful abstraction, we'll find that the system will begin to fight us instead.
            </p><p>

            </p><p>
                Once again, that's just what happens here: <em>Currently</em> all that "good stuff" that we want is bound up pretty tightly in DOM and therefore a lot of times when we're thinking "is-a" it's unfortunately more metaphaorical than literal.  <em>In terms currently available to us today</em>, it just isn't - and so we wind up modeling poorly.
            </p>

            <p>
                Being able to extend input "like HTML did" is one of the most cited use case examples that I hear for extension.  However, even in the platform itself, where extension was technically possible, there is no extension at play here today. There is only input.  It's worth noting that most of how <code tag-esc="">input</code> was done is largely seen as <em>considerably problematic</em> by implementers today.  Why?  Well, the easiest way to begin to understand, I think, is by listening to <a href="https://vimeo.com/176453149" target="_blank">this talk by Monica Dinculescu</a>.  In short though, it's really created by the model mismatch we've been discussing here.  Instead of being really helpful, the model begins to fight us.  We begin to see the cracks in our modeling of metaphor and that actually, it <em>isn't-really-that</em>.
            </p>

            <p>
                This mismatch is increasingly widely recogonized as a real problem that needs solving.  In the <a href="https://extensiblewebmanifesto.org">Extensible Web</a> sense, there's a lot more magic currently woven into today's DOM that needs explaining.  In order for us to actually accomplish many of the sorts of things people are actually trying to describe, we need to decouple the powers and be able to explain the existing platform, and new things, in those terms.  There are a number of discussions underway that are aimed at helping us do precisely that, and none of them are simply inheritance or <code>is="…"</code> as currently specified.  I'll write about those in another piece, but this leaves us with a very real problem:  Until then, where does that leave us?
            </p>

            <p>
                Well, interestingly, in the meantime, 'is-a' isn't the only kind of relationship we have identified for modeling problems.  The often cited Gang of Four <em>Design Patterns</em> provides the simple observation "composition over inheritance" based on Liskov's work.  That is: Composing features through a <em>has-a</em> relationship is often a better way to go in the long run anyway.
            </p>

            <section class="sectioning">
                <h4 class="contextual-heading">We <em>has-a</em> way...</h4>
                <p>
                    The really interesting part is that absolutely nothing new is required in order for us to both follow the self-same progressive enhancement patterns that we've been using all along and gain pretty much all ofthe same values we would with <code>is="…"</code> without adding any new complexity to the platform itself... How?  Through composition rather than inheritance. In concrete terms:
                </p>

                <pre><code class="language-html">&lt;!-- instead of writing this --&gt;
&lt;input type="radio" is="x-radio"&gt;

&lt;!-- you write this --&gt;
&lt;x-radio&gt;
    &lt;input type="radio"&gt;
&lt;/x-radio&gt;</code></pre>

                <div class="captioned-image optional p-attached p-attached-left">
                <img data-src="/media/sax-walrus.jpg" alt="a cool looking walrus playing the saxophone">
                Hat tip to my pal Bruce Lawson for this, you can also <a href="https://youtu.be/0tmHaR0rCJ4" target="_blank">watch the video of this actual event involving a groovy walrus playing a saxophone</a>
                </div>

                <p>
                    Yes, it's not perfect.  Yes, it's not exact pairty.  There are some cases where you have to progressively enhance a parent element in order to affect a child, for example.  However, if you take some time and consider this carefully, you'll find that in fact, their effects are functionally equivalent in just about every useful way: Form serialization, validation, etc.  Both are declarative and have about the same fault tolerance built into their pattern.  And, importantly: As a creator of a component using this pattern, you'll have to change and proxy precisely as much <em>in either model for the sake of accessibility, depending on just what DOM what you change</em>.  Because of this "very close resemblance" if you find any of these aspects very frustrating, it's worth noting that <code tag-esc="">is="…"</code> (as specified today) would likely create <em>many</em> of the same frustrations.  I realize that this can seem a little unintuitive, so I'll likely talk about the sorts of objections I've heard to these observations in another post.
                </p>

                <p>
                    So, to sum up: We <em>has-a</em> way forward for now through composition.  It's not a bad way at all.  It's actually quite powerful and good.  It isn't perfect.  It isn't complete.  But we <em>can</em> do a lot of useful things and that's a Really Good Thing™.  The fact that we've largely stopped chasing <em>is="…"</em> isn't due to simple stone-walling by any vendor and it isn't a net loss.  Ideas need to be able to spread and percolate with lots of minds.  The original ideas also need to be able to fail if they aren't fit so that ideas can mix and mutate and ultimately better ones can arise.  That's just what I see happening here.  In near future pieces I'll write about what sorts of ideas <em>are</em> actively being chased down to help us better solve these problems instead.
                </p>

            </section>
    </section>

    <div class="captioned-image optional"><img data-src="/media/john-beatle.jpg" alt="photo of John Lennon">
    goo goo g'joob...</div>

    <p class="thanksTo">
        Special thanks to my friends, Alex Russell and Peter Rushforth for proofing/commenting on early drafts of this piece and helping them be shorter and less confusing.
    </p>
</section></article></main>
 
   
  <script>
    //import { MediaAffordancesElement } from "./MediaAffordancesElement.js";
    class MediaAffordancesElement extends HTMLElement {
      constructor() {
        super();
        // todo: this should be a private field
        this.__matching = new Set()
        this.mqls = [];
        this.observers = [];

        this.supportedAffordances = new Set();
      }

      observeAffordanceChange(cb) {
        this.observers.push(cb);
      }

      notifyChange() {
        let intersection = new Set();
        for (let elem of this.__matching) {
          if (this.supportedAffordances.has(elem)) {
            intersection.add(elem);
          }
        }

        if (this.__matching.size > 0) {
          this.setAttribute("mq-matched", [...this.__matching].join(" "));
        } else {
          this.removeAttribute("mq-matched");
        }
        let arr =  [...intersection]
        let affordance = arr[arr.length - 1];
        if (affordance) {
          this.setAttribute("affordance", affordance);
        } else {
          this.removeAttribute("affordance");
        }
        this.observers.forEach(cb => {
          cb(intersection, this.__matching);
        });
      }

      static get observedAttributes() {
        return ["mq-affordances"];
      }

      connectedCallback() {
        let newValue = getComputedStyle(this).getPropertyValue(
          "--const-mq-affordances"
        );
        this.connectListeners(newValue);
      }

      connectListeners(newValue = "") {
        if (newValue.trim().length === 0) {
          return;
        }
        
        newValue.split("|").forEach(segment => {
          let mq = segment.trim().match(/\[([^\]]*)/)[1];
          let names = segment
            .replace(`[${mq}]`, "")
            .trim()
            .split(" ");
          let mql = window.matchMedia(mq);
          let mqh = evt => {
            names.forEach(name => {
              this.__matching[mql.matches ? "add" : "delete"](name);
            });

            this.notifyChange();
          };
          mqh();
          mql.addEventListener("change", mqh);
          this.mqls.push(mql);
        }, this);
      }

      attributeChangedCallback(name, oldValue, newValue) {
        this.connectListeners(newValue);
      }
    }

    //-----------------------------------------------------

    (function() {
      let lastUId = 0;
      let nextUId = () => {
        return `cp${++lastUId}`;
      };

      let getLabels = regionset => {
        return [...regionset.children].filter(el => /^H\d$/.test(el.tagName));
      };

      let getContentEls = regionset => {
        return [...regionset.children].filter(el => !/^H\d$/.test(el.tagName));
      };

      let ensureId = el => {
        el.id = el.id || nextUId();
        return el.id;
      };

      let getDisclosureButton = label => {
        return label.shadowRoot.querySelector("button");
      };

     
      let style = document.createElement('style')
      style.innerHTML = `
          
        :where(spicy-sections > [affordance*="collapse"])::before { 
          content: ' ';
          display: inline-block;
          width: 0.5em;
          height: 0.75em;
          margin: 0 0.4em 0 0;
          transform: rotate(90deg);
          background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='10px' height='10px' viewBox='0 0 270 240' enable-background='new 0 0 270 240' xml:space='preserve'%3e%3cpolygon fill='black' points='5,235 135,10 265,235 '/%3e%3c/svg%3e ");
          background-size: 100% 100%;
        } 

        :where(spicy-sections > [affordance*="collapse"][aria-expanded="true"])::before, 
        :where(spicy-sections > [affordance*="collapse"][aria-expanded="true"])::after {
          transform: rotate(180deg);
        }
      `
      document.head.prepend(style)
      
      const template = `
            <style>
              :root {
                font-size: 1rem;
              }

              :host([hidden]),
              ::slotted([hidden]) {
                display: none;
              }
              
              ::slotted(h1),
              ::slotted(h2),
              ::slotted(h3),
              ::slotted(h4),
              ::slotted(h5),
              ::slotted(h6) {
                 margin-right: 1rem;
              }
              
              tab-bar ::slotted([tabindex="0"]) {
                border-bottom: 1px solid blue;
              }
              
              tab-list { 
                display: flex; 
                overflow: hidden;
                white-space: nowrap;
              }
            </style>
            <tab-bar part="tab-bar">
              <!-- The region/tablist should have a  label -->
              <tab-list part="tab-list" role="tablist"
              ><slot name="tabListSlot"></slot></tab-list>
            </tab-bar>
            <content part="content-panels">
              <slot default></slot>
            </content>
        `;

      class RegionSet extends MediaAffordancesElement {
        __defaults;
        __tabListEl;

        // tabs and exclusive collapses should have the same affordance object?
        __affordanceConf = {
          collapse: {
            // can take a condition to force, check-like
            toggle: (label, condition) => {
              let state =
                typeof condition === "boolean"
                  ? condition
                  : !label.affordanceState.expanded;
              let contentEl = label.nextElementSibling;
              label.affordanceState.expanded = state;
              label.affordanceState.nonExclusiveExpanded = state;
              label.setAttribute("aria-expanded", state);
              if (state) {
                label.setAttribute("expanded", "");
                contentEl.style.display = "block";
              } else {
                label.removeAttribute("expanded");
                contentEl.style.display = "none";
              }
            }
          },
          "exclusive-collapse": {
            // ignores condition, radio-like
            toggle: label => {
              let labels = getLabels(label.parentElement);
              let siblings = labels.filter(c => c !== label);
              let index = labels.findIndex(c => c === label);

              siblings.forEach((sibLabel, i) => {
                let relatedContent = sibLabel.nextElementSibling;
                sibLabel.tabIndex = -1;
                relatedContent.style.display = "none";
                label.setAttribute("aria-expanded", "false");
                sibLabel.affordanceState.exclusiveExpanded = false;
              });
              label.tabIndex = 0;
              //nope - todo, fix/remove this?
              label.parentElement.affordanceState.exclusiveSelection.index = index;
              label.nextElementSibling.style.display = "block";
              label.setAttribute("aria-expanded", "true");
              label.affordanceState.exclusiveExpanded = true;
              label.focus();
            }
          },
          "tab-bar": {
            // ignores condition, radio-like
            toggle: label => {
              let labels = getLabels(label.parentElement);
              let siblings = labels.filter(c => c !== label);
              let index = labels.findIndex(c => c === label);

              siblings.forEach((sibLabel, i) => {
                let relatedContent = sibLabel.nextElementSibling;
                sibLabel.tabIndex = -1;
                relatedContent.style.display = "none";
                sibLabel.setAttribute("aria-expanded", "false");
                sibLabel.affordanceState.exclusiveExpanded = false;
              });
              label.tabIndex = 0;
              label.parentElement.affordanceState.exclusiveSelection.index = index;
              label.nextElementSibling.style.display = "block";
              label.setAttribute("aria-expanded", "true");
              label.affordanceState.exclusiveExpanded = true;
              label.focus();
            }
          }
        };
        __setSize = (labelEls, contentEls) => {
          this.__size = Math.min(labelEls.length, contentEls.length);

          if (labelEls.length !== this.__size) {
            console.warn("mismatch in tab-set label/content pairs...");
          }

          labelEls.forEach((labelEl, i) => {
            let contentEl = contentEls[i];
            if (!labelEl.initialized) {
              labelEl.initialized = true; // todo: this used to be shadow, do i need it?
              let defs = this.__defaults.defaultActive;

              // this assumes it is about collapses
              labelEl.affordanceState = {
                expanded: defs.includes(labelEl),
                active: false,
                // activate in the current mode
                activate: () => {
                  if (this.affordanceState.current) {
                    this.__affordanceConf[this.affordanceState.current].toggle(
                      labelEl
                    );
                  }
                }
              };

              let defaultExclusive =
                defs.length === 0 ? labelEls[0] : defs[defs.length - 1];

              this.affordanceState.exclusiveSelection.index = labelEls.indexOf(
                defaultExclusive
              );
            }
            labelEl.setMode = mode => {
              if (mode === "non-exclusive") {
                let isExpanded = labelEl.affordanceState.expanded;
                labelEl.setAttribute("affordance", "collapse");
                labelEl.setAttribute("tabindex", "0");
                labelEl.setAttribute("aria-controls", contentEl.id);
                labelEl.setAttribute("role", "button");
                labelEl.setAttribute("aria-expanded", isExpanded);
                labelEl.nextElementSibling.style.display = isExpanded
                  ? "block"
                  : "none";
              } else if (mode === "exclusive") {
                let isExpanded =
                  labelEls.indexOf(labelEl) ===
                  this.affordanceState.exclusiveSelection.index;
                labelEl.setAttribute("affordance", "collapse");
                labelEl.setAttribute("tabindex", isExpanded ? 0 : -1);
                labelEl.setAttribute("role", "button");
                labelEl.setAttribute("aria-expanded", isExpanded);
                labelEl.setAttribute("aria-controls", contentEl.id);
                labelEl.nextElementSibling.style.display = isExpanded
                  ? "block"
                  : "none";
              } else {
                labelEl.removeAttribute("tabIndex");
                labelEl.removeAttribute("affordance");
                labelEl.removeAttribute("aria-expanded");
                labelEl.removeAttribute("role");
              }
            };
          });
        };

        __projectTabBar = () => {
          this.__removeProjections();
          getLabels(this).forEach((tabSource, i) => {
            let selected = false,
              tabIndex = -1,
              display = "none";

            tabSource.setMode();
            tabSource.slot = "tabListSlot";
            tabSource.setAttribute("role", "tab");
            let tabId = ensureId(tabSource);
            let contentSource = tabSource.nextElementSibling;
            contentSource.tabIndex = 0;
            tabSource.setAttribute("aria-controls", ensureId(contentSource));
            contentSource.setAttribute("role", "tabpanel");
            contentSource.setAttribute("aria-labelledby", tabSource.id);
            if (i === this.affordanceState.exclusiveSelection.index) {
              tabIndex = 0;
              selected = true;
              display = "block";
            }
            tabSource.setAttribute("aria-selected", selected);
            tabSource.tabIndex = tabIndex;
            contentSource.style.display = display;

            // TODO: aria-orientation :(
          });
        };

        __projectCollapses = exclusive => {
          // TODO - remove projections and... ??
          this.__removeProjections();
          getLabels(this).forEach(label => {
            label.setMode(exclusive ? "exclusive" : "non-exclusive");
          });
        };

        __removeProjections = () => {
          [...this.children].forEach(child => {
            child.removeAttribute("slot");
            child.removeAttribute("affordance")
            child.removeAttribute("role");
            child.removeAttribute("aria-selected");
            child.removeAttribute("aria-controls");
            child.removeAttribute("tabindex");
            child.removeAttribute("aria-expanded")
            child.style.display = "block";
          });
        };

        // matching pairs
        __size = 0;

        __configure = () => {
          ///hmmm

          this.__setSize(getLabels(this), getContentEls(this));

          if (this.affordanceState.current === "tab-bar") {
            this.affordanceState.currentMode = "exclusive";
            this.__projectTabBar();
          } else if (this.affordanceState.current === "collapse") {
            this.affordanceState.currentMode = "non-exclusive";
            this.__projectCollapses();
          } else if (this.affordanceState.current === "exclusive-collapse") {
            this.affordanceState.currentMode = "exclusive";
            this.__projectCollapses(true);
          } else {
            this.affordanceState.currentMode = undefined;
            this.__removeProjections();
          }

          let specifiedIndex = this.activeTabIndex || 0;
          // TODO: hmm, these are DOM changes, we could cache them
          let labelEls = getLabels(this);
          let contentEls = getContentEls(this);

          for (let i = 0; i < this.__size; i++) {
            let label = labelEls[i];
            // probably add one handler that decides
            if (!label._inited) {
              label.addEventListener("click", evt => {
                evt.target.affordanceState.activate();
              });
              label._inited = true;
            }
          }
        };
        
        __childListObserver = new MutationObserver(mutationList => {
          // we have to wire up new elements
          let labelEls = getLabels(this);
          let contentEls = getContentEls(this);

          // what if there is a mismatch?
          this.__setSize(labelEls, contentEls);
          this.__configure();
        });

        __tabset;

        affordanceState = {
          exclusiveSelection: { index: undefined },
          current: undefined,
          currentMode: undefined,
          getLabels: () => {
            return getLabels(this);
          }
        };

        /*
          Wires up suppored affordances...
        */
        constructor() {
          super();
          this.supportedAffordances.add("tab-bar");
          this.supportedAffordances.add("collapse");
          this.supportedAffordances.add("exclusive-collapse");

          this.observeAffordanceChange((matching, all) => {
            if (!this.__defaults) {
              this.__defaults = {
                onMatch: this.hasAttribute("defaults-on-match"),
                defaultActive: getLabels(this).filter(l =>
                  l.hasAttribute("default-activate")
                )
              };
            }
            this.affordanceState.current = this.getAttribute("affordance");
            this.__configure();
          });

          this.attachShadow({ mode: "open" });
          this.shadowRoot.innerHTML = template;
     
          this.__tabListEl = this.shadowRoot.querySelector("tab-list");
          this.addEventListener(
            "keydown",
            evt => {
              let labels = getLabels(this);
              let size = labels.length;
              let cur = this.affordanceState.exclusiveSelection.index;
              let prev = cur === 0 ? size - 1 : cur - 1;
              let next = cur === size - 1 ? 0 : cur + 1;

              if (
                this.affordanceState.current === "tab-bar" ||
                this.affordanceState.current === "exclusive-collapse"
              ) { 
                if (evt.keyCode == 37 || evt.keyCode == 38) {
                  labels[prev].affordanceState.activate();
                } else if (evt.keyCode == 39 || evt.keyCode == 40) {
                  labels[next].affordanceState.activate();
                }
              } else if (evt.keyCode == 32 && this.affordanceState.current === 'collapse') {
                evt.preventDefault()
              }
            },
            false
          );
          this.addEventListener(
            "keyup", 
            evt => {
              if (evt.keyCode == 32 && this.affordanceState.current === 'collapse') {
                evt.target.closest('[affordance]').affordanceState.activate()
                evt.preventDefault()
              }
            })
        }

        connectedCallback() {
          super.connectedCallback();

          //TODO: check whether there is a hash/handle selection
          
          // If you append a fragment with a pair, it should work
          this.__childListObserver.observe(this, { childList: true });
        }
      }
      customElements.define("spicy-sections", RegionSet);
    })();
    </script>
  <script>
    Array.prototype.slice.call(document.querySelectorAll('.optional [data-src]')).forEach(function (optional) {
      var prefs = window.localStorage.downloadsPrefs,
          clickToSee;
      if (prefs === 'true') {
        activateOptional(optional);
      } else {
        clickToSee = document.createElement('div');
        clickToSee.classList.add('clickToSee')
        clickToSee.innerHTML = '<button>Click to see media</button>';
        clickToSee.style.textAlign = 'center';
        clickToSee.style.border = 'none';
        optional.parentElement.insertBefore(clickToSee, optional.nextSibling);
        clickToSee.firstElementChild.addEventListener('click', function () {
          activateOptional(optional);
        })
      }

    })
  </script>

</body></html>