
<!DOCTYPE html><html class=''>
<head>
	<script>const CA = .25 /* cutoff angle */,
			HF = ['cos', 'sin'] /* harmonic functions */,
			NS_URI = 'http://www.w3.org/2000/svg',
			SEL = '[points][r]:not(path)',
			/* polygonal chains whose corners we round */
			_P = Array(...document.querySelectorAll(SEL));

let np = _P.length;

function rand(max = 1, min = 0, is_int) {
	let gen = min + (max - min)*Math.random();
	return is_int ? Math.round(gen) : gen;
}

function isImportant(node) {
	return node.nodeType === document.ELEMENT_NODE && node.matches(SEL)
};

function fillet(_poly, _path) {
	const /* threshold error = cosine of cutoff angle */
				TE = Math.cos((_poly.hasAttribute('daca-ca') ?
					 _poly.getAttribute('daca-ca') : CA)*Math.PI/180),
				/* read the rounding radius */
				R = +_poly.getAttribute('r');

	let v, n, τ, ne, d, l, α = [], f, ρ, γ, δ,
			s, e, na, pd, _up, _1st = !_path,
			k, m, ra, s0, s1;

	/*
	 * check that rounding radius r is
	 * a finite, positive number
	 */
	if(!isFinite(R) || R <= 0) return;

	/*
	 * extract coordinates from points
	 * attribute, no matter its format
	 */
	v = _poly.getAttribute('points')
		.replace(/(\d)\-/g, `$1 -`)
		.split(/\s*,\s*|\s+/g)
		.map(c => +c);

	/*
	 * check we have enough coords for
	 * a triangle at least
	 */
	n = v.length;
	if(.5*n < 3) return;
	n -= n%2;

	/*
	 * check that all useful coordinates
	 * are finite numbers
	 */
	for(let i = 0; i < n; i++)
		if(!isFinite(v[i])) return;

	/*
	 * compact 1D array into 2D array
	 * for example, [5, 6, 1, 7, 3, 2, 8]
	 * becomes [[5, 6], [1, 7], [3, 2]]
	 */
	v = v.reduce((a, c, i) => i%2 ?
				a.concat([[v[i - 1], c]]) : a, []);

	n = v.length;

	/*
	 * the shape type:
	 * 0 for polygon, 1 for polyline
	 */
	τ = +(_poly.localName !== 'polygon');

	/* the number of edges */
	ne = n - τ;

	/*
	 * compute coordinate differences between
	 * edge endpoints
	 */
	d = v.slice(0, ne).map((c, i) => {
		let nxt = v[(i + 1)%n]; /* next vertex coords */

		return [
			nxt[0] - c[0] /* x difference dx */,
			nxt[1] - c[1] /* y difference dy */
		];
	});

	/* compute edge lengths */
	l = d.map(c => Math.hypot(...c));

	/*
	 * get polygonal chain angles,
	 * perform collinearity checks and, if needed,
	 * remove vertices and
	 * replace coordinate differences and edge lengths
	 */
	for(let i = τ; i < ne; i++) {
		let j = (i - 1 + n)%n /* first edge index */,
				k = (i + 1)%n /* second edge index */,
				/* third edge endpoint coord differences */
				dx = v[j][0] - v[k][0],
				dy = v[j][1] - v[k][1],
				c = Math.hypot(dx, dy) /* third edge */,
				/* cosine of current angle from law of cosines */
				h = (l[i]*l[i] + l[j]*l[j] - c*c)/(2*l[i]*l[j]);

		/* if current cosine greater than cutoff value */
		if(Math.abs(h) > TE) {
			/* remove middle vertex */
			v.splice(i, 1);
			/* update number of vertices
			 * and check we still have at least 3 */
			if(--n < 3) return;

			/* remove coord diffs related to removed vertex,
			 * introduce those between adjacent vertices */
			d.splice(j, 2, [dx, dy]);
			/* remove edges connected to removed vertex
			 * introduce shortcircuiting segment */
			l.splice(j, 2, c);
			ne--; /* update number of edges */

			/* if we have a polygon & removed vertex is last */
			if(!τ && i === ne) {
				dx = v[i - 1][0] - v[k][0];
				dy = v[i - 1][1] - v[k][1];
				c = Math.hypot(dx, dy);
				h = (l[i-1]*l[i-1] + l[0]*l[0] - c*c)/(2*l[i-1]*l[0]);
				α[0] = Math.acos(h);
			}

			/* decrement index */
			i = Math.max(i - 2, τ - 1);
			/* to fix previous angle */
			α.pop();
		}
		else α.push(Math.acos(h));
	}

	na = n - 2*τ;

	/* get the angle k constants */
	k = α.map(c => 1/Math.tan(.5*c));

	/* get the limit radii for each edge */
	m = l.map((c, i) => c/((i >= τ)*k[(i - τ + na)%na] + (ne - 1 - i >= τ)*k[(i - τ + 1)%na]));

	/* get the actual radii used for each arc */
	ra = m.slice(0, na).map((c, i) => Math.min(R, m[(i + τ - 1 + ne)%ne], m[i + τ]));

	/* get the sweep flags */
	f = d.slice(τ).map((c, i) => {
		/* coord diffs corresp to previous edge */
		let prv = d[(i + ne - 1 + τ)%ne];

		return .5*(Math.sign(prv[0]*c[1] - c[0]*prv[1]) + 1);
	});

	/*
	 * get segments coonecting replaced vertices
	 * to start/ end points of arcs replacing them
	 */
	ρ = α.map((c, i) => ra[i]/Math.tan(.5*c));

	/*
	 * get edge angles with respect to the horizontal
	 */
	γ = d.map(c => Math.atan2(...c.reverse()));
	δ = d.map(c => Math.atan2(...c.map(c => -c)));

	/*
	 * get coordinates of arc start points
	 */
	s = ρ.map((c, i) =>
			  v[i + τ].map((k, j) =>
			  			   k + c*Math[HF[j]](δ[(i - 1 + τ + ne)%ne])));

	/*
	 * get coordinates of arc end points
	 */
	e = ρ.map((c, i) =>
			  v[i + τ].map((k, j) =>
			  			   k + c*Math[HF[j]](γ[(i + τ + ne)%ne])));

	/*
	 * generate path data
	 */
	pd = 'M' + (τ ? v[0] + 'L' : '');

	for(let i = 0; i < na; i++)
		pd += (i ? 'L' : '') + s[i] + 'A' + [ra[i], ra[i], 0, 0, f[i], ...e[i]];

	pd += τ ? 'L' + v[n - 1] : 'z';

	s0 = getComputedStyle(_poly);

	/*
	 * if we don't already have a path
	 * create equiv path element, set its path data
	 * and add it to document
	 */
	if(_1st) {
		_path = document.createElementNS(NS_URI, 'path');
		_up = _poly.parentNode;

		/* add equivalent path after original polygonal chain */
		if(_poly.nextElementSibling)
			_up.insertBefore(_path, _poly.nextElementSibling);
		else _up.appendChild(_path);
	}

	_path.setAttribute('d', pd);

	console.log(_1st);
	if(_1st) {
		/* copy attributes from original polygonal chain */
		for(let i = 0; i < _poly.attributes.length; i++) {
			let attr = _poly.attributes[i];
			_path.setAttribute(attr.name, attr.value);
		}

		s1 = getComputedStyle(_path);

		/* make sure they both have the same look */
		for(let i = 0; i < s0.length; i++) {
			let key = s0.item(i), val = s0.getPropertyValue(key);

			if(key !== 'd' && val !== s1.getPropertyValue(key)) {
				_path.style[key] = val;
			}
		}

		/* hide original and remove pointer events from equivalent */
		_poly.dataset.falpha = s0['fill-opacity'];
		_poly.dataset.salpha = s0['stroke-opacity'];
		_poly.style['fill-opacity'] = _poly.style['stroke-opacity'] = 0;
		_path.style['pointer-events'] = 'none';
	}

	return _path;
};

for(let i = 0; i < np; i++)
	_P.splice(i, 1, { ini: _P[i], fin: fillet(_P[i]) });

let observer = new MutationObserver(records => {
	records.forEach(r => {
		if (r.type === 'attributes') {
			if (r.attributeName === 'r' && r.target.matches('polygon,polyline')) {
				let curr = r.target.getAttribute(r.attributeName)
				if (!r.oldValue) {
					// it's newly gaining r
				} else if (!curr) {
					for(let i = 0; i < np; i++) {
						if(_P[i].ini === r.target) {
							_P[i].fin.parentNode.removeChild(_P[i].fin);
							if(_P[i].ini.dataset.falpha < 1)
								_P[i].ini.style['fill-opacity'] = _P[i].ini.dataset.falpha;
							else _P[i].ini.style.removeProperty('fill-opacity');
							if(_P[i].ini.dataset.salpha < 1)
								_P[i].ini.style['stroke-opacity'] = _P[i].ini.dataset.salpha;
							else _P[i].ini.style.removeProperty('stroke-opacity');
							_P[i].ini.removeAttribute('data-falpha');
							_P[i].ini.removeAttribute('data-salpha');
							_P.splice(i, 1);
							np--;
							break;
						}
					}
				} else {
					for(let i = 0; i < np; i++) {
						if(_P[i].ini === r.target) {
							_P[i].fin = fillet(_P[i].ini, _P[i].fin);
							break;
						}
					}
				}
			}
		}

		r.addedNodes.forEach((node) => {
			if(isImportant(node)) {
				_P.push({ini: node, fin: fillet(node)})
				np++;
			}
		});

		r.removedNodes.forEach(node => {
			if(isImportant(node)) {
				for(let i = 0; i < np; i++) {
					if(_P[i].ini === node) {
						_P[i].fin.parentNode.removeChild(_P[i].fin);
						_P.splice(i, 1);
						np--;
						break;
					}
				}
			}
		});
	});
});

observer.observe(document.documentElement, {
	attributes: true,
	childList: true,
	subtree: true,
	attributeOldValue: true
});

addEventListener('dblclick', e => {
	const _T = e.target;

	if(_T.matches('svg')) {
		let xmin = 0, ymin = 0, w = 300, h = 150, n = rand(10, 3), v = [], _dw;

		if(_T.getAttribute('viewBox'))
			[xmin, ymin, w, h] = _T.getAttribute('viewBox').split(' ').map(c => +c);

		for(let i = 0; i < n; i++) {
			v.push([xmin + rand(w), ymin + rand(h)]);
		}

		_dw = document.createElementNS(NS_URI, `poly${Math.random()>.5 ? 'gon' : 'line'}`)
		_dw.setAttribute('points', v.join(' '));
		_dw.setAttribute('r', rand(.1*Math.min(w, h), .01*Math.max(w, h), 1));
		_T.appendChild(_dw);
	}
	else {
		_T.parentNode.removeChild(_T);
	}
}, false);

addEventListener('click', e => {
	const _T = e.target;

	if(_T.matches(SEL)) {
		_T.setAttribute('r', +_T.getAttribute('r') + 5);
	}
}, false)

addEventListener('touchstart', e => {
	const _T = e.target;

	if(_T.matches(SEL)) {
		_T.removeAttribute('r');
	}
}, false)</script>
	<style>

		body {
			display: flex;
			flex-wrap: wrap;
			justify-content: space-around;
			align-items: space-around;
			margin: 0;
			height: 100vh;

			@media(orientation: portrait) {
				flex-direction: column;
			}
		}

		svg { flex: 1; }

		* {
			fill: none;
			stroke-width: 3px;
			vector-effect: non-scaling-stroke;
		}

		polygon, polyline { fill-opacity: .5 }

		polygon { fill: #c7a0ee }

		polyline { fill: #eec7a0 }

		[points] { opacity: .35; }

		[r] { stroke: #99a; }

		path { stroke: #ef9134 }

		.boo { stroke: #ef3491 }

		#boo { stroke-linecap: round }
	</style>
</head>
<body>
<svg viewBox='-50 -50 100 100'>
	<line y2='50' class='boo'/>
	<polygon points='7,-47 -43,-35 -38,26 -9,7 23,32 26,13 41,28 46,-47 21,-35 20,3 -27,-5 -25,-27 -3,-29'
					 stroke-dasharray='5'
					 r='14'/>
	<path d='M-23-15h40q-20 20-40 0'/>
</svg>
<svg viewBox='-50 -50 100 100'>
	<circle r='10' cx='9' cy='5'/>
	<polygon points='-45,-45 45,-45 45,45'/>
	<polyline points='26,4 16,-9 26,-37 0,-8 -28,-21 -11,-1 -30,13 -3,9 2,34 19,19'
					 r='14' id='boo' style='stroke-dasharray: 3 8' class='boo'/>
</svg>



</body></html>