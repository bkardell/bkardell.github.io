<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <style>
    x-slider { 
      width: 20em;
      height: 1.25em;
      --val: 0;
      --dif: calc(0.625em + -1*5px);
      --pos: calc(5px + .01*var(--val)*(100% - 2*5px));
    }

    x-slider::part(track) {
      background: #e4e7f5;
      border-radius: 1em;
      border-style: solid;
      margin: var(--dif);
      width: calc(20em + -2*var(--dif));  
    }

    x-slider::part(thumb) {
      background-color: purple;
    }

    x-slider::part(fill) {
      background: rgba(200, 200, 100, 0.5);
      border-radius: 1em;
      border-collapse: collapse;
    } 

  </style>
  <script>
    class XSlider extends HTMLElement {
      isDragging = false;
      constructor() {
        super();
        this.attachShadow({ mode: "open" });
        this.shadowRoot.innerHTML = `
          <style>
            .visually-hidden {
              background-color: pink;
              position: absolute;
              width: 1px;
              height: 1px;
              padding: 0;
              margin: -1px;
              overflow: hidden;
              clip: rect(0, 0, 0, 0);
              white-space: nowrap;
              border-width: 0;
            }

            [part=container] {
              height: 1em;
              padding: 0;
              margin: 0;
            }
            :host {
              display: block;
              background-color: none;
              margin: 2px;
              cursor: default;
              padding: unset;
              border: unset;
              user-select: none !important;
              height: 1em;
            }
            [part=track] {
              border: 1px dashed blue;
              background-color: lightgray;
              display: block !important;
              float: none !important;
              position: static !important;
              writing-mode: unset !important;
              direction: unset !important;
              block-size: 1em;
              box-sizing: border-box;
              user-select: none !important;
            }
            [part=fill] {
              border: 1px solid transparent;
              display: block !important;
              float: none !important;
              position: absolute !important;  
              margin: var(--dif);  
              top: calc(var(--dif) * 0.7);
              writing-mode: unset !important;
              direction: unset !important;
              block-size: 1em;
              width: 1em;
              box-sizing: border-box;
              background-color: blue;
              user-select: none !important;
            }
            [part=thumb] {
              display: block !important;
              float: none !important;
              position: absolute !important;
              writing-mode: unset !important;
              direction: unset !important;
              aspect-ratio: 1 / 1;
              height: 1em;
              width: 1em;
              top: calc(var(--dif) * 1.25);
              left: 0.7em;
              border: 0.1em solid pink;
              border-radius: 50%;
              background: currentColor;
              user-select: none !important;
            }
            .focused {
              border-color: lime;
            }
          </style>
          <div part="container">
            <div part="track"></div>
            <div part="fill"></div>
            <div part="thumb"></div>
            <div class="visually-hidden"><slot></slot></div>
          </div>
        `;
        let self = this;
        let thumb = this.shadowRoot.querySelector("[part=thumb]");
        let track = this.shadowRoot.querySelector("[part=track]");
        let fill = this.shadowRoot.querySelector("[part=fill]");
        let slot = this.shadowRoot.querySelector("slot");
        let container = this.shadowRoot.querySelector("[part=container]");
        this.thumb = thumb;
        this.fill = fill;
        this.container = container;


        let setWidthFromInput = (input) => {
          let unit = (this.offsetWidth - 12) / parseInt(input.max, 10);
          let newValue = (unit * input.value);
          setWidth({
            clientX: newValue
          }, true);

        }

        let divCoordsToRangeCoords = (e) => {
          return ((thumb.offsetLeft + 12) / this.offsetWidth) * 100;
        }

        let setWidth = (e, keys=false) => {
          if ((keys || this.isDragging) && (e.clientX <= (this.offsetWidth - 12))) {
          

            requestAnimationFrame(()=> {
              this.thumb.style.left = e.clientX + "px";
              this.fill.style.width = e.clientX + "px";
              slot.assignedElements()[0].value = divCoordsToRangeCoords(e);

            })
          }
        }

        container.addEventListener("slotchange", (e) => {
          console.log('slotchange')
          let inp = e.target.assignedElements()[0]
          setWidthFromInput(inp)
        })

        this.addEventListener("mousedown", (e) => {
          //e.preventDefault();
          this.isDragging = true;
          setWidth(e)
        });

        container.onmouseout = (e) => {
          if (e.relatedTarget && !e.relatedTarget.matches("x-slider, [part=container] > *")) {
            this.isDragging = false;
          }
        };
        this.onmousemove = (e) => {
          setWidth(e)
        };
        this.onmouseup = this.stopDragging.bind(this);
        this.addEventListener("focus", (e) => {
          console.log('hey')
          this.thumb.classList.add("focused")
        }, true)
        this.addEventListener("change",  (e) => {
          let input = e.target
          setWidthFromInput(input)
        });
      }

      moveElement(e) {}
      stopDragging() {
        this.isDragging = false;
      }
    }

    customElements.define("x-slider", XSlider);
    </script>
  </head>
  <body>
    <x-slider>
      <input type="range" min="0" max="100" value="90" step="10">
    </x-slider>

    <p>Ok, so...</p>


    <p>Today, each browser has different (and differently problematic) shadow dom structures for <code>&lt;input type="range"></code>. We're looking to potentially standardize something here. Ana Tudor has been working on this for a while and e'd like to be able to illustrate and explain the current idea and let people experiment before making actual standards proposals.  This is an attempt to figure out how we might do that.</p> 

    <p>It introduces a decorator custom element (rendered above):</p>

    <pre><code>&lt;x-slider>
  &lt;input type="range" min="0" max="100" value="90" step="10">
&lt;/x-slider></code></pre>

    <p>Inside, the Shadow DOM looks like this...</p>

    <pre><code>&lt;div part="container">
  &lt;div part="track">&lt;/div>
  &lt;div part="fill">&lt;/div>
  &lt;div part="thumb">&lt;/div>
  &lt;div class="visually-hidden">&lt;slot>&lt;/slot>&lt;/div>
&lt;/div></code></pre>

    <p>The important (perhaps questionable?) concept is that the input <em>remains</em> the actual input and all that is replaced is the visual rendering (attempting to kind of draw inspiration from canvas a11y).</p>

    <ul>
      <li>The range input is the range input</li>
      <li>None of the rendered stuff has any meaning, it's basically canvas but with CSS :)</li>
      <li>You can sequentially focus on the actual input and use arrow keys - those update the UI by simply reflecting the equivalent rendered view. The thumb appears focused (needs a little work).</li>
      <li>Updating with your pointer/mouse just does the inverse</li>
      <li>You can submit a form, it all works, etc...</li>
      <li><em><strong>You can style all the parts 1 way and it should work!</strong></em></li>
    </ul>





</body>
</html>




